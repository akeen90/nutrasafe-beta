<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NutraSafe Admin Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-functions-compat.js"></script>
    <script>
        // Initialize Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyAW1cyvgMe7jU38P6b1RgAOd7w6lCGK5lE",
            authDomain: "nutrasafe-705c7.firebaseapp.com",
            projectId: "nutrasafe-705c7",
            storageBucket: "nutrasafe-705c7.firebasestorage.app",
            messagingSenderId: "128150759188",
            appId: "1:128150759188:ios:cc965730162576d9574401"
        };
        firebase.initializeApp(firebaseConfig);
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --accent: #2563eb;
            --accent-hover: #1d4ed8;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --border: #e5e7eb;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-secondary);
            color: var(--text-primary);
            min-height: 100vh;
        }

        /* Header */
        .header {
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
            padding: 16px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .header h1 span {
            color: var(--accent);
        }

        /* Navigation */
        .nav-tabs {
            display: flex;
            gap: 8px;
        }

        .nav-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-tab:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .nav-tab.active {
            background: var(--accent);
            color: white;
        }

        .nav-badge {
            background: var(--error);
            color: white;
            font-size: 11px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 10px;
            min-width: 18px;
            text-align: center;
        }

        .nav-tab.active .nav-badge {
            background: white;
            color: var(--accent);
        }

        /* Main Content */
        .main-content {
            padding: 24px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .view {
            display: none;
        }

        .view.active {
            display: block;
        }

        /* Search and Filters */
        .search-section {
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
        }

        .search-row {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .search-input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            border-color: var(--accent);
        }

        .search-btn {
            padding: 12px 24px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .search-btn:hover {
            background: var(--accent-hover);
        }

        .filters-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-label {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .filter-select {
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 13px;
            outline: none;
            background: white;
            cursor: pointer;
        }

        .filter-select:focus {
            border-color: var(--accent);
        }

        /* Results Stats */
        .results-stats {
            font-size: 13px;
            color: var(--text-secondary);
            margin-left: auto;
        }

        /* Food List */
        .food-list {
            background: var(--bg-primary);
            border-radius: 12px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .food-item {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 16px;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }

        .food-item:last-child {
            border-bottom: none;
        }

        .food-item:hover {
            background: var(--bg-secondary);
        }

        .food-info h3 {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .food-info .meta {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .food-info .meta span {
            margin-right: 12px;
        }

        /* Quality Indicators */
        .quality-dots {
            display: flex;
            gap: 6px;
        }

        .quality-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            position: relative;
        }

        .quality-dot::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--text-primary);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            margin-bottom: 4px;
        }

        .quality-dot:hover::after {
            opacity: 1;
        }

        .quality-dot.good {
            background: var(--success);
        }

        .quality-dot.bad {
            background: var(--error);
        }

        /* Missing Info Badges */
        .missing-info {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .missing-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #fef2f2;
            color: var(--error);
            border: 1px solid #fecaca;
        }

        .missing-badge.warn {
            background: #fffbeb;
            color: var(--warning);
            border: 1px solid #fed7aa;
        }

        /* Modal Navigation */
        .modal-nav {
            display: flex;
            gap: 8px;
            margin-right: 16px;
        }

        .nav-arrow {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .nav-arrow:hover:not(:disabled) {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .nav-arrow:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .nav-position {
            font-size: 13px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            padding: 0 8px;
        }

        /* Action Buttons */
        .food-actions {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-danger {
            background: var(--error);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-success {
            background: #22c55e;
            color: white;
        }

        .btn-success:hover {
            background: #16a34a;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-info {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
        }

        .btn-info:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 20px;
            background: var(--bg-primary);
            border-top: 1px solid var(--border);
        }

        .pagination button {
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .pagination button:hover:not(:disabled) {
            border-color: var(--accent);
            color: var(--accent);
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination span {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-primary);
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: var(--bg-primary);
        }

        .modal-header h2 {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-body {
            padding: 20px;
        }

        .modal-footer {
            padding: 20px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            position: sticky;
            bottom: 0;
            background: var(--bg-primary);
        }

        /* Form Styles */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .form-group.full-width {
            grid-column: 1 / -1;
        }

        .form-group label {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            border-color: var(--accent);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        .form-section h3 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        /* Reports View */
        .reports-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .reports-filters {
            display: flex;
            gap: 12px;
        }

        .reports-bulk-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .select-all-label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .select-all-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .report-checkbox {
            display: flex;
            align-items: center;
            margin-right: 10px;
        }

        .report-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .report-card {
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            box-shadow: var(--shadow);
        }

        .report-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 8px;
        }

        .report-header .report-title {
            flex: 1;
        }

        .report-header .report-status {
            margin-left: auto;
        }

        .report-title {
            font-size: 16px;
            font-weight: 600;
        }

        .report-status {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .report-status.pending {
            background: #fef3c7;
            color: #92400e;
        }

        .report-status.in_progress {
            background: #dbeafe;
            color: #1e40af;
        }

        .report-status.resolved {
            background: #dcfce7;
            color: #166534;
        }

        .report-meta {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .report-meta span {
            margin-right: 16px;
        }

        .report-description {
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-primary);
            background: var(--bg-secondary);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .report-actions {
            display: flex;
            gap: 8px;
        }

        /* Loading State */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 12px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 24px;
            right: 24px;
            z-index: 2000;
        }

        .toast {
            background: var(--text-primary);
            color: white;
            padding: 14px 20px;
            border-radius: 8px;
            margin-top: 8px;
            box-shadow: var(--shadow-lg);
            animation: slideIn 0.3s ease;
        }

        .toast.success {
            background: var(--success);
        }

        .toast.error {
            background: var(--error);
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* AI Actions */
        .ai-actions {
            display: flex;
            gap: 12px;
            align-items: center;
            margin: 16px 0;
            padding: 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .btn-ai {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-ai:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        .btn-ai:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        #ai-status {
            font-size: 13px;
            color: var(--text-secondary);
            margin-left: auto;
        }

        .ai-suggestions {
            background: #f0fdf4;
            border: 1px solid var(--success);
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
        }

        .ai-suggestions h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--success);
            margin-bottom: 12px;
        }

        .ai-suggestion-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #dcfce7;
        }

        .ai-suggestion-item:last-child {
            border-bottom: none;
        }

        .suggestion-label {
            font-size: 13px;
            color: var(--text-secondary);
            min-width: 100px;
        }

        .suggestion-value {
            flex: 1;
            font-size: 14px;
            color: var(--text-primary);
            margin: 0 12px;
        }

        .suggestion-old {
            text-decoration: line-through;
            color: var(--error);
            margin-right: 8px;
        }

        .suggestion-new {
            color: var(--success);
            font-weight: 500;
        }

        .apply-suggestion {
            color: var(--accent);
            cursor: pointer;
            font-weight: 500;
            font-size: 13px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .apply-suggestion:hover {
            background: var(--bg-tertiary);
        }

        .report-info-section {
            background: #fef3c7;
            border: 1px solid var(--warning);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .report-info-section h4 {
            font-size: 14px;
            font-weight: 600;
            color: #92400e;
            margin-bottom: 8px;
        }

        .report-info-section .report-type {
            display: inline-block;
            background: #fde68a;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            color: #92400e;
            margin-bottom: 8px;
        }

        .report-info-section .report-desc {
            font-size: 14px;
            color: #78350f;
            line-height: 1.5;
        }

        /* Database Check View */
        .scan-controls {
            display: flex;
            gap: 16px;
            align-items: center;
            padding: 20px;
            background: var(--bg-primary);
            border-radius: 12px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
        }

        .scan-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .scan-control-group label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .btn-scan {
            padding: 12px 24px;
            font-size: 15px;
        }

        .scan-progress {
            padding: 24px;
            background: var(--bg-primary);
            border-radius: 12px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
        }

        .progress-bar {
            height: 24px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), #8b5cf6);
            border-radius: 12px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-text {
            text-align: center;
            margin-top: 12px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .results-summary {
            display: flex;
            gap: 32px;
            padding: 20px;
            background: var(--bg-primary);
            border-radius: 12px;
            box-shadow: var(--shadow);
            margin-bottom: 20px;
        }

        .summary-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .stat-value.stat-issues {
            color: var(--warning);
        }

        .stat-label {
            font-size: 13px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .issue-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
        }

        .filter-btn {
            padding: 8px 16px;
            border: 1px solid var(--border);
            border-radius: 20px;
            background: var(--bg-primary);
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .filter-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .filtered-count {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        /* Issue Badges */
        .issue-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            margin-right: 6px;
            margin-bottom: 4px;
        }

        .issue-badge.issue-misspelling {
            background: #fef3c7;
            color: #92400e;
        }

        .issue-badge.issue-missing-nutrition {
            background: #fef2f2;
            color: #dc2626;
        }

        .issue-badge.issue-non-word {
            background: #f3e8ff;
            color: #7c3aed;
        }

        .issue-badge.issue-missing-barcode {
            background: #e0f2fe;
            color: #0369a1;
        }

        .issue-badge.issue-missing-ingredients {
            background: #fce7f3;
            color: #be185d;
        }

        .issue-badge.issue-impossible-nutrition {
            background: #fee2e2;
            color: #dc2626;
            font-weight: 600;
        }

        .issue-badge.issue-weird-spacing {
            background: #fef9c3;
            color: #a16207;
        }

        .issue-badge.issue-html-code {
            background: #fce4ec;
            color: #c2185b;
            font-weight: 600;
        }

        /* Highlighted text for misspellings */
        mark.misspelling {
            background: #fde68a;
            color: #92400e;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: 500;
        }

        /* Issue Card */
        .issue-card {
            position: relative;
        }

        .issue-card .issues-row {
            display: flex;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        .issue-card .checkbox-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .issue-card .checkbox-label:hover {
            background: var(--bg-tertiary);
        }

        .issue-card .checkbox-label input {
            cursor: pointer;
        }

        .issue-card.marked-delete {
            background: #fef2f2;
            border-color: var(--error);
        }

        .issue-card.selected {
            background: #eff6ff;
            border-color: var(--accent);
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Session Sidebar for Database Check */
        .database-check-layout {
            display: flex;
            gap: 20px;
            min-height: calc(100vh - 180px);
        }

        .session-sidebar {
            width: 280px;
            flex-shrink: 0;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .session-sidebar h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0 0 12px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-list {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .session-item {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .session-item:hover {
            border-color: var(--accent);
        }

        .session-item.active {
            border-color: var(--accent);
            background: rgba(99, 102, 241, 0.05);
        }

        .session-item .session-index {
            font-weight: 600;
            font-size: 13px;
            color: var(--text-primary);
        }

        .session-item .session-date {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .session-item .session-stats {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 6px;
            display: flex;
            gap: 12px;
        }

        .session-item .session-stats .stat-issues {
            color: var(--error);
            font-weight: 500;
        }

        .session-item .session-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .session-item .btn-session {
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
        }

        .session-item .btn-session.delete {
            background: #fee2e2;
            color: var(--error);
        }

        .session-item .btn-session.delete:hover {
            background: #fecaca;
        }

        .database-check-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .no-sessions {
            color: var(--text-secondary);
            font-size: 13px;
            text-align: center;
            padding: 20px;
        }

        /* Batch Actions Footer - Fixed at bottom */
        .batch-actions {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
            z-index: 100;
        }

        /* Add padding to main content so it doesn't get hidden behind fixed footer */
        .database-check-main {
            padding-bottom: 80px;
        }

        /* Issues List Container with Scroll */
        .issues-list-container {
            flex: 1;
            overflow-y: auto;
            min-height: 400px;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        /* Compact tool sections */
        .ai-batch-section,
        .calories-review-section {
            padding: 12px 16px;
            margin-bottom: 8px;
        }

        .ai-batch-section h4,
        .calories-review-section h4 {
            font-size: 13px;
            margin-bottom: 8px;
        }

        .compact-tools-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .compact-tools-row > div {
            flex: 1;
            min-width: 300px;
        }

        /* Pagination for Issues */
        .issues-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 16px;
            background: var(--bg-primary);
            border-top: 1px solid var(--border);
            border-radius: 0 0 12px 12px;
        }

        .issues-pagination button {
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .issues-pagination button:hover:not(:disabled) {
            border-color: var(--accent);
            color: var(--accent);
        }

        .issues-pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .issues-pagination .page-info {
            font-size: 13px;
            color: var(--text-secondary);
            min-width: 120px;
            text-align: center;
        }

        .issues-pagination .page-jump {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: 16px;
        }

        .issues-pagination .page-jump input {
            width: 60px;
            padding: 6px 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }

        /* Select All Controls */
        .select-all-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .select-all-controls .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            cursor: pointer;
        }

        .select-all-controls .checkbox-label input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .select-all-controls .selection-info {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .select-all-controls .selection-actions {
            margin-left: auto;
            display: flex;
            gap: 8px;
        }

        /* AI Batch Actions */
        .ai-batch-section {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd;
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 16px;
        }

        .ai-batch-section h4 {
            font-size: 14px;
            font-weight: 600;
            color: #0369a1;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-batch-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn-ai-batch {
            background: linear-gradient(135deg, #0ea5e9, #0284c7);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-ai-batch:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
        }

        .btn-ai-batch:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .ai-batch-status {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .ai-progress-bar {
            flex: 1;
            min-width: 200px;
            height: 8px;
            background: #e0f2fe;
            border-radius: 4px;
            overflow: hidden;
        }

        .ai-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0ea5e9, #0284c7);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        /* Duplicate Badge */
        .issue-badge.issue-duplicate {
            background: #fef3c7;
            color: #b45309;
            font-weight: 600;
        }

        /* Calories Mismatch Section */
        .calories-review-section {
            background: linear-gradient(135deg, #fef9c3 0%, #fef08a 100%);
            border: 1px solid #fde047;
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 16px;
        }

        .calories-review-section h4 {
            font-size: 14px;
            font-weight: 600;
            color: #a16207;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .calories-review-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn-calories {
            background: linear-gradient(135deg, #eab308, #ca8a04);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-calories:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(234, 179, 8, 0.3);
        }

        .btn-calories:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .pending-summary {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .pending-summary .separator {
            color: var(--border);
        }

        .batch-buttons {
            display: flex;
            gap: 12px;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .empty-state h3 {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .empty-state p {
            font-size: 14px;
            max-width: 400px;
            margin: 0 auto;
            line-height: 1.6;
        }

        /* ========================================
           VERIFICATION SYSTEM STYLES
           ======================================== */

        /* Verification Status Badges */
        .verification-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 16px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .verification-badge.status-unverified {
            background: #f3f4f6;
            color: #6b7280;
            border: 1px solid #d1d5db;
        }

        .verification-badge.status-verified {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #86efac;
        }

        .verification-badge.status-updated {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #93c5fd;
        }

        .verification-badge.status-flagged {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fcd34d;
        }

        .verification-badge.status-no-action {
            background: #e5e7eb;
            color: #4b5563;
            border: 1px solid #9ca3af;
        }

        /* UK-Specific Verification Status Badges */
        .verification-badge.status-uk-verified {
            background: linear-gradient(135deg, #dcfce7, #bbf7d0);
            color: #14532d;
            border: 2px solid #22c55e;
        }

        .verification-badge.status-uk-verified::before {
            content: 'üá¨üáß ';
        }

        .verification-badge.status-non-uk-data {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            color: #78350f;
            border: 2px solid #f59e0b;
        }

        .verification-badge.status-non-uk-data::before {
            content: '‚ö†Ô∏è ';
        }

        .verification-badge.status-insufficient-uk-data {
            background: linear-gradient(135deg, #fee2e2, #fecaca);
            color: #991b1b;
            border: 2px solid #ef4444;
        }

        .verification-badge.status-insufficient-uk-data::before {
            content: '‚ùå ';
        }

        /* UK Warning Banner */
        .uk-warning-banner {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border: 2px solid #f59e0b;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .uk-warning-banner .flag {
            font-size: 24px;
        }

        .uk-warning-banner .message {
            flex: 1;
        }

        .uk-warning-banner .message strong {
            color: #92400e;
            display: block;
            font-size: 14px;
        }

        .uk-warning-banner .message p {
            color: #78350f;
            font-size: 12px;
            margin: 4px 0 0;
        }

        /* Source Country Flag */
        .source-country-flag {
            font-size: 16px;
            margin-right: 6px;
        }

        /* Confidence Score Indicator */
        .confidence-score {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .confidence-bar {
            width: 60px;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .confidence-fill.high { background: #22c55e; }
        .confidence-fill.medium { background: #f59e0b; }
        .confidence-fill.low { background: #ef4444; }

        /* Verification Actions Panel */
        .verification-actions-panel {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .verification-actions-panel h3 {
            font-size: 16px;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .verification-actions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .verify-action-btn {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding: 14px 16px;
            border: 2px solid transparent;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .verify-action-btn .btn-title {
            font-size: 14px;
            margin-bottom: 4px;
        }

        .verify-action-btn .btn-desc {
            font-size: 11px;
            font-weight: 400;
            opacity: 0.8;
        }

        .verify-action-btn.verify-sources {
            background: linear-gradient(135deg, #0ea5e9, #0284c7);
            color: white;
        }

        .verify-action-btn.verify-sources:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(14, 165, 233, 0.3);
        }

        .verify-action-btn.fix-nutrition {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
        }

        .verify-action-btn.fix-nutrition:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.3);
        }

        .verify-action-btn.fix-ingredients {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
        }

        .verify-action-btn.fix-ingredients:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.3);
        }

        .verify-action-btn.flag-review {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
        }

        .verify-action-btn.flag-review:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.3);
        }

        .verify-action-btn.force-rerun {
            background: #64748b;
            color: white;
        }

        .verify-action-btn.force-rerun:hover {
            background: #475569;
        }

        .verify-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        /* Verification Modal */
        .verification-modal {
            max-width: 900px;
        }

        .verification-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        }

        .verification-product-info {
            flex: 1;
        }

        .verification-product-info h2 {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .verification-product-info .product-meta {
            font-size: 13px;
            color: #64748b;
        }

        .verification-status-area {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Side-by-Side Comparison */
        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            background: #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
            margin: 20px;
        }

        .comparison-column {
            background: white;
            padding: 20px;
        }

        .comparison-column h4 {
            font-size: 14px;
            font-weight: 700;
            color: #374151;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .comparison-column.original h4 {
            color: #6b7280;
        }

        .comparison-column.verified h4 {
            color: #0369a1;
        }

        .comparison-field {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .comparison-field:nth-child(odd) {
            background: #f9fafb;
        }

        .comparison-field .field-name {
            font-weight: 500;
            color: #4b5563;
        }

        .comparison-field .field-value {
            font-weight: 600;
            color: #111827;
        }

        .comparison-field .field-value.changed {
            color: #059669;
            background: #ecfdf5;
            padding: 2px 8px;
            border-radius: 4px;
        }

        .comparison-field .field-value.invalid {
            color: #dc2626;
        }

        .comparison-field .field-confidence {
            font-size: 11px;
            color: #6b7280;
            margin-left: 8px;
        }

        /* Change Log */
        .change-log {
            margin: 20px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .change-log h4 {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 12px;
            color: #374151;
        }

        .change-log-entry {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid #e5e7eb;
        }

        .change-log-entry .field-badge {
            background: #dbeafe;
            color: #1e40af;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            min-width: 80px;
            text-align: center;
        }

        .change-log-entry .change-values {
            flex: 1;
        }

        .change-log-entry .old-value {
            text-decoration: line-through;
            color: #dc2626;
            font-size: 13px;
        }

        .change-log-entry .arrow {
            color: #9ca3af;
            margin: 0 8px;
        }

        .change-log-entry .new-value {
            color: #059669;
            font-weight: 600;
            font-size: 13px;
        }

        .change-log-entry .change-reason {
            font-size: 11px;
            color: #6b7280;
            margin-top: 4px;
        }

        .change-log-entry .source-link {
            font-size: 11px;
            color: #2563eb;
            text-decoration: underline;
            cursor: pointer;
        }

        /* Source List */
        .sources-list {
            margin: 20px;
            padding: 16px;
            background: #f0fdf4;
            border: 1px solid #86efac;
            border-radius: 8px;
        }

        .sources-list h4 {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 12px;
            color: #166534;
        }

        .source-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 6px;
        }

        .source-item .source-tier {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .source-tier.tier-1 {
            background: #dcfce7;
            color: #166534;
        }

        .source-tier.tier-2 {
            background: #dbeafe;
            color: #1e40af;
        }

        .source-tier.tier-3 {
            background: #f3e8ff;
            color: #7c3aed;
        }

        .source-item .source-name {
            font-weight: 600;
            font-size: 13px;
            color: #374151;
        }

        .source-item .source-url {
            font-size: 11px;
            color: #2563eb;
            text-decoration: underline;
            cursor: pointer;
            word-break: break-all;
        }

        /* Verification Actions Footer */
        .verification-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: #f8fafc;
            border-top: 1px solid #e2e8f0;
        }

        .verification-footer .action-group {
            display: flex;
            gap: 10px;
        }

        .btn-accept {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-accept:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
        }

        .btn-reject {
            background: #dc2626;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-reject:hover {
            background: #b91c1c;
        }

        .btn-flag {
            background: #f59e0b;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-flag:hover {
            background: #d97706;
        }

        /* Dry Run Indicator */
        .dry-run-banner {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border: 2px dashed #f59e0b;
            border-radius: 8px;
            padding: 12px 20px;
            margin: 0 20px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .dry-run-banner .icon {
            font-size: 24px;
        }

        .dry-run-banner .text {
            flex: 1;
        }

        .dry-run-banner .text strong {
            color: #92400e;
            font-size: 14px;
        }

        .dry-run-banner .text p {
            font-size: 12px;
            color: #78350f;
            margin: 4px 0 0;
        }

        /* Audit Log Section */
        .audit-log-section {
            margin: 20px;
            padding: 16px;
            background: #fafafa;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .audit-log-section h4 {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 12px;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .audit-entry {
            display: flex;
            gap: 12px;
            padding: 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 8px;
            border-left: 3px solid #d1d5db;
        }

        .audit-entry.entry-lookup { border-left-color: #3b82f6; }
        .audit-entry.entry-verify { border-left-color: #22c55e; }
        .audit-entry.entry-update { border-left-color: #0ea5e9; }
        .audit-entry.entry-flag { border-left-color: #f59e0b; }
        .audit-entry.entry-skip { border-left-color: #6b7280; }

        .audit-entry .timestamp {
            font-size: 11px;
            color: #6b7280;
            min-width: 140px;
        }

        .audit-entry .action-type {
            font-size: 12px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 4px;
            min-width: 70px;
            text-align: center;
        }

        .audit-entry .action-type.type-lookup { background: #dbeafe; color: #1e40af; }
        .audit-entry .action-type.type-verify { background: #dcfce7; color: #166534; }
        .audit-entry .action-type.type-update { background: #e0f2fe; color: #0369a1; }
        .audit-entry .action-type.type-flag { background: #fef3c7; color: #92400e; }
        .audit-entry .action-type.type-skip { background: #f3f4f6; color: #4b5563; }

        .audit-entry .details {
            flex: 1;
            font-size: 12px;
            color: #374151;
        }

        /* Verification Progress Overlay */
        .verification-progress-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .verification-progress-card {
            background: white;
            border-radius: 16px;
            padding: 32px 40px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }

        .verification-progress-card h3 {
            font-size: 18px;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 8px;
        }

        .verification-progress-card .subtitle {
            font-size: 13px;
            color: #64748b;
            margin-bottom: 24px;
        }

        .verification-progress-bar {
            height: 12px;
            background: #e5e7eb;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .verification-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0ea5e9, #8b5cf6);
            border-radius: 6px;
            transition: width 0.3s ease;
        }

        .verification-progress-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-top: 24px;
        }

        .progress-stat {
            text-align: center;
        }

        .progress-stat .value {
            font-size: 24px;
            font-weight: 700;
            color: #1e293b;
        }

        .progress-stat .label {
            font-size: 11px;
            color: #64748b;
            margin-top: 2px;
        }

        .progress-stat.stat-verified .value { color: #22c55e; }
        .progress-stat.stat-updated .value { color: #0ea5e9; }
        .progress-stat.stat-flagged .value { color: #f59e0b; }
        .progress-stat.stat-skipped .value { color: #6b7280; }

        .verification-log-stream {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 20px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
            text-align: left;
            font-family: monospace;
            font-size: 11px;
        }

        .verification-log-stream .log-line {
            padding: 4px 0;
            border-bottom: 1px solid #e5e7eb;
        }

        .verification-log-stream .log-line:last-child {
            border-bottom: none;
        }

        .verification-log-stream .log-success { color: #22c55e; }
        .verification-log-stream .log-update { color: #0ea5e9; }
        .verification-log-stream .log-warn { color: #f59e0b; }
        .verification-log-stream .log-skip { color: #6b7280; }
        .verification-log-stream .log-error { color: #dc2626; }

        /* Issue Ledger Styles */
        .ledger-summary {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            background: var(--bg-primary);
            padding: 16px 20px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            margin-bottom: 12px;
        }

        .ledger-stat {
            text-align: center;
            padding: 8px;
            border-radius: 6px;
        }

        .ledger-stat .stat-value {
            font-size: 24px;
            font-weight: 700;
            line-height: 1.2;
        }

        .ledger-stat .stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .ledger-stat.total { background: #f1f5f9; }
        .ledger-stat.total .stat-value { color: var(--text-primary); }

        .ledger-stat.pending { background: #fff7ed; }
        .ledger-stat.pending .stat-value { color: #ea580c; }

        .ledger-stat.resolved { background: #f0fdf4; }
        .ledger-stat.resolved .stat-value { color: #16a34a; }

        .ledger-stat.skipped { background: #f8fafc; }
        .ledger-stat.skipped .stat-value { color: #64748b; }

        .ledger-stat.errors { background: #fef2f2; }
        .ledger-stat.errors .stat-value { color: #dc2626; }

        /* Issue Tabs */
        .issue-tabs {
            display: flex;
            gap: 4px;
            background: var(--bg-tertiary);
            padding: 4px;
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .issue-tab {
            flex: 1;
            padding: 8px 12px;
            border: none;
            background: transparent;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .issue-tab:hover {
            background: rgba(255,255,255,0.5);
            color: var(--text-primary);
        }

        .issue-tab.active {
            background: var(--bg-primary);
            color: var(--text-primary);
            box-shadow: var(--shadow);
        }

        .issue-tab .tab-count {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 10px;
            background: var(--bg-tertiary);
        }

        .issue-tab.active .tab-count {
            background: var(--accent);
            color: white;
        }

        /* Before/After Comparison */
        .change-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 8px;
            margin-top: 12px;
        }

        .comparison-side {
            background: var(--bg-primary);
            border-radius: 6px;
            padding: 12px;
        }

        .comparison-side h4 {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .comparison-side.before h4 { color: #dc2626; }
        .comparison-side.after h4 { color: #16a34a; }

        .comparison-field {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid var(--border);
            font-size: 13px;
        }

        .comparison-field:last-child {
            border-bottom: none;
        }

        .comparison-field .field-name {
            color: var(--text-secondary);
        }

        .comparison-field .field-value {
            font-weight: 500;
        }

        .comparison-field .field-value.changed {
            color: #ea580c;
            text-decoration: line-through;
        }

        .comparison-field .field-value.new {
            color: #16a34a;
            font-weight: 600;
        }

        /* Issue Status Badge */
        .issue-status-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
        }

        .issue-status-badge.status-pending {
            background: #fff7ed;
            color: #ea580c;
        }

        .issue-status-badge.status-resolved {
            background: #f0fdf4;
            color: #16a34a;
        }

        .issue-status-badge.status-skipped {
            background: #f8fafc;
            color: #64748b;
        }

        .issue-status-badge.status-error {
            background: #fef2f2;
            color: #dc2626;
        }

        /* Change Log Accordion */
        .change-log {
            margin-top: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
        }

        .change-log-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }

        .change-log-header:hover {
            background: var(--border);
        }

        .change-log-content {
            padding: 12px 16px;
            display: none;
        }

        .change-log-content.expanded {
            display: block;
        }

        .change-entry {
            display: flex;
            gap: 12px;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
            font-size: 12px;
        }

        .change-entry:last-child {
            border-bottom: none;
        }

        .change-entry .change-field {
            font-weight: 600;
            color: var(--text-primary);
            min-width: 100px;
        }

        .change-entry .change-values {
            flex: 1;
        }

        .change-entry .old-val {
            color: #dc2626;
            text-decoration: line-through;
        }

        .change-entry .new-val {
            color: #16a34a;
            font-weight: 500;
        }

        .change-entry .change-reason {
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Session sidebar ledger stats */
        .session-ledger-stats {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
        }

        .session-ledger-stat {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .session-ledger-stat.resolved {
            background: #dcfce7;
            color: #16a34a;
        }

        .session-ledger-stat.pending {
            background: #ffedd5;
            color: #ea580c;
        }

        .session-ledger-stat.skipped {
            background: #f1f5f9;
            color: #64748b;
        }

        /* UK Discovery Panel Styles */
        .discovery-modal {
            max-width: 900px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .discovery-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
        }

        .discovery-header h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .discovery-header .product-info {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .discovery-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .discovery-section {
            margin-bottom: 24px;
        }

        .discovery-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .source-cards {
            display: grid;
            gap: 12px;
        }

        .source-card {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .source-card:hover {
            border-color: var(--accent);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.1);
        }

        .source-card.selected {
            border-color: var(--accent);
            background: #f0f9ff;
        }

        .source-card.extracting {
            opacity: 0.7;
            pointer-events: none;
        }

        .source-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .source-name {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
        }

        .source-type-badge {
            font-size: 10px;
            font-weight: 500;
            padding: 2px 8px;
            border-radius: 4px;
            text-transform: uppercase;
        }

        .source-type-badge.supermarket {
            background: #dcfce7;
            color: #16a34a;
        }

        .source-type-badge.retailer {
            background: #e0f2fe;
            color: #0284c7;
        }

        .source-type-badge.manufacturer {
            background: #fef3c7;
            color: #d97706;
        }

        .source-url {
            font-size: 12px;
            color: var(--text-secondary);
            word-break: break-all;
            margin-bottom: 8px;
        }

        .source-confidence {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .confidence-bar-mini {
            flex: 1;
            max-width: 100px;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
        }

        .confidence-bar-mini .fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s;
        }

        .confidence-bar-mini .fill.high { background: #22c55e; }
        .confidence-bar-mini .fill.medium { background: #f59e0b; }
        .confidence-bar-mini .fill.low { background: #ef4444; }

        .source-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .source-actions .btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        .extraction-preview {
            margin-top: 16px;
            padding: 16px;
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            border-radius: 8px;
        }

        .extraction-preview h4 {
            font-size: 13px;
            font-weight: 600;
            color: #16a34a;
            margin-bottom: 12px;
        }

        .extraction-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 12px;
        }

        .extraction-field {
            padding: 8px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
        }

        .extraction-field .label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }

        .extraction-field .value {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .extraction-field .value.changed {
            color: #16a34a;
        }

        .manual-search-section {
            background: #fffbeb;
            border: 1px solid #fde68a;
            border-radius: 10px;
            padding: 16px;
        }

        .manual-search-section h4 {
            font-size: 13px;
            font-weight: 600;
            color: #b45309;
            margin-bottom: 12px;
        }

        .search-links-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 8px;
        }

        .search-link {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 12px;
            background: white;
            border: 1px solid #fde68a;
            border-radius: 6px;
            text-decoration: none;
            color: var(--text-primary);
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .search-link:hover {
            border-color: #f59e0b;
            background: #fffbeb;
        }

        .search-link img {
            width: 16px;
            height: 16px;
        }

        .discovery-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
        }

        .discovery-footer .status-text {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .discovery-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            gap: 12px;
        }

        .discovery-loading .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #e5e7eb;
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .discovery-error {
            padding: 20px;
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 8px;
            text-align: center;
            color: #dc2626;
        }

        .discovery-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 500;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .discovery-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(37, 99, 235, 0.3);
        }

        .discovery-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Batch Discovery Results Panel - Now inline instead of floating */
        .batch-results-panel {
            background: var(--bg-primary);
            border-radius: 12px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .batch-results-header {
            padding: 12px 16px;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .batch-results-header h3 {
            font-size: 14px;
            font-weight: 600;
            margin: 0;
        }

        .batch-results-stats {
            display: flex;
            gap: 12px;
            font-size: 12px;
        }

        .batch-stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .batch-stat.success { color: #bbf7d0; }
        .batch-stat.failed { color: #fecaca; }
        .batch-stat.skipped { color: #94a3b8; }

        .batch-filter-btn {
            padding: 4px 10px;
            font-size: 12px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: all 0.15s;
        }
        .batch-filter-btn:hover {
            background: var(--bg-secondary);
        }
        .batch-filter-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .batch-results-list {
            flex: 1;
            overflow-y: auto;
            max-height: 250px;
        }

        .batch-result-item {
            padding: 10px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 12px;
            align-items: flex-start;
        }

        .batch-result-item:last-child {
            border-bottom: none;
        }

        .batch-result-status {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
        }

        .batch-result-status.success {
            background: #dcfce7;
            color: #16a34a;
        }

        .batch-result-status.failed {
            background: #fef2f2;
            color: #dc2626;
        }

        .batch-result-status.skipped {
            background: #f1f5f9;
            color: #64748b;
        }

        .batch-result-status.processing {
            background: #e0f2fe;
            color: #0284c7;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .batch-result-content {
            flex: 1;
            min-width: 0;
        }

        .batch-result-name {
            font-weight: 500;
            font-size: 13px;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .batch-result-source {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        .batch-result-source a {
            color: var(--accent);
            text-decoration: none;
        }

        .batch-result-changes {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 4px;
        }

        .change-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #dcfce7;
            color: #16a34a;
        }

        .batch-result-error {
            font-size: 11px;
            color: #dc2626;
            margin-top: 2px;
        }

        .batch-results-footer {
            padding: 10px 16px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .batch-progress-bar {
            flex: 1;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin-right: 12px;
        }

        .batch-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #16a34a);
            transition: width 0.3s;
        }

        .batch-results-close {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        /* Duplicate Groups Panel */
        .duplicate-groups-panel {
            background: var(--bg-primary);
            border-radius: 12px;
            border: 2px solid #f59e0b;
            margin-bottom: 16px;
            overflow: hidden;
        }

        .dup-panel-header {
            padding: 12px 16px;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dup-panel-header h3 {
            font-size: 14px;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dup-panel-header h3 span {
            font-weight: 400;
            opacity: 0.9;
        }

        .dup-panel-actions {
            display: flex;
            gap: 8px;
            padding: 10px 16px;
            background: #fffbeb;
            border-bottom: 1px solid #fde68a;
        }

        .dup-groups-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .dup-group {
            border-bottom: 1px solid var(--border);
            padding: 12px 16px;
        }

        .dup-group:last-child {
            border-bottom: none;
        }

        .dup-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .dup-group-title {
            font-weight: 600;
            font-size: 13px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dup-group-title .dup-type-badge {
            font-size: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            background: #fef3c7;
            color: #92400e;
            font-weight: 500;
        }

        .dup-group-actions {
            display: flex;
            gap: 6px;
        }

        .dup-group-items {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding-left: 8px;
            border-left: 3px solid #fde68a;
        }

        .dup-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            font-size: 12px;
        }

        .dup-item.canonical {
            background: #dcfce7;
            border: 1px solid #86efac;
        }

        .dup-item-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .dup-item-name {
            flex: 1;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dup-item-meta {
            color: var(--text-secondary);
            font-size: 11px;
        }

        .dup-item-actions {
            display: flex;
            gap: 4px;
        }

        .dup-item-btn {
            padding: 3px 8px;
            font-size: 10px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: all 0.15s;
        }

        .dup-item-btn:hover {
            background: var(--bg-secondary);
        }

        .dup-item-btn.keep {
            color: #16a34a;
            border-color: #16a34a;
        }

        .dup-item-btn.keep:hover {
            background: #dcfce7;
        }

        .dup-item-btn.delete {
            color: #dc2626;
            border-color: #dc2626;
        }

        .dup-item-btn.delete:hover {
            background: #fef2f2;
        }

        /* Category Summary Dashboard */
        .category-dashboard {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .category-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .category-cards {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
        }

        @media (max-width: 900px) {
            .category-cards {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 500px) {
            .category-cards {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .category-card {
            background: white;
            border-radius: 10px;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .category-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .category-card.active {
            border-color: var(--accent);
            background: #eff6ff;
        }

        .category-card.duplicates { border-left: 4px solid #f59e0b; }
        .category-card.duplicates:hover { background: #fffbeb; }
        .category-card.missing { border-left: 4px solid #8b5cf6; }
        .category-card.missing:hover { background: #f5f3ff; }
        .category-card.invalid { border-left: 4px solid #ef4444; }
        .category-card.invalid:hover { background: #fef2f2; }
        .category-card.calories { border-left: 4px solid #3b82f6; }
        .category-card.calories:hover { background: #eff6ff; }
        .category-card.text { border-left: 4px solid #10b981; }
        .category-card.text:hover { background: #ecfdf5; }
        .category-card.multiple { border-left: 4px solid #64748b; }
        .category-card.multiple:hover { background: #f8fafc; }

        .category-icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .category-count {
            font-size: 22px;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1.1;
        }

        .category-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Activity Log Panel */
        .activity-log-panel {
            background: #1e293b;
            border-radius: 10px;
            margin-bottom: 16px;
            overflow: hidden;
            font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Monaco, Consolas, monospace;
        }

        .activity-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            background: #0f172a;
            color: #94a3b8;
            font-size: 12px;
            font-weight: 600;
        }

        .activity-log-content {
            max-height: 150px;
            overflow-y: auto;
            padding: 8px 0;
        }

        .activity-log-content::-webkit-scrollbar {
            width: 6px;
        }

        .activity-log-content::-webkit-scrollbar-track {
            background: #1e293b;
        }

        .activity-log-content::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }

        .activity-log-empty {
            padding: 16px;
            text-align: center;
            color: #64748b;
            font-size: 12px;
        }

        .activity-log-entry {
            display: flex;
            gap: 10px;
            padding: 6px 14px;
            font-size: 11px;
            line-height: 1.4;
            border-bottom: 1px solid #334155;
        }

        .activity-log-entry:last-child {
            border-bottom: none;
        }

        .activity-log-time {
            color: #64748b;
            flex-shrink: 0;
            font-size: 10px;
        }

        .activity-log-icon {
            flex-shrink: 0;
            width: 16px;
            text-align: center;
        }

        .activity-log-message {
            flex: 1;
            color: #e2e8f0;
            word-break: break-word;
        }

        .activity-log-entry.success .activity-log-icon { color: #4ade80; }
        .activity-log-entry.error .activity-log-icon { color: #f87171; }
        .activity-log-entry.warning .activity-log-icon { color: #fbbf24; }
        .activity-log-entry.info .activity-log-icon { color: #60a5fa; }

        .activity-log-entry.success .activity-log-message { color: #86efac; }
        .activity-log-entry.error .activity-log-message { color: #fca5a5; }
        .activity-log-entry.warning .activity-log-message { color: #fde68a; }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 12px;
                padding: 12px 16px;
            }

            .search-row {
                flex-direction: column;
            }

            .filters-row {
                flex-direction: column;
                align-items: flex-start;
            }

            .form-grid {
                grid-template-columns: 1fr;
            }

            .food-item {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .food-actions {
                justify-content: flex-start;
            }
        }

        /* Email Marketing Styles */
        .email-marketing-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .email-header {
            margin-bottom: 24px;
        }

        .email-header h2 {
            color: #1a1a2e;
            font-size: 24px;
            margin-bottom: 8px;
        }

        .email-header p {
            color: #6b7280;
        }

        .email-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 24px;
        }

        .email-stat-card {
            background: white;
            border-radius: 12px;
            padding: 20px 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            text-align: center;
            flex: 1;
            max-width: 200px;
        }

        .email-stat-card .stat-icon {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .email-stat-card .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #1a1a2e;
        }

        .email-stat-card .stat-label {
            color: #6b7280;
            font-size: 13px;
            margin-top: 4px;
        }

        .email-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .email-filter {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
        }

        .email-filter .search-input {
            flex: 1;
            max-width: 400px;
            padding: 10px 14px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 14px;
        }

        .email-table-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            overflow: hidden;
            margin-bottom: 20px;
        }

        .email-table {
            width: 100%;
            border-collapse: collapse;
        }

        .email-table th {
            background: #f8f9fa;
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
        }

        .email-table td {
            padding: 12px 16px;
            border-bottom: 1px solid #f3f4f6;
            font-size: 14px;
        }

        .email-table tbody tr:hover {
            background: #f9fafb;
        }

        .email-table tbody tr.selected {
            background: #eff6ff;
        }

        .email-table input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .email-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .email-status.verified {
            background: #d1fae5;
            color: #065f46;
        }

        .email-status.unverified {
            background: #fef3c7;
            color: #92400e;
        }

        .email-status.disabled {
            background: #fee2e2;
            color: #991b1b;
        }

        .empty-state {
            text-align: center;
            padding: 40px !important;
            color: #6b7280;
        }

        .mailchimp-status {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .mailchimp-status h4 {
            margin-bottom: 12px;
            color: #1a1a2e;
        }

        .mailchimp-result {
            font-size: 14px;
        }

        .mailchimp-result .success {
            color: #059669;
        }

        .mailchimp-result .error {
            color: #dc2626;
        }

        /* Additional email table styles */
        .email-table th.sortable {
            cursor: pointer;
            user-select: none;
        }

        .email-table th.sortable:hover {
            background: #eef2f7;
        }

        .email-table-footer {
            padding: 12px 16px;
            text-align: center;
            color: #6b7280;
            font-size: 13px;
            background: #f8f9fa;
            border-top: 1px solid #e5e7eb;
        }

        .email-table-wrapper {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            overflow: hidden;
        }

        .email-cell {
            font-family: 'SF Mono', monospace;
            font-size: 13px;
        }

        .spinner-small {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #ffffff;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.8s linear infinite;
            vertical-align: middle;
            margin-right: 6px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tesco Database Builder Styles */
        .tesco-builder-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .tesco-header {
            margin-bottom: 24px;
        }

        .tesco-header h2 {
            color: #1a1a2e;
            font-size: 24px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .tesco-header p {
            color: #6b7280;
        }

        /* Real-time connection indicator */
        .realtime-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            font-weight: 500;
            padding: 4px 10px;
            border-radius: 20px;
            background: #f3f4f6;
            color: #6b7280;
            transition: all 0.3s ease;
        }

        .realtime-indicator.connected {
            background: #dcfce7;
            color: #166534;
        }

        .realtime-indicator.disconnected {
            background: #fee2e2;
            color: #991b1b;
        }

        .realtime-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9ca3af;
            animation: none;
        }

        .realtime-dot.connected {
            background: #22c55e;
            animation: pulse-green 2s infinite;
        }

        .realtime-dot.disconnected {
            background: #ef4444;
        }

        @keyframes pulse-green {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.2);
            }
        }

        .tesco-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .tesco-stat-card {
            background: white;
            border-radius: 12px;
            padding: 20px 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            text-align: center;
            flex: 1;
            min-width: 150px;
            max-width: 200px;
        }

        .tesco-stat-card .stat-icon {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .tesco-stat-card .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: #1a1a2e;
        }

        .tesco-stat-card .stat-label {
            color: #6b7280;
            font-size: 13px;
            margin-top: 4px;
        }

        .tesco-progress-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .progress-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .status-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-idle { background: #e5e7eb; color: #374151; }
        .status-running { background: #dbeafe; color: #1d4ed8; }
        .status-paused { background: #fef3c7; color: #92400e; }
        .status-completed { background: #d1fae5; color: #065f46; }
        .status-error { background: #fee2e2; color: #991b1b; }

        .progress-bar-container {
            height: 12px;
            background: #e5e7eb;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            border-radius: 6px;
            transition: width 0.3s ease;
        }

        .progress-details {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            color: #6b7280;
        }

        .tesco-controls {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .btn-large {
            padding: 12px 24px;
            font-size: 15px;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        /* Auto-Restart Toggle */
        .tesco-auto-restart {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding: 12px 16px;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 26px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #cbd5e1;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #10b981;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        .toggle-label {
            font-size: 14px;
            color: #374151;
            font-weight: 500;
        }

        .auto-restart-count {
            margin-left: auto;
            font-size: 13px;
            color: #6b7280;
            background: #e5e7eb;
            padding: 4px 10px;
            border-radius: 12px;
        }

        .auto-restart-count strong {
            color: #374151;
        }

        .tesco-auto-restart.restarting {
            background: #fef3c7;
            border-color: #fbbf24;
            animation: pulse-restart 1s ease-in-out infinite;
        }

        @keyframes pulse-restart {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .tesco-info {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 24px;
        }

        .tesco-info h4 {
            color: #0369a1;
            margin-bottom: 12px;
        }

        .tesco-info ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .tesco-info li {
            padding: 6px 0;
            color: #0c4a6e;
            font-size: 14px;
        }

        .tesco-recent {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .tesco-recent h4 {
            margin-bottom: 12px;
            color: #1a1a2e;
        }

        .recent-products-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .recent-product-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: #f9fafb;
            border-radius: 8px;
        }

        .recent-product-item .product-name {
            font-weight: 500;
        }

        .recent-product-item .product-brand {
            color: #6b7280;
            font-size: 13px;
        }

        .recent-product-item .product-nutrition {
            font-size: 12px;
            color: #059669;
        }

        .tesco-errors {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 12px;
            padding: 16px 20px;
        }

        .tesco-errors h4 {
            color: #991b1b;
            margin-bottom: 12px;
        }

        .error-log {
            max-height: 200px;
            overflow-y: auto;
            font-size: 13px;
            color: #7f1d1d;
        }

        .error-log p {
            padding: 4px 0;
            border-bottom: 1px solid #fecaca;
        }

        /* Live Activity Feed */
        .tesco-live-feed {
            background: white;
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            border-left: 4px solid #3b82f6;
        }

        .tesco-live-feed.stalled {
            border-left-color: #f59e0b;
            background: #fffbeb;
        }

        .live-feed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .live-feed-header h4 {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .live-indicator {
            width: 10px;
            height: 10px;
            background: #22c55e;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        .live-indicator.stalled {
            background: #f59e0b;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }

        .stall-warning {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 12px;
            display: none;
        }

        .stall-warning.visible {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stall-warning-icon {
            font-size: 20px;
        }

        .stall-warning-text {
            flex: 1;
            font-size: 14px;
            color: #92400e;
        }

        .current-activity {
            background: #f8fafc;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 12px;
        }

        .current-activity-label {
            font-size: 11px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .current-activity-text {
            font-size: 14px;
            color: #1f2937;
            font-weight: 500;
        }

        .current-activity-detail {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }

        .activity-log {
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            background: #1e293b;
            border-radius: 8px;
            padding: 12px;
        }

        .activity-log-entry {
            padding: 4px 0;
            color: #94a3b8;
            border-bottom: 1px solid #334155;
        }

        .activity-log-entry:last-child {
            border-bottom: none;
        }

        .activity-log-entry.success {
            color: #4ade80;
        }

        .activity-log-entry.error {
            color: #f87171;
        }

        .activity-log-entry.info {
            color: #60a5fa;
        }

        .activity-log-entry .timestamp {
            color: #64748b;
            margin-right: 8px;
        }

        .time-since-update {
            font-size: 12px;
            color: #6b7280;
        }

        .time-since-update.warning {
            color: #f59e0b;
            font-weight: 600;
        }

        .time-since-update.danger {
            color: #ef4444;
            font-weight: 600;
        }

        /* Login Styles */
        .login-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1e3a5f 0%, #0f172a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .login-container.hidden {
            display: none;
        }

        .login-box {
            background: white;
            border-radius: 16px;
            padding: 48px;
            width: 100%;
            max-width: 420px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        .login-logo {
            text-align: center;
            margin-bottom: 32px;
        }

        .login-logo h1 {
            font-size: 28px;
            font-weight: 700;
            color: #111827;
        }

        .login-logo h1 span {
            color: #2563eb;
        }

        .login-logo p {
            color: #6b7280;
            margin-top: 8px;
            font-size: 14px;
        }

        .login-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .login-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .login-field label {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        .login-field input {
            padding: 12px 16px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.2s;
        }

        .login-field input:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .login-btn {
            background: #2563eb;
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
        }

        .login-btn:hover {
            background: #1d4ed8;
        }

        .login-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .login-error {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #991b1b;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .login-error.show {
            display: block;
        }

        .main-app {
            display: none;
        }

        .main-app.authenticated {
            display: block;
        }

        .logout-btn {
            background: transparent;
            border: 1px solid #e5e7eb;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: 16px;
        }

        .logout-btn:hover {
            background: #fee2e2;
            border-color: #fecaca;
            color: #991b1b;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 13px;
            color: #6b7280;
        }

        .user-email {
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* AI Categories View Styles */
        .categories-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
        }

        .categories-header {
            margin-bottom: 24px;
        }

        .categories-header h2 {
            font-size: 24px;
            font-weight: 600;
            color: #111827;
            margin-bottom: 8px;
        }

        .categories-header p {
            color: #6b7280;
            font-size: 14px;
        }

        .categories-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        @media (max-width: 768px) {
            .categories-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .cat-stat-card {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }

        .cat-stat-card.success {
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            border-color: #a7f3d0;
        }

        .cat-stat-card.warning {
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
            border-color: #fde68a;
        }

        .cat-stat-card.info {
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            border-color: #bfdbfe;
        }

        .cat-stat-card.error {
            background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);
            border-color: #fecaca;
        }

        .cat-stat-card .stat-icon {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .cat-stat-card .stat-value {
            font-size: 32px;
            font-weight: 700;
            color: #111827;
            margin-bottom: 4px;
        }

        .cat-stat-card .stat-label {
            font-size: 13px;
            color: #6b7280;
            font-weight: 500;
        }

        .categories-controls {
            display: flex;
            gap: 24px;
            align-items: center;
            flex-wrap: wrap;
            background: #f8fafc;
            padding: 16px 20px;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .categories-controls .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .categories-controls .control-group label {
            font-weight: 500;
            color: #374151;
            font-size: 14px;
        }

        .categories-controls .control-group select {
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #d1d5db;
            font-size: 14px;
            min-width: 180px;
            background: white;
        }

        .categories-controls .control-group.checkbox label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .categories-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 24px;
        }

        .categories-actions .btn-large {
            padding: 14px 28px;
            font-size: 16px;
        }

        .categories-progress {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            border-left: 4px solid #3b82f6;
        }

        .categories-progress .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        /* Preview Section Styles */
        .categories-preview {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .preview-header h3 {
            margin: 0;
            color: #111827;
        }

        .preview-count {
            background: #dbeafe;
            color: #1e40af;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
        }

        .preview-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
        }

        .preview-item {
            display: flex;
            align-items: center;
            padding: 10px 14px;
            border-bottom: 1px solid #f1f5f9;
            gap: 12px;
        }

        .preview-item:last-child {
            border-bottom: none;
        }

        .preview-item:nth-child(even) {
            background: #f9fafb;
        }

        .preview-item .food-name {
            flex: 1;
            font-weight: 500;
            color: #111827;
            font-size: 14px;
        }

        .preview-item .brand-name {
            color: #6b7280;
            font-size: 12px;
        }

        .preview-item .serving-info {
            color: #9ca3af;
            font-size: 12px;
            min-width: 80px;
            text-align: right;
        }

        .categories-results {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .categories-results h3 {
            margin-bottom: 16px;
            color: #111827;
        }

        .results-summary {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
            font-size: 14px;
            color: #166534;
        }

        .results-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .result-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border-bottom: 1px solid #f1f5f9;
            gap: 12px;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-item .food-name {
            flex: 1;
            font-weight: 500;
            color: #111827;
        }

        .result-item .category-badge {
            background: #e0e7ff;
            color: #3730a3;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .result-item .category-badge.new-category {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #10b981;
        }

        .result-item .serving-info {
            color: #6b7280;
            font-size: 13px;
            min-width: 100px;
            text-align: right;
        }

        .result-item .confidence-badge {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .result-item .confidence-badge.high {
            background: #dcfce7;
            color: #166534;
        }

        .result-item .confidence-badge.medium {
            background: #fef3c7;
            color: #92400e;
        }

        .result-item .confidence-badge.low {
            background: #fee2e2;
            color: #991b1b;
        }

        .categories-distribution {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .categories-distribution h3 {
            margin-bottom: 16px;
            color: #111827;
        }

        .distribution-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
        }

        .distribution-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: #f8fafc;
            border-radius: 8px;
            font-size: 13px;
        }

        .distribution-item .category-name {
            color: #374151;
            font-weight: 500;
        }

        .distribution-item .category-count {
            background: #3b82f6;
            color: white;
            padding: 2px 10px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 12px;
        }

        .categories-reference {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .categories-reference h3 {
            margin-bottom: 8px;
            color: #111827;
        }

        .categories-reference > p {
            color: #6b7280;
            font-size: 13px;
            margin-bottom: 16px;
        }

        .category-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .category-chip {
            background: #f1f5f9;
            color: #475569;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }

        .category-chip:hover {
            background: #e2e8f0;
            border-color: #94a3b8;
        }

        .category-chip.active {
            background: #3b82f6;
            color: white;
        }

        .empty-state {
            text-align: center;
            color: #9ca3af;
            padding: 40px 20px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- Login Container -->
    <div id="login-container" class="login-container">
        <div class="login-box">
            <div class="login-logo">
                <h1>Nutra<span>Safe</span></h1>
                <p>Admin Dashboard Login</p>
            </div>
            <form id="login-form" class="login-form" onsubmit="return app.handleLogin(event)">
                <div class="login-field">
                    <label for="login-email">Email</label>
                    <input type="email" id="login-email" placeholder="admin@nutrasafe.com" required>
                </div>
                <div class="login-field">
                    <label for="login-password">Password</label>
                    <input type="password" id="login-password" placeholder="Enter your password" required>
                </div>
                <div id="login-error" class="login-error"></div>
                <button type="submit" id="login-btn" class="login-btn">Sign In</button>
            </form>
        </div>
    </div>

    <!-- Main App (hidden until authenticated) -->
    <div id="main-app" class="main-app">
        <header class="header">
            <h1>Nutra<span>Safe</span> Admin</h1>
            <div style="display: flex; align-items: center;">
                <nav class="nav-tabs">
                    <button class="nav-tab active" data-view="foods">Foods</button>
                    <button class="nav-tab" data-view="reports">
                        Reports <span id="reports-badge" class="nav-badge">0</span>
                    </button>
                    <button class="nav-tab" data-view="database-check">Database Check</button>
                    <button class="nav-tab" data-view="email-marketing">Email Marketing</button>
                    <button class="nav-tab" data-view="tesco-builder">Database Builder</button>
                    <button class="nav-tab" data-view="ai-categories">AI Categories</button>
                    <button class="nav-tab" data-view="ai-validation">AI Validation</button>
                </nav>
                <div class="user-info">
                    <span id="user-email" class="user-email"></span>
                    <button class="logout-btn" onclick="app.handleLogout()">Sign Out</button>
                </div>
            </div>
        </header>

    <main class="main-content">
        <!-- Foods View -->
        <div id="foods-view" class="view active">
            <div class="search-section">
                <div class="search-row">
                    <input type="text" id="search-input" class="search-input" placeholder="Search foods by name, brand, or barcode...">
                    <button id="search-btn" class="search-btn">Search</button>
                </div>
                <div class="filters-row">
                    <div class="filter-group">
                        <span class="filter-label">Collection:</span>
                        <select id="collection-filter" class="filter-select">
                            <option value="uk_foods_cleaned" selected>UK Foods Cleaned (58,946)</option>
                            <option value="tesco_products">Tesco Products</option>
                            <option value="foods">All Foods (25,658)</option>
                            <option value="generic_database">Generic Database (821)</option>
                            <option value="fast_foods_database">Fast Foods (427)</option>
                            <option value="user_added">User Added (12)</option>
                            <option value="ai_manually_added">AI Manually Added (1)</option>
                            <option value="verified_foods">Verified Foods (0)</option>
                            <option value="manual_foods">Manual Foods (0)</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <span class="filter-label">Quality:</span>
                        <select id="quality-filter" class="filter-select">
                            <option value="all">All</option>
                            <option value="missing-nutrition">Missing Nutrition</option>
                            <option value="missing-ingredients">Missing Ingredients</option>
                            <option value="missing-barcode">Missing Barcode</option>
                            <option value="misspellings">Misspellings</option>
                            <option value="complete">Complete Data</option>
                        </select>
                    </div>
                    <span id="results-stats" class="results-stats"></span>
                </div>
            </div>

            <div id="food-list" class="food-list">
                <div class="loading">
                    <div class="spinner"></div>
                    <span>Loading foods...</span>
                </div>
            </div>

            <div class="pagination" id="pagination" style="display: none;">
                <button id="prev-btn" disabled>‚Üê Previous</button>
                <span id="page-info">Page 1</span>
                <button id="next-btn">Next ‚Üí</button>
            </div>
        </div>

        <!-- Reports View -->
        <div id="reports-view" class="view">
            <div class="reports-toolbar">
                <div class="reports-filters">
                    <select id="report-status-filter" class="filter-select">
                        <option value="all">All Reports</option>
                        <option value="pending">Pending</option>
                        <option value="in_progress">In Progress</option>
                        <option value="resolved">Resolved</option>
                    </select>
                </div>
                <div class="reports-bulk-actions">
                    <label class="select-all-label">
                        <input type="checkbox" id="select-all-reports" onchange="app.toggleSelectAllReports()">
                        Select All
                    </label>
                    <span id="selected-count" style="display:none; margin-left: 10px; color: #666;">0 selected</span>
                    <button class="btn btn-danger btn-sm" id="bulk-delete-btn" style="display:none; margin-left: 10px;" onclick="app.bulkDeleteReports()">
                        üóëÔ∏è Delete Selected
                    </button>
                </div>
            </div>
            <div id="reports-list">
                <div class="loading">
                    <div class="spinner"></div>
                    <span>Loading reports...</span>
                </div>
            </div>
        </div>

        <!-- Database Check View -->
        <div id="database-check-view" class="view">
            <div class="database-check-layout">
                <!-- Session Sidebar -->
                <div class="session-sidebar">
                    <h3>
                        Scan Sessions
                        <button class="btn btn-sm btn-secondary" onclick="app.clearAllSessions()" title="Clear all sessions">Clear All</button>
                    </h3>
                    <div class="session-list" id="session-list">
                        <div class="no-sessions">No saved sessions yet. Run a scan to get started.</div>
                    </div>
                </div>

                <!-- Main Content -->
                <div class="database-check-main">
                    <!-- Scan Controls -->
                    <div class="scan-controls">
                        <div class="scan-control-group">
                            <label>Select Index:</label>
                            <select id="scan-index" class="filter-select">
                                <option value="uk_foods_cleaned">UK Foods Cleaned (58,946)</option>
                                <option value="tesco_products">Tesco Products</option>
                                <option value="foods">All Foods (25,658)</option>
                                <option value="generic_database">Generic Database (821)</option>
                                <option value="fast_foods_database">Fast Foods (427)</option>
                                <option value="user_added">User Added</option>
                                <option value="ai_manually_added">AI Manually Added</option>
                            </select>
                        </div>
                        <button id="start-scan-btn" class="btn btn-primary btn-scan" onclick="app.startDatabaseScan()">
                            Start Full Scan
                        </button>
                        <button id="cancel-scan-btn" class="btn btn-secondary" style="display:none" onclick="app.cancelScan()">
                            Cancel
                        </button>
                    </div>

                    <!-- Progress Section -->
                    <div id="scan-progress" class="scan-progress" style="display:none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                        </div>
                        <div class="progress-text" id="progress-text">Preparing scan...</div>
                    </div>

                    <!-- Results Section -->
                    <div id="scan-results" class="scan-results" style="display:none;">
                        <!-- Issue Ledger Summary -->
                        <div class="ledger-summary" id="ledger-summary">
                            <div class="ledger-stat total">
                                <div class="stat-value" id="ledger-total">0</div>
                                <div class="stat-label">Total Found</div>
                            </div>
                            <div class="ledger-stat pending">
                                <div class="stat-value" id="ledger-pending">0</div>
                                <div class="stat-label">Pending</div>
                            </div>
                            <div class="ledger-stat resolved">
                                <div class="stat-value" id="ledger-resolved">0</div>
                                <div class="stat-label">Resolved</div>
                            </div>
                            <div class="ledger-stat skipped">
                                <div class="stat-value" id="ledger-skipped">0</div>
                                <div class="stat-label">Skipped</div>
                            </div>
                            <div class="ledger-stat errors">
                                <div class="stat-value" id="ledger-errors">0</div>
                                <div class="stat-label">Errors</div>
                            </div>
                        </div>

                        <!-- Issue Tabs for filtering by status -->
                        <div class="issue-tabs" id="issue-tabs">
                            <button class="issue-tab active" data-status="all" onclick="app.filterByLedgerStatus('all')">
                                All <span class="tab-count" id="tab-count-all">0</span>
                            </button>
                            <button class="issue-tab" data-status="pending" onclick="app.filterByLedgerStatus('pending')">
                                Pending <span class="tab-count" id="tab-count-pending">0</span>
                            </button>
                            <button class="issue-tab" data-status="resolved" onclick="app.filterByLedgerStatus('resolved')">
                                Resolved <span class="tab-count" id="tab-count-resolved">0</span>
                            </button>
                            <button class="issue-tab" data-status="skipped" onclick="app.filterByLedgerStatus('skipped')">
                                Skipped <span class="tab-count" id="tab-count-skipped">0</span>
                            </button>
                        </div>

                        <!-- Category Summary Dashboard -->
                        <div class="category-dashboard" id="category-dashboard">
                            <div class="category-title">Issue Categories (click to filter)</div>
                            <div class="category-cards">
                                <div class="category-card duplicates" onclick="app.filterByIssueType('duplicates')" title="View all duplicates">
                                    <div class="category-icon">üîÑ</div>
                                    <div class="category-count" id="cat-duplicates">0</div>
                                    <div class="category-label">Duplicates</div>
                                </div>
                                <div class="category-card missing" onclick="app.filterByIssueType('missing-nutrition')" title="View missing nutrition">
                                    <div class="category-icon">‚ùì</div>
                                    <div class="category-count" id="cat-missing">0</div>
                                    <div class="category-label">Missing Data</div>
                                </div>
                                <div class="category-card invalid" onclick="app.filterByIssueType('impossible-nutrition')" title="View impossible nutrition values">
                                    <div class="category-icon">‚ö†Ô∏è</div>
                                    <div class="category-count" id="cat-invalid">0</div>
                                    <div class="category-label">Invalid Values</div>
                                </div>
                                <div class="category-card calories" onclick="app.filterByIssueType('calories-mismatch')" title="View calories mismatches">
                                    <div class="category-icon">üî¢</div>
                                    <div class="category-count" id="cat-calories">0</div>
                                    <div class="category-label">Cal Mismatch</div>
                                </div>
                                <div class="category-card text" onclick="app.filterByIssueType('misspelling')" title="View text issues">
                                    <div class="category-icon">üìù</div>
                                    <div class="category-count" id="cat-text">0</div>
                                    <div class="category-label">Text Issues</div>
                                </div>
                                <div class="category-card multiple" onclick="app.filterByIssueType('multiple')" title="View items with multiple issues">
                                    <div class="category-icon">üìä</div>
                                    <div class="category-count" id="cat-multiple">0</div>
                                    <div class="category-label">Multiple</div>
                                </div>
                            </div>
                        </div>

                        <!-- Activity Log Panel -->
                        <div class="activity-log-panel" id="activity-log-panel">
                            <div class="activity-log-header">
                                <span>üìã Activity Log</span>
                                <button onclick="app.clearActivityLog()" title="Clear log" style="background: none; border: none; color: #94a3b8; cursor: pointer; font-size: 12px;">Clear</button>
                            </div>
                            <div class="activity-log-content" id="activity-log-content">
                                <div class="activity-log-empty">No activity yet. Start a scan or perform actions to see logs here.</div>
                            </div>
                        </div>

                        <!-- UK VERIFICATION ACTIONS PANEL -->
                        <div class="verification-actions-panel">
                            <h3>
                                <span>üá¨üáß</span> UK Data Verification
                                <span style="margin-left: auto; font-size: 12px; font-weight: 400; color: #64748b;">
                                    <span id="verified-count">0</span> UK verified |
                                    <span id="unverified-count">0</span> unverified
                                </span>
                            </h3>

                            <!-- UK Sources Info -->
                            <div style="background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 6px; padding: 10px 14px; margin-bottom: 16px; font-size: 12px; color: #0369a1;">
                                <strong>üá¨üáß UK Official Sources Only:</strong> Tesco, Sainsbury's, Asda, Morrisons, Waitrose, Co-op, Aldi UK, Lidl UK, Ocado + Manufacturer websites.
                                <br><span style="color: #059669;">Uses Google to discover product pages, then extracts from official sources.</span>
                            </div>

                            <div class="verification-actions-grid">
                                <button class="verify-action-btn verify-sources" id="btn-verify-sources" onclick="app.verifyAgainstSources()">
                                    <span class="btn-title">üá¨üáß Generate Search Links</span>
                                    <span class="btn-desc">Get UK supermarket search links for manual verification</span>
                                </button>
                                <button class="verify-action-btn fix-nutrition" id="btn-fix-nutrition" onclick="app.fixNutritionOnly()">
                                    <span class="btn-title">Fix UK Nutrition</span>
                                    <span class="btn-desc">Update per 100g: kcal, kJ, salt, fibre (UK format)</span>
                                </button>
                                <button class="verify-action-btn fix-ingredients" id="btn-fix-ingredients" onclick="app.fixIngredientsOnly()">
                                    <span class="btn-title">Fix UK Ingredients</span>
                                    <span class="btn-desc">Update UK 14 allergens + ingredient list</span>
                                </button>
                                <button class="verify-action-btn flag-review" id="btn-flag-review" onclick="app.flagForHumanReview()">
                                    <span class="btn-title">Skip Selected</span>
                                    <span class="btn-desc">Mark selected items as skipped in ledger</span>
                                </button>
                                <button class="verify-action-btn force-rerun" id="btn-force-rerun" onclick="app.forceRerunVerification()">
                                    <span class="btn-title">Force Re-verify</span>
                                    <span class="btn-desc">Re-check even if already verified</span>
                                </button>
                                <button class="verify-action-btn fix-calories" id="btn-fix-kj-kcal" onclick="app.fixKjKcalCalories()">
                                    <span class="btn-title">üîß Fix kJ+kcal Calories</span>
                                    <span class="btn-desc">Detect & fix concatenated kJ|kcal values (e.g., 2431583 ‚Üí 583)</span>
                                </button>
                                <button class="verify-action-btn fix-calories" id="btn-fix-simple-ingredients" onclick="app.fixSimpleIngredients()" style="background: linear-gradient(135deg, #059669 0%, #10b981 100%);">
                                    <span class="btn-title">ü•ú Fix Simple Ingredients</span>
                                    <span class="btn-desc">Auto-add ingredients for single-ingredient foods (oils, nuts, etc.)</span>
                                </button>
                                <button class="verify-action-btn fix-calories" id="btn-fix-html-code" onclick="app.fixHtmlCode()" style="background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%);">
                                    <span class="btn-title">üßπ Fix HTML Code</span>
                                    <span class="btn-desc">Remove HTML tags & entities from names, brands, ingredients</span>
                                </button>
                                <button class="verify-action-btn fix-calories" id="btn-rescan-products" onclick="app.rescanProducts()" style="background: linear-gradient(135deg, #7c3aed 0%, #8b5cf6 100%);">
                                    <span class="btn-title">üîÑ Rescan Products</span>
                                    <span class="btn-desc">Re-fetch nutrition data from Tesco API for items with issues</span>
                                </button>
                            </div>

                            <!-- UK Verification Status Legend -->
                            <div style="display: flex; gap: 16px; margin-top: 16px; padding-top: 12px; border-top: 1px solid #e2e8f0; flex-wrap: wrap;">
                                <div style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
                                    <span class="verification-badge status-uk-verified">UK VERIFIED</span>
                                    <span style="color: #64748b;">Confirmed by UK Tier 1/2 sources</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
                                    <span class="verification-badge status-updated">UPDATED</span>
                                    <span style="color: #64748b;">Data corrected from UK sources</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
                                    <span class="verification-badge status-non-uk-data">NON-UK DATA</span>
                                    <span style="color: #64748b;">Only non-UK sources found (rejected)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px; font-size: 11px;">
                                    <span class="verification-badge status-insufficient-uk-data">INSUFFICIENT UK DATA</span>
                                    <span style="color: #64748b;">Needs manual UK source lookup</span>
                                </div>
                            </div>
                        </div>

                        <!-- Filters and Selection Row -->
                        <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 8px; padding: 10px 14px; background: var(--bg-secondary); border-radius: 8px;">
                            <!-- Filter Dropdown -->
                            <select id="issue-filter-select" onchange="app.filterByIssueType(this.value)" style="padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px; font-size: 13px;">
                                <option value="all">All Issues</option>
                                <optgroup label="üîç Duplicates">
                                    <option value="duplicates">All Duplicates</option>
                                    <option value="dup-barcode">‚îî Barcode Match (100%)</option>
                                    <option value="dup-name">‚îî Exact Name (95%)</option>
                                    <option value="dup-brand">‚îî Brand+Name (90%)</option>
                                    <option value="dup-tokens">‚îî Same Words (85%)</option>
                                    <option value="dup-size">‚îî Size Variant (80%)</option>
                                    <option value="dup-fuzzy">‚îî Fuzzy Match (75%)</option>
                                </optgroup>
                                <optgroup label="‚ö†Ô∏è Data Issues">
                                    <option value="calories-mismatch">Calories Mismatch</option>
                                    <option value="missing-nutrition">Missing Nutrition</option>
                                    <option value="impossible-nutrition">Impossible Nutrition</option>
                                    <option value="missing-barcode">Missing Barcode</option>
                                    <option value="missing-ingredients">Missing Ingredients</option>
                                </optgroup>
                                <optgroup label="üìù Text Issues">
                                    <option value="misspelling">Misspellings</option>
                                    <option value="weird-spacing">Weird Spacing</option>
                                    <option value="non-word">Non-Words</option>
                                    <option value="html-code">HTML Code</option>
                                </optgroup>
                                <option value="multiple">Multiple Issues</option>
                            </select>

                            <!-- Duplicate Groups Button -->
                            <button id="open-duplicates-btn" onclick="app.toggleDuplicateGroupsPanel()"
                                style="padding: 6px 12px; font-size: 12px; border: 2px solid #f59e0b; border-radius: 6px; background: #fffbeb; color: #92400e; cursor: pointer; display: flex; align-items: center; gap: 6px; font-weight: 500; transition: all 0.15s;"
                                onmouseover="this.style.background='#fef3c7'" onmouseout="this.style.background='#fffbeb'">
                                üîÑ Duplicates <span id="dup-btn-count" style="background: #f59e0b; color: white; padding: 1px 6px; border-radius: 10px; font-size: 11px;">0</span>
                            </button>

                            <div style="height: 20px; width: 1px; background: var(--border);"></div>

                            <!-- Selection Controls -->
                            <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; cursor: pointer;">
                                <input type="checkbox" id="select-all-checkbox" onchange="app.toggleSelectAll(this.checked)" style="width: 16px; height: 16px;">
                                Page
                            </label>
                            <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; cursor: pointer;">
                                <input type="checkbox" id="select-all-filtered-checkbox" onchange="app.toggleSelectAllFiltered(this.checked)" style="width: 16px; height: 16px;">
                                All <span id="filtered-total">0</span>
                            </label>
                            <span id="selection-info" style="font-size: 13px; color: var(--accent); font-weight: 500;">0 selected</span>

                            <div style="margin-left: auto; display: flex; gap: 6px;">
                                <button class="btn btn-secondary btn-sm" onclick="app.clearSelection()" id="clear-selection-btn" disabled>Clear</button>
                                <button class="btn btn-danger btn-sm" onclick="app.deleteSelected()" id="delete-selected-btn" disabled>Delete</button>
                            </div>
                        </div>

                        <!-- Filtered Count & Pagination Info -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 0 4px;">
                            <div class="filtered-count" id="filtered-count" style="font-size: 13px;"></div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <button onclick="app.issuesPrevPage()" id="issues-prev-btn" disabled style="padding: 4px 10px; font-size: 12px; border: 1px solid var(--border); background: white; border-radius: 4px; cursor: pointer;">‚Äπ Prev</button>
                                <span id="issues-page-info" style="font-size: 12px; color: var(--text-secondary);">Page 1 of 1</span>
                                <button onclick="app.issuesNextPage()" id="issues-next-btn" disabled style="padding: 4px 10px; font-size: 12px; border: 1px solid var(--border); background: white; border-radius: 4px; cursor: pointer;">Next ‚Ä∫</button>
                                <input type="number" id="issues-page-jump" min="1" onchange="app.issuesJumpToPage(this.value)" style="width: 50px; padding: 4px; font-size: 12px; border: 1px solid var(--border); border-radius: 4px; text-align: center;">
                            </div>
                        </div>

                        <!-- Batch Discovery Results Panel - Inline -->
                        <div id="batch-results-panel" class="batch-results-panel" style="display: none;">
                            <div class="batch-results-header">
                                <h3>üîç Batch Discovery Progress</h3>
                                <div class="batch-results-stats">
                                    <span class="batch-stat success" onclick="app.filterBatchResults('success')" style="cursor:pointer;" title="Click to filter">‚úì <span id="batch-success-count">0</span></span>
                                    <span class="batch-stat failed" onclick="app.filterBatchResults('failed')" style="cursor:pointer;" title="Click to filter">‚úó <span id="batch-failed-count">0</span></span>
                                    <span class="batch-stat skipped" onclick="app.filterBatchResults('skipped')" style="cursor:pointer; color: #64748b;" title="Click to filter">‚óã <span id="batch-skipped-count">0</span></span>
                                </div>
                                <button class="batch-results-close" onclick="app.closeBatchResultsPanel()">√ó</button>
                            </div>
                            <!-- Filter tabs and bulk actions -->
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: var(--bg-secondary); border-bottom: 1px solid var(--border);">
                                <div style="display: flex; gap: 8px;">
                                    <button class="batch-filter-btn active" data-filter="all" onclick="app.filterBatchResults('all')">All</button>
                                    <button class="batch-filter-btn" data-filter="success" onclick="app.filterBatchResults('success')">‚úì Success</button>
                                    <button class="batch-filter-btn" data-filter="failed" onclick="app.filterBatchResults('failed')">‚úó Failed</button>
                                    <button class="batch-filter-btn" data-filter="skipped" onclick="app.filterBatchResults('skipped')">‚óã Skipped</button>
                                </div>
                                <div style="display: flex; gap: 6px;">
                                    <button class="btn btn-sm" onclick="app.skipAllBatchErrors()" title="Mark all failed items as skipped" style="font-size: 11px; padding: 4px 8px;">Skip All Errors</button>
                                    <button class="btn btn-sm btn-danger" onclick="app.deleteAllBatchErrors()" title="Delete all failed items" style="font-size: 11px; padding: 4px 8px;">Delete Errors</button>
                                </div>
                            </div>
                            <div class="batch-results-list" id="batch-results-list">
                                <!-- Results populated dynamically -->
                            </div>
                            <div class="batch-results-footer">
                                <div class="batch-progress-bar">
                                    <div class="batch-progress-fill" id="batch-progress-fill" style="width: 0%"></div>
                                </div>
                                <span id="batch-progress-text" style="font-size: 12px; color: var(--text-secondary);">0/0</span>
                            </div>
                        </div>

                        <!-- Duplicate Groups Panel -->
                        <div id="duplicate-groups-panel" class="duplicate-groups-panel" style="display: none;">
                            <div class="dup-panel-header">
                                <h3>üîÑ Duplicate Groups <span id="dup-groups-count">(0 groups, 0 items)</span></h3>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <select id="dup-type-filter" onchange="app.filterDuplicateGroups(this.value)" style="padding: 4px 8px; font-size: 12px; border: 1px solid var(--border); border-radius: 4px;">
                                        <option value="all">All Types</option>
                                        <option value="barcode">üè∑Ô∏è Barcode (100%)</option>
                                        <option value="name">üìù Exact Name (95%)</option>
                                        <option value="brand_name">üè™ Brand+Name (90%)</option>
                                        <option value="tokens">üî§ Same Words (85%)</option>
                                        <option value="size_variant">üìè Size Variant (80%)</option>
                                        <option value="fuzzy">üîç Fuzzy (75%)</option>
                                    </select>
                                    <button class="btn btn-sm" onclick="app.toggleDuplicateGroupsPanel()" title="Close panel">√ó</button>
                                </div>
                            </div>
                            <div class="dup-panel-actions">
                                <button class="btn btn-sm btn-secondary" onclick="app.keepAllFirstDuplicates()" title="Keep first item in each group, delete others">
                                    ‚úì Keep All First
                                </button>
                                <button class="btn btn-sm btn-danger" onclick="app.deleteAllDuplicates()" title="Delete all duplicate items (keep original)">
                                    üóëÔ∏è Delete All Duplicates
                                </button>
                                <button class="btn btn-sm" onclick="app.skipAllDuplicateGroups()" title="Skip all duplicate groups">
                                    ‚óã Skip All
                                </button>
                            </div>
                            <div class="dup-groups-list" id="dup-groups-list">
                                <!-- Duplicate groups rendered here -->
                            </div>
                        </div>

                        <!-- Issues List Container with Scroll -->
                        <div class="issues-list-container">
                            <div id="issues-list" class="food-list"></div>
                        </div>

                        <!-- Bottom Pagination -->
                        <div class="issues-pagination" id="issues-pagination">
                            <button onclick="app.issuesFirstPage()" id="issues-first-btn" disabled>¬´ First</button>
                            <button onclick="app.issuesPrevPage()" id="issues-prev-btn-bottom" disabled>‚Äπ Prev</button>
                            <span class="page-info" id="issues-page-info-bottom">Page 1 of 1</span>
                            <button onclick="app.issuesNextPage()" id="issues-next-btn-bottom" disabled>Next ‚Ä∫</button>
                            <button onclick="app.issuesLastPage()" id="issues-last-btn" disabled>Last ¬ª</button>
                        </div>

                        <!-- Batch Actions (Sticky Footer) -->
                        <div class="batch-actions" id="batch-actions">
                            <div class="pending-summary">
                                <span id="pending-edits">0 edits</span>
                                <span class="separator">|</span>
                                <span id="pending-deletes">0 deletions</span>
                                <span class="separator">|</span>
                                <span id="batch-discovery-status" style="color: var(--accent);"></span>
                            </div>
                            <div class="batch-buttons">
                                <button class="discovery-btn" onclick="app.startBatchDiscovery()" id="batch-discovery-btn" style="margin-right: 8px;">
                                    üîç Batch Discovery
                                </button>
                                <button class="btn btn-secondary" onclick="app.pauseBatchDiscovery()" id="pause-discovery-btn" style="display: none;">
                                    ‚è∏Ô∏è Pause
                                </button>
                                <button class="btn btn-secondary" onclick="app.clearQueue()" id="clear-queue-btn" disabled>
                                    Clear Queue
                                </button>
                                <button class="btn btn-primary" onclick="app.applyAllChanges()" id="apply-changes-btn" disabled>
                                    Apply All Changes
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Empty State -->
                    <div id="scan-empty" class="empty-state">
                        <div class="empty-icon">üîç</div>
                        <h3>Database Quality Check</h3>
                        <p>Select an index and click "Start Full Scan" to scan for issues like missing nutrition data, misspellings, and invalid entries.</p>
                    </div>
                </div> <!-- end database-check-main -->
            </div> <!-- end database-check-layout -->
        </div>

        <!-- Email Marketing View -->
        <div id="email-marketing-view" class="view">
            <div class="email-marketing-container">
                <div class="email-header">
                    <h2>üìß Email Marketing</h2>
                    <p>Manage user emails from Firebase Authentication and sync with Mailchimp</p>
                </div>

                <!-- Stats Cards -->
                <div class="email-stats">
                    <div class="email-stat-card">
                        <div class="stat-icon">üë•</div>
                        <div class="stat-value" id="email-stat-total">-</div>
                        <div class="stat-label">Total Users</div>
                    </div>
                    <div class="email-stat-card">
                        <div class="stat-icon">‚úÖ</div>
                        <div class="stat-value" id="email-stat-verified">-</div>
                        <div class="stat-label">Verified Emails</div>
                    </div>
                    <div class="email-stat-card">
                        <div class="stat-icon">üìÖ</div>
                        <div class="stat-value" id="email-stat-recent">-</div>
                        <div class="stat-label">Active (7 days)</div>
                    </div>
                    <div class="email-stat-card">
                        <div class="stat-icon">‚òëÔ∏è</div>
                        <div class="stat-value" id="email-stat-selected">0</div>
                        <div class="stat-label">Selected</div>
                    </div>
                </div>

                <!-- Controls -->
                <div class="email-controls">
                    <button class="btn btn-primary" id="refresh-emails-btn" onclick="app.loadAuthEmails()">
                        üîÑ Refresh
                    </button>
                    <button class="btn btn-secondary" onclick="app.exportEmailsCSV()">
                        üì• Export CSV
                    </button>
                    <button class="btn btn-secondary" onclick="app.copyEmailsToClipboard()">
                        üìã Copy Emails
                    </button>
                    <button class="btn btn-ai" id="sync-mailchimp-btn" onclick="app.syncSelectedToMailchimp()">
                        üìß Sync to Mailchimp
                    </button>
                </div>

                <!-- Filter -->
                <div class="email-filter">
                    <input type="text" id="email-search-input" class="search-input" placeholder="Search by email or name..." oninput="app.filterEmails()">
                </div>

                <!-- Email Table Container - dynamically rendered -->
                <div id="email-table-container" class="email-table-wrapper">
                    <div class="empty-state">
                        <p>Loading authenticated users...</p>
                    </div>
                </div>

                <!-- Mailchimp Status -->
                <div class="mailchimp-status" id="mailchimp-status" style="display: none;">
                    <h4>Mailchimp Sync Result</h4>
                    <div class="mailchimp-result" id="mailchimp-result"></div>
                </div>
            </div>
        </div>

        <!-- Tesco Database Builder View -->
        <div id="tesco-builder-view" class="view">
            <div class="tesco-builder-container">
                <div class="tesco-header">
                    <h2>üóÑÔ∏è Database Builder <span id="realtime-indicator" class="realtime-indicator" title="Connection status"><span class="realtime-dot"></span> Connecting...</span></h2>
                    <p>Build a comprehensive UK food database from multiple API sources including Tesco, UK Groceries, and recipe databases</p>
                </div>

                <!-- Stats Cards -->
                <div class="tesco-stats">
                    <div class="tesco-stat-card">
                        <div class="stat-icon">üìä</div>
                        <div class="stat-value" id="tesco-stat-total">-</div>
                        <div class="stat-label">Products Saved</div>
                    </div>
                    <div class="tesco-stat-card">
                        <div class="stat-icon">ü•ó</div>
                        <div class="stat-value" id="tesco-stat-nutrition">-</div>
                        <div class="stat-label">With Nutrition</div>
                    </div>
                    <div class="tesco-stat-card">
                        <div class="stat-icon">üîç</div>
                        <div class="stat-value" id="tesco-stat-found">-</div>
                        <div class="stat-label">Products Found</div>
                    </div>
                    <div class="tesco-stat-card">
                        <div class="stat-icon">‚è≠Ô∏è</div>
                        <div class="stat-value" id="tesco-stat-skipped">-</div>
                        <div class="stat-label">Duplicates Skipped</div>
                    </div>
                    <div class="tesco-stat-card" style="background: linear-gradient(135deg, #fef2f2 0%, #fee2e2 100%);">
                        <div class="stat-icon">‚ö†Ô∏è</div>
                        <div class="stat-value" id="tesco-stat-errors" style="color: #991b1b;">0</div>
                        <div class="stat-label">Errors</div>
                    </div>
                </div>

                <!-- Progress Section -->
                <div class="tesco-progress-section">
                    <div class="progress-header">
                        <span id="tesco-status-badge" class="status-badge status-idle">Idle</span>
                        <span id="tesco-current-term">Not started</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="tesco-progress-bar" style="width: 0%"></div>
                    </div>
                    <div class="progress-details">
                        <span id="tesco-progress-text">0 / 0 search terms processed</span>
                        <span id="tesco-last-updated">-</span>
                    </div>
                </div>

                <!-- Live Activity Feed (shown during active build) -->
                <div class="tesco-live-feed" id="tesco-live-feed" style="display: none;">
                    <div class="live-feed-header">
                        <h4>
                            <span class="live-indicator" id="live-indicator"></span>
                            Live Activity
                        </h4>
                        <span class="time-since-update" id="time-since-update">Updated just now</span>
                    </div>

                    <!-- Stall Warning -->
                    <div class="stall-warning" id="stall-warning">
                        <span class="stall-warning-icon">‚ö†Ô∏è</span>
                        <span class="stall-warning-text" id="stall-warning-text">
                            No updates for 60 seconds. The build may be stalled or processing a large request.
                        </span>
                        <button class="btn btn-sm btn-secondary" onclick="app.refreshTescoProgress()">Check Status</button>
                    </div>

                    <!-- Current Activity -->
                    <div class="current-activity">
                        <div class="current-activity-label">Currently Processing</div>
                        <div class="current-activity-text" id="current-activity-text">Waiting for activity...</div>
                        <div class="current-activity-detail" id="current-activity-detail"></div>
                    </div>

                    <!-- Activity Log -->
                    <div class="activity-log" id="activity-log">
                        <div class="activity-log-entry info">
                            <span class="timestamp">[--:--:--]</span>
                            Waiting for build to start...
                        </div>
                    </div>
                </div>

                <!-- API Source Selector -->
                <div class="tesco-api-selector" style="margin-bottom: 16px; display: flex; align-items: center; gap: 12px;">
                    <label style="font-weight: 500; color: #374151;">API Source:</label>
                    <select id="tesco-api-source" style="padding: 8px 12px; border-radius: 6px; border: 1px solid #d1d5db; font-size: 14px; min-width: 200px;">
                        <option value="tesco8">üõí Tesco (Tesco8 API)</option>
                        <option value="uk_groceries">üá¨üáß General UK Groceries</option>
                        <option value="spoonacular">üçΩÔ∏è Spoonacular Recipes</option>
                    </select>
                    <span id="tesco-api-status" style="font-size: 13px; color: #6b7280;"></span>
                </div>

                <!-- Controls -->
                <div class="tesco-controls">
                    <button class="btn btn-primary btn-large" id="tesco-start-btn" onclick="app.startTescoBuild()">
                        ‚ñ∂Ô∏è Start Build
                    </button>
                    <button class="btn btn-warning btn-large" id="tesco-pause-btn" onclick="app.pauseTescoBuild()" style="display: none;">
                        ‚è∏Ô∏è Pause
                    </button>
                    <button class="btn btn-danger btn-large" id="tesco-stop-btn" onclick="app.stopTescoBuild()" style="display: none;">
                        ‚èπÔ∏è Stop
                    </button>
                    <button class="btn btn-success btn-large" id="tesco-resume-btn" onclick="app.resumeTescoBuild()" style="display: none;">
                        ‚ñ∂Ô∏è Resume
                    </button>
                    <button class="btn btn-secondary" id="tesco-refresh-btn" onclick="app.refreshTescoProgress()">
                        üîÑ Refresh Status
                    </button>
                    <button class="btn btn-warning" id="tesco-restart-btn" onclick="app.startTescoBuild(true)">
                        üîÑ Restart Build
                    </button>
                    <button class="btn btn-info" id="tesco-sync-btn" onclick="app.syncTescoToAlgolia()">
                        üîÑ Sync to Algolia
                    </button>
                    <span id="tesco-sync-status" style="margin-left: 10px; font-size: 12px; color: var(--text-secondary);"></span>
                    <button class="btn btn-danger" id="tesco-reset-btn" onclick="app.resetTescoDatabase()">
                        üóëÔ∏è Reset Database
                    </button>
                </div>

                <!-- Auto-Restart Toggle -->
                <div class="tesco-auto-restart">
                    <label class="toggle-switch">
                        <input type="checkbox" id="tesco-auto-restart-toggle" checked onchange="app.toggleAutoRestart(this.checked)">
                        <span class="toggle-slider"></span>
                    </label>
                    <span class="toggle-label">Auto-restart on stall (90s)</span>
                    <span class="auto-restart-count" id="auto-restart-count" style="display: none;">
                        Restarts: <strong id="restart-count-value">0</strong>
                    </span>
                </div>

                <!-- Info Section -->
                <div class="tesco-info">
                    <h4>‚ÑπÔ∏è How it works</h4>
                    <ul>
                        <li><strong>Systematic Scan:</strong> Searches 147 official Tesco food categories (Fresh Food, Bakery, Frozen, etc.)</li>
                        <li><strong>Full Details:</strong> Fetches complete nutrition, ingredients, allergens, and serving sizes</li>
                        <li><strong>Resume Capability:</strong> Progress is saved - you can stop and resume anytime</li>
                        <li><strong>Dual Storage:</strong> Saves to both Firestore (tescoProducts) and Algolia (tesco_products)</li>
                        <li><strong>Rate Limited:</strong> Respects API limits to prevent blocks</li>
                    </ul>
                </div>

                <!-- Products Found -->
                <div class="tesco-recent">
                    <h4>üì¶ Products</h4>
                    <div id="tesco-recent-products" class="recent-products-list">
                        <p class="empty-state">No products yet. Start the build to begin.</p>
                    </div>
                </div>

                <!-- Error Log -->
                <div class="tesco-errors" id="tesco-errors-section" style="display: none;">
                    <h4>‚ö†Ô∏è Errors</h4>
                    <div id="tesco-error-log" class="error-log"></div>
                </div>
            </div>
        </div>

        <!-- AI Categories View -->
        <div id="ai-categories-view" class="view">
            <div class="categories-container">
                <div class="categories-header">
                    <h2>ü§ñ AI Food Categorization</h2>
                    <p>Use AI to automatically categorize foods for intelligent serving size suggestions</p>
                </div>

                <!-- Stats Cards -->
                <div class="categories-stats">
                    <div class="cat-stat-card">
                        <div class="stat-icon">üìä</div>
                        <div class="stat-value" id="cat-stat-total">-</div>
                        <div class="stat-label">Total Foods</div>
                    </div>
                    <div class="cat-stat-card success">
                        <div class="stat-icon">‚úÖ</div>
                        <div class="stat-value" id="cat-stat-categorized">-</div>
                        <div class="stat-label">Categorized</div>
                    </div>
                    <div class="cat-stat-card warning">
                        <div class="stat-icon">‚ùì</div>
                        <div class="stat-value" id="cat-stat-uncategorized">-</div>
                        <div class="stat-label">Uncategorized</div>
                    </div>
                    <div class="cat-stat-card info">
                        <div class="stat-icon">üìà</div>
                        <div class="stat-value" id="cat-stat-percent">-</div>
                        <div class="stat-label">% Complete</div>
                    </div>
                </div>

                <!-- Collection Selector -->
                <div class="categories-controls">
                    <div class="control-group">
                        <label>Collection:</label>
                        <select id="cat-collection-select" onchange="app.onCollectionChange()">
                            <option value="uk_foods_cleaned" selected>UK Foods Cleaned (55k)</option>
                            <option value="foods">All Foods (26k)</option>
                            <option value="tescoProducts">Tesco Products (9k)</option>
                            <option value="verifiedFoods">Verified Foods</option>
                            <option value="generic_database">Generic Database</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Batch Size:</label>
                        <select id="cat-batch-size">
                            <option value="all" selected>All (Full Scan)</option>
                            <option value="10">10 foods</option>
                            <option value="25">25 foods</option>
                            <option value="50">50 foods</option>
                            <option value="100">100 foods</option>
                            <option value="500">500 foods</option>
                        </select>
                    </div>
                </div>
                <p style="font-size: 12px; color: #6b7280; margin-top: 8px;">
                    ‚ö†Ô∏è Categorization will <strong>overwrite</strong> any existing categories
                </p>

                <!-- Action Buttons -->
                <div class="categories-actions">
                    <button class="btn btn-secondary" id="cat-pull-btn" onclick="app.pullUncategorizedFoods()">
                        üì• Pull Data
                    </button>
                    <button class="btn btn-primary btn-large" id="cat-start-btn" onclick="app.startCategorization()" disabled>
                        ü§ñ Start AI Categorization
                    </button>
                    <button class="btn btn-danger" id="cat-stop-btn" onclick="app.stopCategorization()" style="display: none;">
                        ‚èπÔ∏è Stop
                    </button>
                    <button class="btn btn-secondary" id="cat-reset-btn" onclick="app.resetCategorization()" style="display: none;">
                        üîÑ Start Fresh
                    </button>
                    <button class="btn btn-secondary" onclick="app.refreshCategoryStats()">
                        üîÑ Refresh Stats
                    </button>
                </div>

                <!-- Data Preview Section -->
                <div class="categories-preview" id="cat-preview-section" style="display: none;">
                    <div class="preview-header">
                        <h3>üìã Foods to Categorize</h3>
                        <span id="cat-preview-count" class="preview-count">0 foods loaded</span>
                    </div>
                    <div class="preview-list" id="cat-preview-list">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Progress Section -->
                <div class="categories-progress" id="cat-progress-section" style="display: none;">
                    <div class="progress-header">
                        <span id="cat-status-badge" class="status-badge status-idle">Processing</span>
                        <span id="cat-progress-text">Processing 0 / 0 foods...</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="cat-progress-bar" style="width: 0%"></div>
                    </div>
                </div>

                <!-- Results Section -->
                <div class="categories-results" id="cat-results-section" style="display: none;">
                    <h3>Categorization Results</h3>
                    <div class="results-summary" id="cat-results-summary"></div>
                    <div class="results-list" id="cat-results-list"></div>
                </div>

                <!-- Category Distribution -->
                <div class="categories-distribution">
                    <h3>Category Distribution (Sample)</h3>
                    <div class="distribution-grid" id="cat-distribution-grid">
                        <p class="empty-state">No categorization data yet. Run a categorization batch to see distribution.</p>
                    </div>
                </div>

                <!-- Available Categories Reference -->
                <div class="categories-reference">
                    <h3>üìã Available Categories</h3>
                    <p>Click to filter results by category</p>
                    <div class="category-chips" id="category-chips-container">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
        </div>

        <!-- AI Validation View -->
        <div id="ai-validation-view" class="view">
            <div class="categories-container">
                <div class="categories-header">
                    <h2>üîç AI Data Validation</h2>
                    <p>Use AI to validate and clean food data - fix spelling, formatting, identify discontinued products</p>
                </div>

                <!-- Validation Stats Cards -->
                <div class="categories-stats">
                    <div class="cat-stat-card">
                        <div class="stat-icon">üìä</div>
                        <div class="stat-value" id="val-stat-total">-</div>
                        <div class="stat-label">Total Foods</div>
                    </div>
                    <div class="cat-stat-card success">
                        <div class="stat-icon">‚úÖ</div>
                        <div class="stat-value" id="val-stat-validated">-</div>
                        <div class="stat-label">Validated</div>
                    </div>
                    <div class="cat-stat-card warning">
                        <div class="stat-icon">‚ùì</div>
                        <div class="stat-value" id="val-stat-unvalidated">-</div>
                        <div class="stat-label">Unvalidated</div>
                    </div>
                    <div class="cat-stat-card error">
                        <div class="stat-icon">üóëÔ∏è</div>
                        <div class="stat-value" id="val-stat-deletion">-</div>
                        <div class="stat-label">Marked Delete</div>
                    </div>
                </div>

                <!-- Collection Selector -->
                <div class="categories-controls">
                    <div class="control-group">
                        <label>Collection:</label>
                        <select id="val-collection-select" onchange="app.onValidationCollectionChange()">
                            <option value="uk_foods_cleaned" selected>UK Foods Cleaned (55k)</option>
                            <option value="foods">All Foods (26k)</option>
                            <option value="tescoProducts">Tesco Products (9k)</option>
                            <option value="verifiedFoods">Verified Foods</option>
                            <option value="generic_database">Generic Database</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Batch Size:</label>
                        <select id="val-batch-size">
                            <option value="all" selected>All (Full Scan)</option>
                            <option value="10">10 foods</option>
                            <option value="25">25 foods</option>
                            <option value="50">50 foods</option>
                            <option value="100">100 foods</option>
                            <option value="500">500 foods</option>
                        </select>
                    </div>
                </div>
                <div style="font-size: 12px; color: #6b7280; margin-top: 8px;">
                    <strong>AI Validation will:</strong>
                    <ul style="margin: 8px 0 0 16px; padding: 0;">
                        <li>Fix product name spelling and formatting</li>
                        <li>Fix brand name capitalisation</li>
                        <li>Clean ingredients (UK spelling, remove dirty data)</li>
                        <li>Identify non-UK/discontinued products (e.g., Coke Light)</li>
                        <li>Flag wildly incorrect calories for deletion</li>
                        <li>Fix serving sizes where known</li>
                    </ul>
                </div>

                <!-- Action Buttons -->
                <div class="categories-actions">
                    <button class="btn btn-secondary" id="val-pull-btn" onclick="app.pullFoodsForValidation()">
                        üì• Pull Data
                    </button>
                    <button class="btn btn-primary btn-large" id="val-start-btn" onclick="app.startValidation()" disabled>
                        üîç Start AI Validation
                    </button>
                    <button class="btn btn-danger" id="val-stop-btn" onclick="app.stopValidation()" style="display: none;">
                        ‚èπÔ∏è Stop
                    </button>
                    <button class="btn btn-secondary" id="val-reset-btn" onclick="app.resetValidation()" style="display: none;">
                        üîÑ Start Fresh
                    </button>
                    <button class="btn btn-secondary" onclick="app.refreshValidationStats()">
                        üîÑ Refresh Stats
                    </button>
                </div>

                <!-- Data Preview Section -->
                <div class="categories-preview" id="val-preview-section" style="display: none;">
                    <div class="preview-header">
                        <h3>üìã Foods to Validate</h3>
                        <span id="val-preview-count" class="preview-count">0 foods loaded</span>
                    </div>
                    <div class="preview-list" id="val-preview-list">
                        <!-- Populated by JS -->
                    </div>
                </div>

                <!-- Progress Section -->
                <div class="categories-progress" id="val-progress-section" style="display: none;">
                    <div class="progress-header">
                        <span id="val-status-badge" class="status-badge status-idle">Processing</span>
                        <span id="val-progress-text">Processing 0 / 0 foods...</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="val-progress-bar" style="width: 0%"></div>
                    </div>
                    <div style="margin-top: 8px; font-size: 13px; color: #6b7280;">
                        <span id="val-updates-count">0 updated</span> |
                        <span id="val-deletions-count">0 marked for deletion</span>
                    </div>
                </div>

                <!-- Results Section -->
                <div class="categories-results" id="val-results-section" style="display: none;">
                    <h3>Validation Results</h3>
                    <div class="results-summary" id="val-results-summary"></div>
                    <div class="results-list" id="val-results-list"></div>
                </div>

                <!-- Marked for Deletion Section -->
                <div class="categories-distribution" id="val-deletion-section">
                    <div class="preview-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <h3>üóëÔ∏è Marked for Deletion</h3>
                        <div>
                            <button class="btn btn-secondary btn-sm" onclick="app.refreshMarkedForDeletion()">üîÑ Refresh</button>
                            <button class="btn btn-danger btn-sm" id="val-delete-all-btn" onclick="app.deleteAllMarked()" style="display: none;">
                                üóëÔ∏è Delete All
                            </button>
                            <button class="btn btn-secondary btn-sm" id="val-clear-list-btn" onclick="app.clearDeletionList()" style="display: none;">
                                ‚ùå Clear List
                            </button>
                        </div>
                    </div>
                    <div id="val-deletion-list" class="preview-list" style="max-height: 400px; overflow-y: auto;">
                        <p class="empty-state">No items marked for deletion yet. Run validation to identify problematic products.</p>
                    </div>
                </div>

                <!-- Validation Info -->
                <div class="categories-reference">
                    <h3>‚ÑπÔ∏è What Gets Validated</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 16px; margin-top: 12px;">
                        <div class="info-card" style="background: #f0fdf4; border-left: 3px solid #22c55e; padding: 12px;">
                            <strong style="color: #15803d;">‚úèÔ∏è Auto-Fixed</strong>
                            <ul style="margin: 8px 0 0 16px; font-size: 13px; color: #166534;">
                                <li>Spelling errors in names</li>
                                <li>UK spelling in ingredients</li>
                                <li>Brand capitalisation</li>
                                <li>Dirty data removal</li>
                            </ul>
                        </div>
                        <div class="info-card" style="background: #fef2f2; border-left: 3px solid #ef4444; padding: 12px;">
                            <strong style="color: #b91c1c;">üóëÔ∏è Marked for Delete</strong>
                            <ul style="margin: 8px 0 0 16px; font-size: 13px; color: #991b1b;">
                                <li>Non-UK products (Coke Light, etc.)</li>
                                <li>Discontinued products</li>
                                <li>Wildly wrong calories</li>
                                <li>Corrupted/garbled entries</li>
                            </ul>
                        </div>
                        <div class="info-card" style="background: #fefce8; border-left: 3px solid #eab308; padding: 12px;">
                            <strong style="color: #a16207;">üìã Needs Review</strong>
                            <ul style="margin: 8px 0 0 16px; font-size: 13px; color: #92400e;">
                                <li>Uncertain corrections</li>
                                <li>Multiple issues found</li>
                                <li>Low confidence changes</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Edit Food Modal -->
    <div id="edit-modal" class="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-nav">
                    <button class="nav-arrow" id="prev-food-btn" onclick="app.prevFood()" title="Previous food">‚Üê</button>
                    <span class="nav-position" id="food-position">1 / 20</span>
                    <button class="nav-arrow" id="next-food-btn" onclick="app.nextFood()" title="Next food">‚Üí</button>
                </div>
                <h2>Edit Food</h2>
                <button class="modal-close" onclick="app.closeModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="edit-food-id">
                <div class="form-grid">
                    <div class="form-group full-width">
                        <label>Food Name *</label>
                        <input type="text" id="edit-food-name" required>
                    </div>
                    <div class="form-group">
                        <label>Brand Name</label>
                        <input type="text" id="edit-brand-name">
                    </div>
                    <div class="form-group">
                        <label>Barcode</label>
                        <input type="text" id="edit-barcode">
                    </div>
                    <div class="form-group">
                        <label>Serving Size</label>
                        <input type="text" id="edit-serving-size" placeholder="e.g., 100g">
                    </div>
                    <div class="form-group">
                        <label>Category</label>
                        <select id="edit-category">
                            <option value="">Select category</option>
                            <option value="beverages">Beverages</option>
                            <option value="dairy">Dairy</option>
                            <option value="grains">Grains & Cereals</option>
                            <option value="fruits">Fruits</option>
                            <option value="vegetables">Vegetables</option>
                            <option value="protein">Protein</option>
                            <option value="snacks">Snacks</option>
                            <option value="condiments">Condiments</option>
                            <option value="other">Other</option>
                        </select>
                    </div>
                </div>

                <div class="form-section">
                    <h3>Ingredients</h3>
                    <div class="form-group full-width">
                        <label>Ingredients List</label>
                        <textarea id="edit-ingredients" placeholder="Enter ingredients separated by commas..."></textarea>
                    </div>
                </div>

                <div class="form-section">
                    <h3>Nutrition (per 100g)</h3>
                    <div class="form-grid">
                        <div class="form-group">
                            <label>Calories (kcal)</label>
                            <input type="number" id="edit-calories" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Protein (g)</label>
                            <input type="number" id="edit-protein" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Carbohydrates (g)</label>
                            <input type="number" id="edit-carbs" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Fat (g)</label>
                            <input type="number" id="edit-fat" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Fiber (g)</label>
                            <input type="number" id="edit-fiber" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Sugar (g)</label>
                            <input type="number" id="edit-sugar" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Salt (g)</label>
                            <input type="number" id="edit-salt" step="0.01">
                        </div>
                    </div>
                </div>

                <div class="form-section">
                    <h3>Verification Status</h3>
                    <div class="form-grid">
                        <div class="form-group">
                            <label>Verified By</label>
                            <select id="edit-verified-by">
                                <option value="">Not Verified</option>
                                <option value="admin">Admin</option>
                                <option value="ai">AI System</option>
                                <option value="user">User Submitted</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="app.closeModal()">Cancel</button>
                <button class="btn btn-primary" onclick="app.saveFood()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Report Review Modal -->
    <div id="report-modal" class="modal-overlay">
        <div class="modal" style="max-width: 900px;">
            <div class="modal-header">
                <h2>Review Report</h2>
                <button class="modal-close" onclick="app.closeReportModal()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Report Info Section -->
                <div class="report-info-section">
                    <h4>User Report</h4>
                    <div id="report-details"></div>
                </div>

                <!-- AI Actions -->
                <div class="ai-actions">
                    <button class="btn btn-ai" id="ai-fix-btn" onclick="app.aiAutoFix()">
                        ü§ñ AI Auto-Fix
                    </button>
                    <button class="btn btn-secondary" onclick="app.searchGoogle()">
                        üîç Search Google
                    </button>
                    <span id="ai-status"></span>
                </div>

                <!-- AI Suggestions (hidden until AI runs) -->
                <div id="ai-suggestions" class="ai-suggestions" style="display:none;"></div>

                <!-- Editable Food Form -->
                <input type="hidden" id="report-food-id">
                <input type="hidden" id="report-id">
                <input type="hidden" id="report-food-index">
                <div class="form-grid">
                    <div class="form-group full-width">
                        <label>Food Name *</label>
                        <input type="text" id="report-food-name" required>
                    </div>
                    <div class="form-group">
                        <label>Brand Name</label>
                        <input type="text" id="report-brand-name">
                    </div>
                    <div class="form-group">
                        <label>Barcode</label>
                        <input type="text" id="report-barcode">
                    </div>
                    <div class="form-group">
                        <label>Serving Description</label>
                        <input type="text" id="report-serving-size" placeholder="e.g., Tall (12oz), per slice">
                    </div>
                    <div class="form-group">
                        <label>Serving Size (g/ml)</label>
                        <input type="number" id="report-serving-size-g" placeholder="e.g., 354" step="0.1" min="0">
                    </div>
                    <div class="form-group">
                        <label>Unit</label>
                        <select id="report-serving-unit">
                            <option value="g">g (grams)</option>
                            <option value="ml">ml (liquid)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Category</label>
                        <input type="text" id="report-category">
                    </div>
                </div>

                <div class="form-section">
                    <h3>Ingredients</h3>
                    <div class="form-group full-width">
                        <label>Ingredients List</label>
                        <textarea id="report-ingredients" placeholder="Enter ingredients separated by commas..."></textarea>
                    </div>
                </div>

                <div class="form-section">
                    <h3>Nutrition (per 100g)</h3>
                    <div class="form-grid">
                        <div class="form-group">
                            <label>Calories (kcal)</label>
                            <input type="number" id="report-calories" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Protein (g)</label>
                            <input type="number" id="report-protein" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Carbohydrates (g)</label>
                            <input type="number" id="report-carbs" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Fat (g)</label>
                            <input type="number" id="report-fat" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Fiber (g)</label>
                            <input type="number" id="report-fiber" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Sugar (g)</label>
                            <input type="number" id="report-sugar" step="0.1">
                        </div>
                        <div class="form-group">
                            <label>Salt (g)</label>
                            <input type="number" id="report-salt" step="0.01">
                        </div>
                        <div class="form-group">
                            <label>Saturated Fat (g)</label>
                            <input type="number" id="report-saturated-fat" step="0.1">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="app.closeReportModal()">Cancel</button>
                <button class="btn btn-danger" onclick="app.deleteReportedFood()">üóëÔ∏è Delete Food</button>
                <button class="btn btn-secondary" onclick="app.dismissReport()">Dismiss</button>
                <button class="btn btn-success" onclick="app.saveOnly()">üíæ Save</button>
                <button class="btn btn-primary" onclick="app.saveAndResolve()">‚úì Save & Resolve</button>
            </div>
        </div>
    </div>

    <!-- Verification Detail Modal -->
    <div id="verification-modal" class="modal-overlay">
        <div class="modal verification-modal">
            <div class="verification-header">
                <div class="verification-product-info">
                    <h2 id="verify-modal-title">Product Name</h2>
                    <div class="product-meta">
                        <span id="verify-modal-brand">Brand</span> |
                        <span id="verify-modal-barcode">Barcode</span> |
                        <span id="verify-modal-country">Country</span>
                    </div>
                </div>
                <div class="verification-status-area">
                    <span class="verification-badge status-unverified" id="verify-modal-status">UNVERIFIED</span>
                    <div class="confidence-score" id="verify-modal-confidence">
                        <span>Confidence:</span>
                        <div class="confidence-bar">
                            <div class="confidence-fill high" id="verify-modal-confidence-fill" style="width: 0%"></div>
                        </div>
                        <span id="verify-modal-confidence-value">0%</span>
                    </div>
                    <button class="modal-close" onclick="app.closeVerificationModal()">&times;</button>
                </div>
            </div>

            <!-- Dry Run Banner -->
            <div class="dry-run-banner" id="dry-run-banner" style="display: none;">
                <span class="icon">‚ö†Ô∏è</span>
                <div class="text">
                    <strong>DRY RUN MODE</strong>
                    <p>Changes shown below are PROPOSED only. Click "Apply Changes" to save to database.</p>
                </div>
            </div>

            <!-- Side-by-Side Comparison -->
            <div class="comparison-container" id="comparison-container">
                <div class="comparison-column original">
                    <h4>üìÑ Original Data (Current)</h4>
                    <div id="original-data-fields"></div>
                </div>
                <div class="comparison-column verified">
                    <h4>‚úÖ Verified Data (Proposed)</h4>
                    <div id="verified-data-fields"></div>
                </div>
            </div>

            <!-- Sources Used -->
            <div class="sources-list" id="sources-list" style="display: none;">
                <h4>üìö Data Sources Used</h4>
                <div id="sources-items"></div>
            </div>

            <!-- Change Log -->
            <div class="change-log" id="change-log" style="display: none;">
                <h4>üìù Proposed Changes</h4>
                <div id="change-log-entries"></div>
            </div>

            <!-- Audit Log -->
            <div class="audit-log-section" id="audit-log-section" style="display: none;">
                <h4>üìã Verification History</h4>
                <div id="audit-log-entries"></div>
            </div>

            <!-- Verification Footer -->
            <div class="verification-footer">
                <div class="action-group">
                    <button class="btn-reject" onclick="app.rejectProposedChanges()">Reject All</button>
                    <button class="btn-flag" onclick="app.flagForManualReview()">Flag for Review</button>
                </div>
                <div class="action-group">
                    <button class="btn btn-secondary" onclick="app.closeVerificationModal()">Close</button>
                    <button class="btn-accept" id="btn-apply-changes" onclick="app.applyProposedChanges()">Apply Changes</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Verification Progress Overlay -->
    <div id="verification-progress-overlay" class="verification-progress-overlay" style="display: none;">
        <div class="verification-progress-card">
            <h3 id="verify-progress-title">Verifying Foods...</h3>
            <div class="subtitle" id="verify-progress-subtitle">Searching online sources for product data</div>

            <div class="verification-progress-bar">
                <div class="verification-progress-fill" id="verify-progress-fill" style="width: 0%"></div>
            </div>

            <div style="font-size: 14px; color: #374151; margin-bottom: 8px;">
                <span id="verify-progress-current">0</span> / <span id="verify-progress-total">0</span> items processed
            </div>

            <div class="verification-progress-stats">
                <div class="progress-stat stat-verified">
                    <div class="value" id="verify-stat-verified">0</div>
                    <div class="label">Verified</div>
                </div>
                <div class="progress-stat stat-updated">
                    <div class="value" id="verify-stat-updated">0</div>
                    <div class="label">Updated</div>
                </div>
                <div class="progress-stat stat-flagged">
                    <div class="value" id="verify-stat-flagged">0</div>
                    <div class="label">Flagged</div>
                </div>
                <div class="progress-stat stat-skipped">
                    <div class="value" id="verify-stat-skipped">0</div>
                    <div class="label">Skipped</div>
                </div>
            </div>

            <div class="verification-log-stream" id="verification-log-stream">
                <div class="log-line log-skip">Waiting to start...</div>
            </div>

            <div style="margin-top: 20px;">
                <button class="btn btn-secondary" onclick="app.cancelVerification()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>

    <!-- UK Source Discovery Modal -->
    <div id="discovery-modal" class="modal-overlay">
        <div class="modal discovery-modal">
            <div class="discovery-header">
                <h2>üîç Discover UK Sources</h2>
                <div class="product-info" id="discovery-product-info">
                    <span id="discovery-product-name">Product Name</span> |
                    <span id="discovery-product-barcode">Barcode</span>
                </div>
                <button class="modal-close" onclick="app.closeDiscoveryModal()" style="position: absolute; top: 16px; right: 16px;">&times;</button>
            </div>

            <div class="discovery-body">
                <!-- Loading State -->
                <div class="discovery-loading" id="discovery-loading" style="display: none;">
                    <div class="spinner"></div>
                    <div>Searching UK supermarket databases...</div>
                </div>

                <!-- Error State -->
                <div class="discovery-error" id="discovery-error" style="display: none;">
                    <p>Unable to search automatically. Use the manual search links below.</p>
                </div>

                <!-- Discovered Sources -->
                <div class="discovery-section" id="discovered-sources-section" style="display: none;">
                    <h3>üè™ Discovered UK Sources</h3>
                    <div class="source-cards" id="discovered-sources"></div>
                </div>

                <!-- Extraction Preview -->
                <div class="extraction-preview" id="extraction-preview" style="display: none;">
                    <h4>‚úÖ Extracted Nutrition Data (per 100g)</h4>
                    <div class="extraction-grid" id="extraction-data"></div>
                    <div style="margin-top: 12px; display: flex; gap: 8px;">
                        <button class="btn btn-primary" onclick="app.applyExtractedData()">Apply This Data</button>
                        <button class="btn btn-secondary" onclick="app.clearExtraction()">Clear</button>
                    </div>
                </div>

                <!-- Manual Search Section -->
                <div class="discovery-section">
                    <div class="manual-search-section">
                        <h4>üîó Manual Search Links</h4>
                        <p style="font-size: 12px; color: #92400e; margin-bottom: 12px;">Click to search each UK supermarket directly:</p>
                        <div class="search-links-grid" id="manual-search-links">
                            <!-- Links populated dynamically -->
                        </div>
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #fde68a;">
                            <p style="font-size: 11px; color: #92400e; margin-bottom: 8px;">Or copy Google search query:</p>
                            <div style="display: flex; gap: 8px;">
                                <input type="text" id="google-search-query" readonly style="flex: 1; padding: 8px; font-size: 11px; border: 1px solid #fde68a; border-radius: 4px; background: white;">
                                <button class="btn btn-secondary" onclick="app.copyGoogleQuery()" style="font-size: 11px; padding: 8px 12px;">Copy</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Manual URL Entry -->
                <div class="discovery-section">
                    <h3>üì• Extract from URL</h3>
                    <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">Found a product page? Paste the URL here to extract nutrition data:</p>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" id="manual-extract-url" placeholder="https://www.tesco.com/groceries/..." style="flex: 1; padding: 10px; font-size: 13px; border: 1px solid var(--border); border-radius: 6px;">
                        <button class="btn btn-primary" onclick="app.extractFromManualUrl()" id="extract-url-btn">Extract</button>
                    </div>
                </div>
            </div>

            <div class="discovery-footer">
                <div class="status-text" id="discovery-status">Enter a URL or use manual search links</div>
                <div>
                    <button class="btn btn-secondary" onclick="app.closeDiscoveryModal()">Close</button>
                </div>
            </div>
        </div>
    </div>
    </div><!-- End main-app -->


    <script>
        // Configuration
        const CONFIG = {
            ALGOLIA_APP_ID: 'WK0TIF84M2',
            ALGOLIA_SEARCH_KEY: '577cc4ee3fed660318917bbb54abfb2e',
            API_BASE: 'https://us-central1-nutrasafe-705c7.cloudfunctions.net',
            ITEMS_PER_PAGE: 50
        };

        // Initialize Algolia
        const algoliaClient = algoliasearch(CONFIG.ALGOLIA_APP_ID, CONFIG.ALGOLIA_SEARCH_KEY);
        let currentIndex = algoliaClient.initIndex('uk_foods_cleaned');

        // Application State
        const state = {
            // Algolia client reference for session reloading
            searchClient: algoliaClient,
            currentView: 'foods',
            foods: [],
            filteredFoods: [],
            reports: [],
            currentPage: 0,
            totalPages: 0,
            totalHits: 0,
            currentQuery: '',
            editingFood: null,
            editingIndex: 0,
            reviewingReport: null,
            aiSuggestions: null,
            // Database Check state
            scanResults: [],
            filteredScanResults: [],
            pendingEdits: {},
            pendingDeletes: new Set(),
            pendingFixes: {}, // { 'html-code': ['objectID1', 'objectID2'], 'simple-ingredients': ['objectID3'] }
            scanInProgress: false,
            currentScanIndex: '',
            currentIssueFilter: 'all',
            // Session persistence
            savedSessions: [],
            activeSessionId: null,
            lastStorageWarning: null,
            lastStorageError: null,
            // Pagination for issues
            issuesCurrentPage: 0,
            issuesPerPage: 50,
            // Selection state
            selectedItems: new Set(),
            // Duplicates detection
            duplicateGroups: [],
            duplicatesMap: new Map(), // objectID -> duplicate group
            // AI correction state (legacy - being replaced)
            aiCorrectionInProgress: false,
            aiCorrectionResults: new Map(), // objectID -> corrections

            // NEW: Verification System State
            verificationInProgress: false,
            verificationCancelled: false,
            verificationResults: new Map(), // objectID -> verification result
            currentVerificationItem: null, // Item being viewed in verification modal
            proposedChanges: null, // Changes proposed for current item

            // Verification Statistics
            verificationStats: {
                processed: 0,
                verified: 0,
                updated: 0,
                flagged: 0,
                skipped: 0,
                errors: 0
            },

            // Verification Log for current batch
            verificationLog: [],

            // Issue Ledger System (proper before/after tracking)
            issueLedger: null, // Will be set when scan completes
            currentLedgerFilter: 'all', // all | pending | resolved | skipped

            // UK Source Discovery
            discoveryFoodItem: null, // Current food item being discovered
            discoveredSources: [], // Discovered UK sources for current item
            extractedData: null, // Extracted nutrition data from source
            extractionSourceUrl: null, // URL of source that was extracted

            // Batch Discovery
            batchDiscoveryInProgress: false,
            batchDiscoveryPaused: false,
            batchDiscoveryQueue: [], // Items to process
            batchDiscoveryProcessed: 0,
            batchDiscoveryTotal: 0,
            batchDiscoverySuccessful: 0,
            batchDiscoveryFailed: 0,
            batchDiscoveryRateLimit: 100, // ms between calls (10 req/sec - Google is the real bottleneck)
            batchDiscoveryResults: [], // Live results for display {objectID, name, status, source, changes, error, barcode, brand}
            batchResultsFilter: 'all', // Filter for batch results display: all | success | failed | skipped

            // Email Marketing State
            authEmails: [], // All authenticated user emails
            filteredAuthEmails: [], // Filtered emails for display
            selectedAuthEmails: new Set(), // Selected email UIDs
            emailSearchQuery: '', // Current search query
            emailsLoading: false,
            emailsSortBy: 'createdAt', // createdAt | lastSignIn | email
            emailsSortOrder: 'desc', // asc | desc

            // Tesco Database Builder State
            tescoBuildProgress: null, // Current build progress from Firebase
            tescoBuildLoading: false,
            tescoLastUpdateTime: null, // Timestamp of last progress update
            tescoActivityLog: [], // Activity log entries
            tescoStallThreshold: 60000, // 60 seconds before showing stall warning
            tescoPreviousProgress: null, // Previous progress for change detection
            tescoStats: null, // Database statistics
            tescoAutoRestartEnabled: true, // Auto-restart on stall (default ON)
            tescoAutoRestartThreshold: 60000, // 60 seconds before auto-restart (reduced from 90)
            tescoAutoRestartCount: 0, // Count of auto-restarts this session
            tescoLastAutoRestart: null, // Timestamp of last auto-restart
            tescoAutoRestartCooldown: 30000, // Minimum 30s between auto-restarts
            tescoAutoRestarting: false, // Currently in auto-restart process
            tescoStopRequested: false, // User clicked Stop - block all auto-restarts
            tescoPeriodicRestartInterval: 300000, // 5 minutes - do proactive restart
            tescoLastPeriodicRestart: null, // Timestamp of last periodic restart

            // Authentication State
            currentUser: null, // Firebase auth user
            isAuthenticated: false,
            authLoading: true // Show loading until auth state is determined
        };

        // Main Application
        const app = {
            init() {
                // Set up Firebase Auth state listener FIRST
                this.setupAuthListener();
            },

            // Called after successful authentication
            initAuthenticatedApp() {
                this.bindEvents();
                this.loadFoods();
                this.loadReportsCount();
                this.loadSavedSessions();
                this.updateIndexCounts(); // Fetch real counts from Algolia
            },

            // Fetch actual record counts from Algolia for all indices
            async updateIndexCounts() {
                const indices = [
                    { name: 'uk_foods_cleaned', label: 'UK Foods Cleaned' },
                    { name: 'tesco_products', label: 'Tesco Products' },
                    { name: 'foods', label: 'All Foods' },
                    { name: 'generic_database', label: 'Generic Database' },
                    { name: 'fast_foods_database', label: 'Fast Foods' },
                    { name: 'user_added', label: 'User Added' },
                    { name: 'ai_manually_added', label: 'AI Manually Added' },
                    { name: 'verified_foods', label: 'Verified Foods' },
                    { name: 'manual_foods', label: 'Manual Foods' }
                ];

                console.log('üìä Fetching index counts from Algolia...');

                // Fetch counts in parallel
                const counts = await Promise.all(indices.map(async (idx) => {
                    try {
                        const index = algoliaClient.initIndex(idx.name);
                        // Use empty search with 0 hits to get nbHits count
                        const result = await index.search('', { hitsPerPage: 0 });
                        return { name: idx.name, label: idx.label, count: result.nbHits };
                    } catch (e) {
                        console.warn(`Failed to get count for ${idx.name}:`, e.message);
                        return { name: idx.name, label: idx.label, count: 0 };
                    }
                }));

                console.log('üìä Index counts:', counts);

                // Update both dropdown selects
                const collectionFilter = document.getElementById('collection-filter');
                const scanIndex = document.getElementById('scan-index');

                counts.forEach(({ name, label, count }) => {
                    const formattedCount = count.toLocaleString();
                    const displayText = `${label} (${formattedCount})`;

                    // Update collection-filter dropdown
                    if (collectionFilter) {
                        const option = collectionFilter.querySelector(`option[value="${name}"]`);
                        if (option) option.textContent = displayText;
                    }

                    // Update scan-index dropdown
                    if (scanIndex) {
                        const option = scanIndex.querySelector(`option[value="${name}"]`);
                        if (option) option.textContent = displayText;
                    }
                });

                console.log('‚úÖ Index counts updated');
            },

            setupAuthListener() {
                console.log('Setting up auth listener...');
                firebase.auth().onAuthStateChanged(async (user) => {
                    state.authLoading = false;
                    console.log('Auth state changed:', user ? user.email : 'not signed in');

                    if (user) {
                        // User is signed in - verify token is valid
                        try {
                            const token = await user.getIdToken(true); // Force refresh
                            console.log('Auth token refreshed, length:', token.length);
                            state.currentUser = user;
                            state.isAuthenticated = true;
                            this.onAuthSuccess(user);
                        } catch (tokenError) {
                            console.error('Failed to get auth token:', tokenError);
                            // Token refresh failed - force re-login
                            await firebase.auth().signOut();
                            this.showLoginForm();
                        }
                    } else {
                        // User is signed out
                        state.currentUser = null;
                        state.isAuthenticated = false;
                        this.showLoginForm();
                    }
                });
            },

            onAuthSuccess(user) {
                // Hide login, show main app
                document.getElementById('login-container').classList.add('hidden');
                document.getElementById('main-app').classList.add('authenticated');

                // Display user email and UID (for admin setup)
                const userEmailEl = document.getElementById('user-email');
                if (userEmailEl) {
                    userEmailEl.textContent = user.email;
                    userEmailEl.title = `UID: ${user.uid}`; // Show UID on hover
                }

                // Initialize the rest of the app
                this.initAuthenticatedApp();

                console.log('User authenticated:', user.email);
                console.log('User UID (add to /admins collection for full access):', user.uid);
            },

            showLoginForm() {
                document.getElementById('login-container').classList.remove('hidden');
                document.getElementById('main-app').classList.remove('authenticated');
                document.getElementById('login-error').classList.remove('show');
            },

            async handleLogin(event) {
                event.preventDefault();

                const email = document.getElementById('login-email').value.trim();
                const password = document.getElementById('login-password').value;
                const loginBtn = document.getElementById('login-btn');
                const errorEl = document.getElementById('login-error');

                if (!email || !password) {
                    errorEl.textContent = 'Please enter both email and password';
                    errorEl.classList.add('show');
                    return false;
                }

                // Disable button during login
                loginBtn.disabled = true;
                loginBtn.textContent = 'Signing in...';
                errorEl.classList.remove('show');

                try {
                    await firebase.auth().signInWithEmailAndPassword(email, password);
                    // Auth state listener will handle the rest
                } catch (error) {
                    console.error('Login error:', error);

                    // User-friendly error messages
                    let message = 'Login failed. Please try again.';
                    switch (error.code) {
                        case 'auth/invalid-email':
                            message = 'Invalid email address format.';
                            break;
                        case 'auth/user-disabled':
                            message = 'This account has been disabled.';
                            break;
                        case 'auth/user-not-found':
                            message = 'No account found with this email.';
                            break;
                        case 'auth/wrong-password':
                            message = 'Incorrect password.';
                            break;
                        case 'auth/too-many-requests':
                            message = 'Too many failed attempts. Please try again later.';
                            break;
                        case 'auth/invalid-credential':
                            message = 'Invalid email or password.';
                            break;
                    }

                    errorEl.textContent = message;
                    errorEl.classList.add('show');
                } finally {
                    loginBtn.disabled = false;
                    loginBtn.textContent = 'Sign In';
                }

                return false;
            },

            async handleLogout() {
                try {
                    // Stop any polling
                    this.stopTescoProgressPolling();

                    await firebase.auth().signOut();
                    // Auth state listener will handle the rest

                    // Reset relevant state
                    state.authEmails = [];
                    state.filteredAuthEmails = [];
                    state.selectedAuthEmails.clear();
                    state.tescoBuildProgress = null;
                    state.tescoStats = null;

                    console.log('User signed out');
                } catch (error) {
                    console.error('Logout error:', error);
                    this.showToast('Failed to sign out', 'error');
                }
            },

            bindEvents() {
                // Navigation
                document.querySelectorAll('.nav-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => this.switchView(e.target.dataset.view));
                });

                // Search
                document.getElementById('search-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.search();
                });
                document.getElementById('search-btn').addEventListener('click', () => this.search());

                // Filters
                document.getElementById('collection-filter').addEventListener('change', () => this.onCollectionChange());
                document.getElementById('quality-filter').addEventListener('change', () => this.applyQualityFilter());
                document.getElementById('report-status-filter').addEventListener('change', () => this.filterReports());

                // Pagination
                document.getElementById('prev-btn').addEventListener('click', () => this.prevPage());
                document.getElementById('next-btn').addEventListener('click', () => this.nextPage());

                // Modal close on overlay click
                document.getElementById('edit-modal').addEventListener('click', (e) => {
                    if (e.target.classList.contains('modal-overlay')) this.closeModal();
                });
            },

            switchView(view) {
                state.currentView = view;
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelector(`[data-view="${view}"]`).classList.add('active');
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                document.getElementById(`${view}-view`).classList.add('active');

                if (view === 'reports') {
                    this.loadReports();
                } else if (view === 'email-marketing') {
                    // Load emails if not already loaded
                    if (state.authEmails.length === 0 && !state.emailsLoading) {
                        this.loadAuthEmails();
                    }
                } else if (view === 'tesco-builder') {
                    // Load Tesco build progress
                    this.refreshTescoProgress();
                } else if (view === 'ai-categories') {
                    // Initialize AI Categories view
                    this.initCategoriesView();
                } else if (view === 'ai-validation') {
                    // Initialize AI Validation view
                    this.initValidationView();
                }
            },

            // Foods Functions
            async loadFoods(query = '', page = 0) {
                state.currentQuery = query;
                state.currentPage = page;

                const foodList = document.getElementById('food-list');
                foodList.innerHTML = '<div class="loading"><div class="spinner"></div><span>Searching...</span></div>';

                try {
                    const results = await currentIndex.search(query, {
                        page: page,
                        hitsPerPage: CONFIG.ITEMS_PER_PAGE
                    });

                    state.foods = results.hits;
                    state.totalHits = results.nbHits;
                    state.totalPages = results.nbPages;

                    this.applyQualityFilter();
                } catch (error) {
                    console.error('Search error:', error);
                    foodList.innerHTML = '<div class="empty-state">Error loading foods. Please try again.</div>';
                }
            },

            onCollectionChange() {
                const collection = document.getElementById('collection-filter').value;
                currentIndex = algoliaClient.initIndex(collection);
                state.currentPage = 0;
                this.loadFoods(state.currentQuery, 0);
            },

            applyQualityFilter() {
                const filter = document.getElementById('quality-filter').value;
                let filtered = [...state.foods];

                // Debug: log first food structure
                if (state.foods.length > 0) {
                    const f = state.foods[0];
                    console.log('üîç First food structure:', {
                        name: f.foodName || f.name,
                        calories: f.calories,
                        kcal: f.kcal,
                        energy: f.energy,
                        protein: f.protein,
                        carbs: f.carbs,
                        carbohydrates: f.carbohydrates,
                        fat: f.fat,
                        nutritionData: f.nutritionData,
                        nutrition: f.nutrition,
                        allKeys: Object.keys(f).filter(k => !k.startsWith('_'))
                    });
                }

                if (filter === 'missing-nutrition') {
                    filtered = filtered.filter(f => this.getMissingNutrition(f).length > 0);
                    console.log(`üîç Missing nutrition filter: ${filtered.length} of ${state.foods.length} foods have missing data`);
                } else if (filter === 'missing-ingredients') {
                    filtered = filtered.filter(f => !this.hasIngredients(f));
                } else if (filter === 'missing-barcode') {
                    filtered = filtered.filter(f => !f.barcode);
                } else if (filter === 'misspellings') {
                    filtered = filtered.filter(f => this.hasMisspelling(f));
                    console.log(`üîç Misspellings filter: ${filtered.length} of ${state.foods.length} foods have misspellings`);
                } else if (filter === 'complete') {
                    filtered = filtered.filter(f => this.getMissingNutrition(f).length === 0 && this.hasIngredients(f) && f.barcode);
                }

                state.filteredFoods = filtered;
                this.renderFoods();
            },

            // Returns array of missing nutrition field names
            getMissingNutrition(food) {
                // Check both nested (nutritionData/nutrition) and top-level properties
                const n = food.nutritionData || food.nutrition || {};
                const missing = [];

                // Helper to get value from nested or top-level
                // Returns the actual value, treating undefined/null/'' as 0 for comparison
                const getValue = (nested, top) => {
                    const nestedVal = n[nested];
                    const topVal = food[top];
                    // Return the first valid number found
                    if (typeof nestedVal === 'number') return nestedVal;
                    if (typeof topVal === 'number') return topVal;
                    // Check string values that might be numeric
                    if (nestedVal !== undefined && nestedVal !== null && nestedVal !== '') return parseFloat(nestedVal) || 0;
                    if (topVal !== undefined && topVal !== null && topVal !== '') return parseFloat(topVal) || 0;
                    return 0;
                };

                const calories = getValue('calories', 'calories');
                const protein = getValue('protein', 'protein');
                const carbs = getValue('carbohydrates', 'carbs') || getValue('carbs', 'carbohydrates');
                const fat = getValue('fat', 'fat');

                // If ALL core macros are 0, it's almost certainly missing data
                // (no real food has 0 cal, 0 protein, 0 carbs, AND 0 fat except water)
                const allZero = calories === 0 && protein === 0 && carbs === 0 && fat === 0;

                if (allZero) {
                    // Flag all as missing since data is clearly incomplete
                    return ['calories', 'protein', 'carbs', 'fat'];
                }

                // For individual checks, calories=0 is suspicious (almost nothing has 0 cal)
                // But protein=0, carbs=0, or fat=0 can be valid
                if (calories === 0) missing.push('calories');
                // Only flag protein/carbs/fat as missing if they're undefined/null (not 0)
                if (food.protein === undefined && n.protein === undefined) missing.push('protein');
                if ((food.carbs === undefined && food.carbohydrates === undefined) &&
                    (n.carbs === undefined && n.carbohydrates === undefined)) missing.push('carbs');
                if (food.fat === undefined && n.fat === undefined) missing.push('fat');

                return missing;
            },

            // Check if food has all core nutrition (calories, protein, carbs, fat)
            hasNutrition(food) {
                return this.getMissingNutrition(food).length === 0;
            },

            hasIngredients(food) {
                return (food.extractedIngredients && food.extractedIngredients.length > 0) ||
                       (food.ingredients && food.ingredients.length > 0);
            },

            // Check for common misspellings in food name or ingredients
            hasMisspelling(food) {
                const text = `${food.foodName || food.name || ''} ${food.brandName || food.brand || ''} ${(food.extractedIngredients || food.ingredients || []).join(' ')}`.toLowerCase();

                // Common misspellings to detect (UK spellings like flavour/colour are CORRECT)
                const misspellings = [
                    'protien', 'caloires', 'carbohidrates', 'suger', 'sodiem', 'soduim',
                    'choclate', 'chocolat', 'cholocate', 'vanila', 'vanilia', 'strawbery', 'bluberry', 'blueberrry',
                    'oragne', 'oraneg', 'bananana', 'bannana', 'appel', 'lemmon', 'cheery', 'cherrie',
                    'chiken', 'chickin', 'chickn', 'beaf', 'prok', 'salman', 'samon', 'tunna',
                    'vegatable', 'vegetabel', 'vegitables', 'tomatoe', 'tomatos', 'potatos', 'letuce', 'lettuse',
                    'cheeze', 'chese', 'cheesse', 'yougurt', 'yoghert', 'yougrt', 'buuter', 'buttr',
                    'breackfast', 'breakfest', 'luch', 'diner', 'dinr', 'snaks', 'deserts',
                    'ceral', 'cerael', 'cerial', 'biscits', 'biscuts', 'chrisps', 'crissp',
                    'oragnic', 'orgainc', 'natual', 'natrual', 'artifical', 'artifcial', 'preservitive',
                    'containts', 'ingredeints', 'ingrdients', 'nutritoin', 'nutrtion', 'servng', 'seving',
                    'flavord', 'colord', 'favourate', // US misspellings
                    'calcuim', 'magneisum', 'potasium', 'pottasium', 'vitmin', 'vitamn'
                ];

                return misspellings.some(m => text.includes(m));
            },

            renderFoods() {
                const foodList = document.getElementById('food-list');
                const stats = document.getElementById('results-stats');

                if (state.filteredFoods.length === 0) {
                    foodList.innerHTML = '<div class="empty-state">No foods found matching your criteria.</div>';
                    stats.textContent = '0 results';
                    document.getElementById('pagination').style.display = 'none';
                    return;
                }

                const filter = document.getElementById('quality-filter').value;
                if (filter !== 'all') {
                    stats.textContent = `${state.filteredFoods.length} of ${state.foods.length} on this page (${state.totalHits.toLocaleString()} total in database)`;
                } else {
                    stats.textContent = `${state.totalHits.toLocaleString()} total ‚Ä¢ Page limited to 1000 by Algolia`;
                }

                const html = state.filteredFoods.map(food => {
                    const missingNutrition = this.getMissingNutrition(food);
                    const missingBadges = missingNutrition.length > 0
                        ? `<div class="missing-info">${missingNutrition.map(f => `<span class="missing-badge">${f}</span>`).join('')}</div>`
                        : '';

                    return `
                    <div class="food-item" data-id="${food.objectID}">
                        <div class="food-info">
                            <h3>${this.escapeHtml(food.foodName || food.name || 'Unknown')}</h3>
                            <div class="meta">
                                <span>${this.escapeHtml(food.brandName || food.brand || 'No brand')}</span>
                                <span>${food.barcode || 'No barcode'}</span>
                            </div>
                            ${missingBadges}
                        </div>
                        <div class="quality-dots">
                            <div class="quality-dot ${this.hasNutrition(food) ? 'good' : 'bad'}" data-tooltip="Nutrition ${this.hasNutrition(food) ? '‚úì' : '‚úó'}"></div>
                            <div class="quality-dot ${this.hasIngredients(food) ? 'good' : 'bad'}" data-tooltip="Ingredients ${this.hasIngredients(food) ? '‚úì' : '‚úó'}"></div>
                            <div class="quality-dot ${food.barcode ? 'good' : 'bad'}" data-tooltip="Barcode ${food.barcode ? '‚úì' : '‚úó'}"></div>
                        </div>
                        <div class="food-actions">
                            <button class="btn btn-primary" onclick="app.editFood('${food.objectID}')">Edit</button>
                            <button class="btn btn-danger" onclick="app.deleteFood('${food.objectID}')">Delete</button>
                        </div>
                    </div>
                `;
                }).join('');

                foodList.innerHTML = html;

                // Pagination
                const pagination = document.getElementById('pagination');
                pagination.style.display = 'flex';
                document.getElementById('prev-btn').disabled = state.currentPage === 0;
                document.getElementById('next-btn').disabled = state.currentPage >= state.totalPages - 1;
                document.getElementById('page-info').textContent = `Page ${state.currentPage + 1} of ${state.totalPages}`;
            },

            search() {
                const query = document.getElementById('search-input').value.trim();
                this.loadFoods(query, 0);
            },

            prevPage() {
                if (state.currentPage > 0) {
                    this.loadFoods(state.currentQuery, state.currentPage - 1);
                }
            },

            nextPage() {
                if (state.currentPage < state.totalPages - 1) {
                    this.loadFoods(state.currentQuery, state.currentPage + 1);
                }
            },

            editFood(id) {
                const food = state.foods.find(f => f.objectID === id);
                if (!food) return;

                state.editingFood = food;
                // Track index in filtered list for navigation
                state.editingIndex = state.filteredFoods.findIndex(f => f.objectID === id);

                this.populateEditForm(food);
                this.updateNavButtons();
                document.getElementById('edit-modal').classList.add('active');
            },

            populateEditForm(food) {
                // Support both nested nutrition object and flat structure (from Algolia)
                const nutrition = food.nutritionData || food.nutrition || {};
                const ingredients = food.extractedIngredients || food.ingredients || [];

                document.getElementById('edit-food-id').value = food.objectID;
                document.getElementById('edit-food-name').value = food.foodName || food.name || '';
                document.getElementById('edit-brand-name').value = food.brandName || food.brand || '';
                document.getElementById('edit-barcode').value = food.barcode || '';
                document.getElementById('edit-serving-size').value = food.servingSize || '';
                document.getElementById('edit-category').value = food.category || '';
                document.getElementById('edit-ingredients').value = Array.isArray(ingredients) ? ingredients.join(', ') : ingredients;

                // Check both nested nutrition object AND flat structure (Algolia returns flat)
                document.getElementById('edit-calories').value = nutrition.calories || food.calories || '';
                document.getElementById('edit-protein').value = nutrition.protein || food.protein || '';
                document.getElementById('edit-carbs').value = nutrition.carbohydrates || nutrition.carbs || food.carbohydrates || food.carbs || '';
                document.getElementById('edit-fat').value = nutrition.fat || food.fat || '';
                document.getElementById('edit-fiber').value = nutrition.fiber || food.fiber || '';
                document.getElementById('edit-sugar').value = nutrition.sugar || food.sugar || '';

                // Salt calculation - handle both UK (salt in g) and US (sodium in mg) formats
                // Same logic as scan-database.ts to ensure consistency
                const saltFromFood = parseFloat(nutrition.salt || food.salt) || 0;
                const sodiumFromFood = parseFloat(nutrition.sodium || food.sodium) || 0;
                let saltValue = '';
                if (saltFromFood > 0) {
                    // UK format: salt already in grams
                    saltValue = saltFromFood;
                } else if (sodiumFromFood > 0) {
                    // US format: convert sodium mg to salt g (salt = sodium * 2.5 / 1000)
                    saltValue = (sodiumFromFood * 2.5 / 1000).toFixed(2);
                }
                document.getElementById('edit-salt').value = saltValue;

                document.getElementById('edit-verified-by').value = food.verifiedBy || '';
            },

            updateNavButtons() {
                const idx = state.editingIndex;
                const total = state.filteredFoods.length;

                document.getElementById('prev-food-btn').disabled = idx <= 0;
                document.getElementById('next-food-btn').disabled = idx >= total - 1;
                document.getElementById('food-position').textContent = `${idx + 1} / ${total}`;
            },

            prevFood() {
                if (state.editingIndex > 0) {
                    state.editingIndex--;
                    const food = state.filteredFoods[state.editingIndex];
                    state.editingFood = food;
                    this.populateEditForm(food);
                    this.updateNavButtons();
                }
            },

            nextFood() {
                if (state.editingIndex < state.filteredFoods.length - 1) {
                    state.editingIndex++;
                    const food = state.filteredFoods[state.editingIndex];
                    state.editingFood = food;
                    this.populateEditForm(food);
                    this.updateNavButtons();
                }
            },

            closeModal() {
                document.getElementById('edit-modal').classList.remove('active');
                state.editingFood = null;
            },

            async saveFood() {
                const id = document.getElementById('edit-food-id').value;
                const ingredientsRaw = document.getElementById('edit-ingredients').value;
                const ingredients = ingredientsRaw ? ingredientsRaw.split(',').map(i => i.trim()).filter(i => i) : [];

                // Get the current Algolia index from collection filter
                const indexName = document.getElementById('collection-filter').value;

                // Build changes object for Algolia update (flat structure)
                const changes = {
                    foodName: document.getElementById('edit-food-name').value,
                    name: document.getElementById('edit-food-name').value, // Algolia uses 'name' field
                    brandName: document.getElementById('edit-brand-name').value,
                    brand: document.getElementById('edit-brand-name').value, // Algolia uses 'brand' field
                    barcode: document.getElementById('edit-barcode').value,
                    servingSize: document.getElementById('edit-serving-size').value,
                    category: document.getElementById('edit-category').value,
                    extractedIngredients: ingredients,
                    ingredients: ingredients, // Algolia uses 'ingredients' field
                    verifiedBy: document.getElementById('edit-verified-by').value || null,
                    // Flat nutrition fields for Algolia
                    calories: parseFloat(document.getElementById('edit-calories').value) || 0,
                    protein: parseFloat(document.getElementById('edit-protein').value) || 0,
                    carbs: parseFloat(document.getElementById('edit-carbs').value) || 0,
                    carbohydrates: parseFloat(document.getElementById('edit-carbs').value) || 0,
                    fat: parseFloat(document.getElementById('edit-fat').value) || 0,
                    fiber: parseFloat(document.getElementById('edit-fiber').value) || 0,
                    sugar: parseFloat(document.getElementById('edit-sugar').value) || 0,
                    salt: parseFloat(document.getElementById('edit-salt').value) || 0,
                    // Calculate sodium from salt for database compatibility (sodium mg = salt g * 1000 / 2.5)
                    sodium: Math.round((parseFloat(document.getElementById('edit-salt').value) || 0) * 1000 / 2.5)
                };

                // Also keep nested nutritionData for compatibility
                const foodData = {
                    ...changes,
                    nutritionData: {
                        calories: changes.calories,
                        protein: changes.protein,
                        carbohydrates: changes.carbohydrates,
                        fat: changes.fat,
                        fiber: changes.fiber,
                        sugar: changes.sugar,
                        sodium: changes.sodium,
                        salt: changes.salt
                    }
                };

                try {
                    // Use batchUpdateFoods to update Algolia directly (not Firestore)
                    const response = await fetch(`${CONFIG.API_BASE}/batchUpdateFoods`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            indexName: indexName,
                            updates: [{ objectID: id, changes: changes }],
                            deletes: []
                        })
                    });

                    const result = await response.json();
                    console.log('Save response:', result);

                    if (result.success) {
                        this.showToast('Food saved successfully!', 'success');

                        // Check if food still matches current filter
                        const filter = document.getElementById('quality-filter').value;

                        // Update with ALL fields (including Algolia-compatible field names)
                        const updatedFood = {
                            ...state.editingFood,
                            ...changes  // Apply all the Algolia changes (name, brand, ingredients, calories, etc.)
                        };

                        const stillMatchesFilter = this.foodMatchesFilter(updatedFood, filter);

                        if (!stillMatchesFilter && state.filteredFoods.length > 1) {
                            // Remove from filtered list and advance to next
                            state.filteredFoods.splice(state.editingIndex, 1);
                            // Also remove from main foods list
                            const mainIdx = state.foods.findIndex(f => f.objectID === id);
                            if (mainIdx >= 0) state.foods.splice(mainIdx, 1);

                            // Adjust index if we were at the end
                            if (state.editingIndex >= state.filteredFoods.length) {
                                state.editingIndex = state.filteredFoods.length - 1;
                            }

                            // Load next food or close if none left
                            if (state.filteredFoods.length > 0) {
                                const nextFood = state.filteredFoods[state.editingIndex];
                                state.editingFood = nextFood;
                                this.populateEditForm(nextFood);
                                this.updateNavButtons();
                                this.renderFoods();
                                this.showToast('Fixed! Moved to next food.', 'success');
                            } else {
                                this.closeModal();
                                this.renderFoods();
                            }
                        } else {
                            // Update the food in both lists
                            Object.assign(state.editingFood, updatedFood);
                            this.renderFoods();
                        }
                    } else {
                        console.error('Save failed:', result);
                        this.showToast('Error saving food: ' + (result.error || result.details || 'Unknown error'), 'error');
                    }
                } catch (error) {
                    console.error('Save error:', error);
                    this.showToast('Error saving food: ' + error.message, 'error');
                }
            },

            // Check if food matches current filter
            foodMatchesFilter(food, filter) {
                if (filter === 'all') return true;
                if (filter === 'missing-nutrition') return this.getMissingNutrition(food).length > 0;
                if (filter === 'missing-ingredients') return !this.hasIngredients(food);
                if (filter === 'missing-barcode') return !food.barcode;
                if (filter === 'misspellings') return this.hasMisspelling(food);
                if (filter === 'complete') return this.getMissingNutrition(food).length === 0 && this.hasIngredients(food) && food.barcode;
                return true;
            },

            async deleteFood(id) {
                if (!confirm('Are you sure you want to delete this food?')) return;

                // Get the current index name from the collection filter
                const indexName = document.getElementById('collection-filter').value;

                try {
                    this.showToast('Deleting...', 'info');

                    const response = await fetch(`${CONFIG.API_BASE}/deleteFoodFromAlgolia`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ foodId: id, indexName: indexName })
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.showToast(`Food deleted from ${indexName}!`, 'success');

                        // Remove from local state immediately for instant UI feedback
                        state.foods = state.foods.filter(f => f.objectID !== id);
                        state.filteredFoods = state.filteredFoods.filter(f => f.objectID !== id);
                        state.totalHits = Math.max(0, state.totalHits - 1);
                        this.renderFoods();
                        this.updatePagination();

                        // Also refresh from server after a delay to ensure sync
                        setTimeout(() => {
                            // Reinitialize index to clear any client cache
                            currentIndex = algoliaClient.initIndex(indexName);
                            this.loadFoods(state.currentQuery, state.currentPage);
                        }, 1500);
                    } else {
                        this.showToast('Error deleting food: ' + (result.error || 'Unknown error'), 'error');
                    }
                } catch (error) {
                    console.error('Delete error:', error);
                    this.showToast('Error deleting food. Please try again.', 'error');
                }
            },

            // Reports Functions
            async loadReportsCount() {
                try {
                    const response = await fetch(`${CONFIG.API_BASE}/getUserReports`);
                    const result = await response.json();
                    if (result.success) {
                        const pending = result.reports.filter(r => r.status === 'pending').length;
                        document.getElementById('reports-badge').textContent = pending;
                    }
                } catch (error) {
                    console.error('Error loading reports count:', error);
                }
            },

            async loadReports() {
                const reportsList = document.getElementById('reports-list');
                reportsList.innerHTML = '<div class="loading"><div class="spinner"></div><span>Loading reports...</span></div>';

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/getUserReports`);
                    const result = await response.json();

                    if (result.success) {
                        state.reports = result.reports || [];
                        this.filterReports();
                    } else {
                        reportsList.innerHTML = '<div class="empty-state">Error loading reports.</div>';
                    }
                } catch (error) {
                    console.error('Error loading reports:', error);
                    reportsList.innerHTML = '<div class="empty-state">Error loading reports. Please try again.</div>';
                }
            },

            filterReports() {
                const filter = document.getElementById('report-status-filter').value;
                let filtered = [...state.reports];

                if (filter !== 'all') {
                    filtered = filtered.filter(r => r.status === filter);
                }

                this.renderReports(filtered);
            },

            renderReports(reports) {
                const reportsList = document.getElementById('reports-list');

                if (reports.length === 0) {
                    reportsList.innerHTML = '<div class="empty-state">No reports found.</div>';
                    document.getElementById('select-all-reports').checked = false;
                    this.updateBulkDeleteUI();
                    return;
                }

                const html = reports.map(report => `
                    <div class="report-card" data-id="${report.id}">
                        <div class="report-header">
                            <label class="report-checkbox" onclick="event.stopPropagation()">
                                <input type="checkbox" class="report-select" data-report-id="${report.id}" onchange="app.updateBulkDeleteUI()">
                            </label>
                            <span class="report-title">${this.escapeHtml(report.foodName || 'Unknown Food')}</span>
                            <span class="report-status ${report.status}">${this.formatStatus(report.status)}</span>
                        </div>
                        <div class="report-meta">
                            <span>Type: ${this.escapeHtml(report.reportType || 'General')}</span>
                            <span>Reported: ${this.formatDate(report.createdAt)}</span>
                            ${report.userId ? `<span>User: ${report.userId.substring(0, 8)}...</span>` : ''}
                        </div>
                        <div class="report-description">${this.escapeHtml(report.description || 'No description provided.')}</div>
                        <div class="report-actions">
                            <button class="btn btn-primary" onclick="app.openReportModal('${report.id}')">Review</button>
                            <button class="btn btn-danger btn-sm" onclick="app.deleteReport('${report.id}')">Delete</button>
                        </div>
                    </div>
                `).join('');

                reportsList.innerHTML = html;
                document.getElementById('select-all-reports').checked = false;
                this.updateBulkDeleteUI();
            },

            async updateReportStatus(id, status) {
                try {
                    const response = await fetch(`${CONFIG.API_BASE}/updateUserReport`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ reportId: id, status })
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.showToast('Report updated!', 'success');
                        this.loadReports();
                        this.loadReportsCount();
                    } else {
                        this.showToast('Error updating report', 'error');
                    }
                } catch (error) {
                    console.error('Error updating report:', error);
                    this.showToast('Error updating report', 'error');
                }
            },

            async deleteReport(id) {
                if (!confirm('Are you sure you want to delete this report?')) return;

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/deleteUserReport`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ reportId: id })
                    });

                    const result = await response.json();

                    if (result.success) {
                        this.showToast('Report deleted!', 'success');
                        // Remove from local state instead of reloading
                        state.reports = state.reports.filter(r => r.id !== id);
                        this.renderReports(state.reports);
                        this.loadReportsCount();
                    } else {
                        this.showToast('Error deleting report', 'error');
                    }
                } catch (error) {
                    console.error('Error deleting report:', error);
                    this.showToast('Error deleting report', 'error');
                }
            },

            // Bulk selection functions
            toggleSelectAllReports() {
                const selectAll = document.getElementById('select-all-reports').checked;
                document.querySelectorAll('.report-select').forEach(cb => cb.checked = selectAll);
                this.updateBulkDeleteUI();
            },

            updateBulkDeleteUI() {
                const selected = document.querySelectorAll('.report-select:checked');
                const count = selected.length;
                const countEl = document.getElementById('selected-count');
                const deleteBtn = document.getElementById('bulk-delete-btn');

                if (count > 0) {
                    countEl.style.display = 'inline';
                    countEl.textContent = `${count} selected`;
                    deleteBtn.style.display = 'inline-block';
                } else {
                    countEl.style.display = 'none';
                    deleteBtn.style.display = 'none';
                }

                // Update select all checkbox state
                const total = document.querySelectorAll('.report-select').length;
                const selectAllCb = document.getElementById('select-all-reports');
                selectAllCb.checked = total > 0 && count === total;
                selectAllCb.indeterminate = count > 0 && count < total;
            },

            async bulkDeleteReports() {
                const selected = document.querySelectorAll('.report-select:checked');
                const ids = Array.from(selected).map(cb => cb.dataset.reportId);

                if (ids.length === 0) return;

                if (!confirm(`Delete ${ids.length} report(s)? This cannot be undone.`)) return;

                this.showToast(`Deleting ${ids.length} reports...`, 'info');

                let deleted = 0;
                let failed = 0;

                // Delete in parallel for speed
                await Promise.all(ids.map(async (id) => {
                    try {
                        const response = await fetch(`${CONFIG.API_BASE}/deleteUserReport`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ reportId: id })
                        });
                        const result = await response.json();
                        if (result.success) {
                            deleted++;
                            state.reports = state.reports.filter(r => r.id !== id);
                        } else {
                            failed++;
                        }
                    } catch (e) {
                        failed++;
                    }
                }));

                this.renderReports(state.reports);
                this.loadReportsCount();

                if (failed === 0) {
                    this.showToast(`Deleted ${deleted} reports`, 'success');
                } else {
                    this.showToast(`Deleted ${deleted}, failed ${failed}`, 'error');
                }
            },

            // Report Review Modal Functions
            openReportModal(reportId) {
                const report = state.reports.find(r => r.id === reportId);
                if (!report) return;

                state.reviewingReport = report;
                state.aiSuggestions = null;

                // Populate report details
                const detailsHtml = `
                    <span class="report-type">${this.escapeHtml(report.reportType || 'General')}</span>
                    <p class="report-desc">${this.escapeHtml(report.description || 'No description provided.')}</p>
                `;
                document.getElementById('report-details').innerHTML = detailsHtml;

                // Populate food form with current data
                const food = report.food || {};
                document.getElementById('report-id').value = report.id;
                document.getElementById('report-food-id').value = food.id || food.objectID || report.foodId || '';
                // Determine which Algolia index this food is from
                const foodIndex = food._sourceIndex || food.sourceIndex || report.sourceIndex || 'uk_foods_cleaned';
                document.getElementById('report-food-index').value = foodIndex;
                document.getElementById('report-food-name').value = food.name || report.foodName || '';
                document.getElementById('report-brand-name').value = food.brand || report.brandName || '';
                document.getElementById('report-barcode').value = food.barcode || report.barcode || '';
                document.getElementById('report-serving-size').value = food.servingDescription || food.servingSize || '';
                document.getElementById('report-serving-size-g').value = food.servingSizeG || '';
                document.getElementById('report-serving-unit').value = food.servingUnit || (food.servingSizeG && food.servingDescription && food.servingDescription.toLowerCase().includes('ml') ? 'ml' : 'g');
                document.getElementById('report-category').value = food.category || '';
                document.getElementById('report-ingredients').value = Array.isArray(food.ingredients) ? food.ingredients.join(', ') : (food.ingredients || '');
                document.getElementById('report-calories').value = food.calories || '';
                document.getElementById('report-protein').value = food.protein || '';
                document.getElementById('report-carbs').value = food.carbs || '';
                document.getElementById('report-fat').value = food.fat || '';
                document.getElementById('report-fiber').value = food.fiber || '';
                document.getElementById('report-sugar').value = food.sugar || '';
                document.getElementById('report-salt').value = food.salt || '';
                document.getElementById('report-saturated-fat').value = food.saturatedFat || '';

                // Reset AI state
                document.getElementById('ai-suggestions').style.display = 'none';
                document.getElementById('ai-status').textContent = '';
                document.getElementById('ai-fix-btn').disabled = false;

                // Show modal
                document.getElementById('report-modal').classList.add('active');
            },

            closeReportModal() {
                document.getElementById('report-modal').classList.remove('active');
                state.reviewingReport = null;
                state.aiSuggestions = null;
            },

            async aiAutoFix() {
                const btn = document.getElementById('ai-fix-btn');
                const statusEl = document.getElementById('ai-status');

                btn.disabled = true;
                statusEl.textContent = 'üîÑ Analyzing with AI...';

                try {
                    const food = state.reviewingReport.food || {
                        name: document.getElementById('report-food-name').value,
                        brand: document.getElementById('report-brand-name').value,
                        barcode: document.getElementById('report-barcode').value,
                        calories: parseFloat(document.getElementById('report-calories').value) || 0,
                        protein: parseFloat(document.getElementById('report-protein').value) || 0,
                        carbs: parseFloat(document.getElementById('report-carbs').value) || 0,
                        fat: parseFloat(document.getElementById('report-fat').value) || 0,
                        fiber: parseFloat(document.getElementById('report-fiber').value) || 0,
                        sugar: parseFloat(document.getElementById('report-sugar').value) || 0,
                        salt: parseFloat(document.getElementById('report-salt').value) || 0,
                        sodium: Math.round((parseFloat(document.getElementById('report-salt').value) || 0) * 1000 / 2.5),
                        ingredients: document.getElementById('report-ingredients').value.split(',').map(i => i.trim()).filter(i => i)
                    };

                    const response = await fetch(`${CONFIG.API_BASE}/analyzeAndCleanFoods`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ foods: [food] })
                    });

                    const result = await response.json();

                    if (result.success && result.results && result.results[0]) {
                        state.aiSuggestions = result.results[0];
                        this.showAISuggestions(result.results[0]);
                        statusEl.textContent = '‚úÖ Analysis complete';
                    } else {
                        statusEl.textContent = '‚ö†Ô∏è No suggestions found';
                    }
                } catch (error) {
                    console.error('AI Auto-Fix error:', error);
                    statusEl.textContent = '‚ùå Error analyzing food';
                }

                btn.disabled = false;
            },

            showAISuggestions(result) {
                const container = document.getElementById('ai-suggestions');
                const suggestions = result.suggestions || {};
                const issues = result.issues || [];

                if (Object.keys(suggestions).length === 0 && issues.length === 0) {
                    container.innerHTML = '<h4>‚úÖ AI Analysis</h4><p>No issues found. Food data looks correct.</p>';
                    container.style.display = 'block';
                    return;
                }

                let html = '<h4>ü§ñ AI Suggestions</h4>';

                if (issues.length > 0) {
                    html += '<p style="margin-bottom:12px;color:#92400e;"><strong>Issues found:</strong> ' + issues.join(', ') + '</p>';
                }

                const fields = [
                    { key: 'foodName', label: 'Food Name', inputId: 'report-food-name' },
                    { key: 'brandName', label: 'Brand Name', inputId: 'report-brand-name' },
                    { key: 'barcode', label: 'Barcode', inputId: 'report-barcode' },
                    { key: 'servingSize', label: 'Serving Size', inputId: 'report-serving-size' },
                    { key: 'ingredients', label: 'Ingredients', inputId: 'report-ingredients' }
                ];

                const nutritionFields = [
                    { key: 'calories', label: 'Calories', inputId: 'report-calories' },
                    { key: 'protein', label: 'Protein', inputId: 'report-protein' },
                    { key: 'carbohydrates', label: 'Carbs', inputId: 'report-carbs' },
                    { key: 'fat', label: 'Fat', inputId: 'report-fat' },
                    { key: 'fiber', label: 'Fiber', inputId: 'report-fiber' },
                    { key: 'sugar', label: 'Sugar', inputId: 'report-sugar' },
                    { key: 'salt', label: 'Salt', inputId: 'report-salt' },
                    { key: 'saturatedFat', label: 'Saturated Fat', inputId: 'report-saturated-fat' }
                ];

                // Basic field suggestions
                fields.forEach(field => {
                    if (suggestions[field.key] !== undefined && suggestions[field.key] !== null) {
                        const currentVal = document.getElementById(field.inputId).value;
                        const suggestedVal = Array.isArray(suggestions[field.key]) ? suggestions[field.key].join(', ') : suggestions[field.key];
                        if (currentVal !== suggestedVal) {
                            html += `
                                <div class="ai-suggestion-item">
                                    <span class="suggestion-label">${field.label}</span>
                                    <span class="suggestion-value">
                                        <span class="suggestion-old">${this.escapeHtml(currentVal || '(empty)')}</span>
                                        ‚Üí <span class="suggestion-new">${this.escapeHtml(suggestedVal)}</span>
                                    </span>
                                    <span class="apply-suggestion" onclick="app.applySuggestion('${field.inputId}', '${this.escapeHtml(suggestedVal).replace(/'/g, "\\'")}')">Apply</span>
                                </div>
                            `;
                        }
                    }
                });

                // Nutrition suggestions
                const nutrition = suggestions.nutrition || {};
                nutritionFields.forEach(field => {
                    if (nutrition[field.key] !== undefined && nutrition[field.key] !== null) {
                        const currentVal = document.getElementById(field.inputId).value;
                        const suggestedVal = nutrition[field.key];
                        if (parseFloat(currentVal) !== parseFloat(suggestedVal)) {
                            html += `
                                <div class="ai-suggestion-item">
                                    <span class="suggestion-label">${field.label}</span>
                                    <span class="suggestion-value">
                                        <span class="suggestion-old">${currentVal || '(empty)'}</span>
                                        ‚Üí <span class="suggestion-new">${suggestedVal}</span>
                                    </span>
                                    <span class="apply-suggestion" onclick="app.applySuggestion('${field.inputId}', '${suggestedVal}')">Apply</span>
                                </div>
                            `;
                        }
                    }
                });

                // Apply all button
                html += `
                    <div style="margin-top:12px;text-align:right;">
                        <button class="btn btn-primary" onclick="app.applyAllSuggestions()">Apply All Suggestions</button>
                    </div>
                `;

                container.innerHTML = html;
                container.style.display = 'block';
            },

            applySuggestion(inputId, value) {
                document.getElementById(inputId).value = value;
                this.showToast('Suggestion applied', 'success');
            },

            applyAllSuggestions() {
                if (!state.aiSuggestions) return;

                const suggestions = state.aiSuggestions.suggestions || {};
                const nutrition = suggestions.nutrition || {};

                // Apply basic fields
                if (suggestions.foodName) document.getElementById('report-food-name').value = suggestions.foodName;
                if (suggestions.brandName) document.getElementById('report-brand-name').value = suggestions.brandName;
                if (suggestions.barcode) document.getElementById('report-barcode').value = suggestions.barcode;
                if (suggestions.servingSize) document.getElementById('report-serving-size').value = suggestions.servingSize;
                if (suggestions.ingredients) {
                    const val = Array.isArray(suggestions.ingredients) ? suggestions.ingredients.join(', ') : suggestions.ingredients;
                    document.getElementById('report-ingredients').value = val;
                }

                // Apply nutrition
                if (nutrition.calories !== undefined) document.getElementById('report-calories').value = nutrition.calories;
                if (nutrition.protein !== undefined) document.getElementById('report-protein').value = nutrition.protein;
                if (nutrition.carbohydrates !== undefined) document.getElementById('report-carbs').value = nutrition.carbohydrates;
                if (nutrition.fat !== undefined) document.getElementById('report-fat').value = nutrition.fat;
                if (nutrition.fiber !== undefined) document.getElementById('report-fiber').value = nutrition.fiber;
                if (nutrition.sugar !== undefined) document.getElementById('report-sugar').value = nutrition.sugar;
                if (nutrition.salt !== undefined) document.getElementById('report-salt').value = nutrition.salt;
                if (nutrition.saturatedFat !== undefined) document.getElementById('report-saturated-fat').value = nutrition.saturatedFat;

                this.showToast('All suggestions applied!', 'success');
            },

            searchGoogle() {
                const name = document.getElementById('report-food-name').value;
                const brand = document.getElementById('report-brand-name').value;
                const query = `${name} ${brand} nutrition facts UK`.trim();
                window.open(`https://www.google.com/search?q=${encodeURIComponent(query)}`, '_blank');
            },

            // Helper to get food data from form
            _getFoodDataFromForm() {
                const foodId = document.getElementById('report-food-id').value;
                const ingredientsRaw = document.getElementById('report-ingredients').value;
                const ingredients = ingredientsRaw ? ingredientsRaw.split(',').map(i => i.trim()).filter(i => i) : [];
                const foodIndex = document.getElementById('report-food-index').value;

                return {
                    foodId: foodId,
                    collection: foodIndex,
                    foodName: document.getElementById('report-food-name').value,
                    brandName: document.getElementById('report-brand-name').value,
                    barcode: document.getElementById('report-barcode').value,
                    servingSize: document.getElementById('report-serving-size').value,
                    servingSizeG: parseFloat(document.getElementById('report-serving-size-g').value) || null,
                    servingUnit: document.getElementById('report-serving-unit').value || 'g',
                    category: document.getElementById('report-category').value,
                    extractedIngredients: ingredients,
                    nutritionData: {
                        calories: parseFloat(document.getElementById('report-calories').value) || null,
                        protein: parseFloat(document.getElementById('report-protein').value) || null,
                        carbs: parseFloat(document.getElementById('report-carbs').value) || null,
                        fat: parseFloat(document.getElementById('report-fat').value) || null,
                        fiber: parseFloat(document.getElementById('report-fiber').value) || null,
                        sugar: parseFloat(document.getElementById('report-sugar').value) || null,
                        salt: parseFloat(document.getElementById('report-salt').value) || null,
                        sodium: Math.round((parseFloat(document.getElementById('report-salt').value) || 0) * 1000 / 2.5) || null,
                        saturatedFat: parseFloat(document.getElementById('report-saturated-fat').value) || null
                    }
                };
            },

            // Save food without resolving report (keeps modal open for further edits)
            async saveOnly() {
                const foodData = this._getFoodDataFromForm();

                if (!foodData.foodId) {
                    this.showToast('No food ID found', 'error');
                    return;
                }

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/updateVerifiedFood`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(foodData)
                    });

                    const result = await response.json();
                    if (result.success) {
                        this.showToast('Food saved! Report still open for further edits.', 'success');
                        // Update local report data with saved food info
                        if (state.reviewingReport) {
                            state.reviewingReport.food = {
                                ...state.reviewingReport.food,
                                name: foodData.foodName,
                                brand: foodData.brandName,
                                barcode: foodData.barcode,
                                servingDescription: foodData.servingSize,
                                servingSizeG: foodData.servingSizeG,
                                servingUnit: foodData.servingUnit,
                                ingredients: foodData.extractedIngredients,
                                calories: foodData.nutritionData.calories,
                                protein: foodData.nutritionData.protein,
                                carbs: foodData.nutritionData.carbs,
                                fat: foodData.nutritionData.fat,
                                fiber: foodData.nutritionData.fiber,
                                sugar: foodData.nutritionData.sugar,
                                salt: foodData.nutritionData.salt,
                                saturatedFat: foodData.nutritionData.saturatedFat
                            };
                        }
                    } else {
                        this.showToast('Error saving: ' + (result.error || 'Unknown error'), 'error');
                    }
                } catch (error) {
                    console.error('Save error:', error);
                    this.showToast('Error saving changes', 'error');
                }
            },

            async saveAndResolve() {
                const foodData = this._getFoodDataFromForm();
                const reportId = document.getElementById('report-id').value;

                if (!foodData.foodId) {
                    this.showToast('No food ID found', 'error');
                    return;
                }

                try {
                    // 1. Save food changes
                    const foodResponse = await fetch(`${CONFIG.API_BASE}/updateVerifiedFood`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(foodData)
                    });

                    const foodResult = await foodResponse.json();
                    if (!foodResult.success) {
                        this.showToast('Error saving food: ' + (foodResult.error || 'Unknown error'), 'error');
                        return;
                    }

                    // 2. Mark report as resolved
                    const reportResponse = await fetch(`${CONFIG.API_BASE}/updateUserReport`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ reportId: reportId, status: 'resolved' })
                    });

                    const reportResult = await reportResponse.json();
                    if (reportResult.success) {
                        this.showToast('Resolved!', 'success');
                        this.closeReportModal();
                        // Update local state instead of full reload
                        state.reports = state.reports.filter(r => r.id !== reportId);
                        this.renderReports(state.reports);
                        this.loadReportsCount();
                    } else {
                        this.showToast('Food saved but failed to update report status', 'error');
                    }
                } catch (error) {
                    console.error('Save and resolve error:', error);
                    this.showToast('Error saving changes', 'error');
                }
            },

            async dismissReport() {
                if (!confirm('Dismiss this report without making changes?')) return;

                const reportId = document.getElementById('report-id').value;

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/updateUserReport`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ reportId: reportId, status: 'dismissed' })
                    });

                    const result = await response.json();
                    if (result.success) {
                        this.showToast('Report dismissed', 'success');
                        this.closeReportModal();
                        this.loadReports();
                        this.loadReportsCount();
                    } else {
                        this.showToast('Error dismissing report', 'error');
                    }
                } catch (error) {
                    console.error('Dismiss error:', error);
                    this.showToast('Error dismissing report', 'error');
                }
            },

            async deleteReportedFood() {
                const foodId = document.getElementById('report-food-id').value;
                const reportId = document.getElementById('report-id').value;
                const foodName = document.getElementById('report-food-name').value;
                const indexName = document.getElementById('report-food-index').value || 'uk_foods_cleaned';

                if (!foodId) {
                    this.showToast('No food ID found', 'error');
                    return;
                }

                if (!confirm(`Are you sure you want to DELETE "${foodName}" from the database? This cannot be undone.`)) return;

                try {
                    this.showToast('Deleting food...', 'info');

                    // 1. Delete the food from Algolia (and Firestore if applicable)
                    const foodResponse = await fetch(`${CONFIG.API_BASE}/deleteFoodFromAlgolia`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ foodId: foodId, indexName: indexName })
                    });

                    const foodResult = await foodResponse.json();
                    if (!foodResult.success) {
                        this.showToast('Error deleting food: ' + (foodResult.error || 'Unknown error'), 'error');
                        return;
                    }

                    // 2. Mark report as resolved
                    await fetch(`${CONFIG.API_BASE}/updateUserReport`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ reportId: reportId, status: 'resolved' })
                    });

                    this.showToast(`Food deleted and report resolved!`, 'success');
                    this.closeReportModal();

                    // Remove from local state immediately for instant UI feedback
                    state.reports = state.reports.filter(r => r.id !== reportId);
                    this.renderReports(state.reports);
                    this.loadReportsCount();

                    // Refresh from server after delay
                    setTimeout(() => this.loadReports(), 1500);
                } catch (error) {
                    console.error('Delete food error:', error);
                    this.showToast('Error deleting food', 'error');
                }
            },

            // Utility Functions
            showToast(message, type = 'info') {
                // Add to activity log (primary display)
                this.addToActivityLog(message, type);

                // Also show toast for important messages (errors and warnings)
                if (type === 'error' || type === 'warning') {
                    const container = document.getElementById('toast-container');
                    const toast = document.createElement('div');
                    toast.className = `toast ${type}`;
                    toast.textContent = message;
                    container.appendChild(toast);
                    setTimeout(() => toast.remove(), 3000);
                }
            },

            // Add entry to activity log
            addToActivityLog(message, type = 'info') {
                const container = document.getElementById('activity-log-content');
                if (!container) return;

                // Remove empty message if present
                const emptyMsg = container.querySelector('.activity-log-empty');
                if (emptyMsg) emptyMsg.remove();

                // Icons by type
                const icons = {
                    success: '‚úì',
                    error: '‚úó',
                    warning: '‚ö†',
                    info: '‚Ñπ'
                };

                // Create entry
                const entry = document.createElement('div');
                entry.className = `activity-log-entry ${type}`;

                const now = new Date();
                const time = now.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

                entry.innerHTML = `
                    <span class="activity-log-time">${time}</span>
                    <span class="activity-log-icon">${icons[type] || '‚Ñπ'}</span>
                    <span class="activity-log-message">${this.escapeHtml(message)}</span>
                `;

                // Add to top
                container.insertBefore(entry, container.firstChild);

                // Keep max 100 entries
                while (container.children.length > 100) {
                    container.lastChild.remove();
                }
            },

            // Clear activity log
            clearActivityLog() {
                const container = document.getElementById('activity-log-content');
                if (container) {
                    container.innerHTML = '<div class="activity-log-empty">No activity yet. Start a scan or perform actions to see logs here.</div>';
                }
            },

            escapeHtml(str) {
                if (!str) return '';
                return String(str).replace(/[&<>"']/g, (m) => ({
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
                }[m]));
            },

            formatDate(timestamp) {
                if (!timestamp) return 'Unknown';
                const date = timestamp._seconds ? new Date(timestamp._seconds * 1000) : new Date(timestamp);
                return date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: 'numeric' });
            },

            formatStatus(status) {
                return status ? status.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase()) : 'Unknown';
            },

            // ========================
            // Database Check Functions
            // ========================

            async startDatabaseScan() {
                const indexName = document.getElementById('scan-index').value;
                state.scanInProgress = true;
                state.currentScanIndex = indexName;
                state.pendingEdits = {};
                state.pendingDeletes = new Set();

                // Show progress UI
                document.getElementById('scan-empty').style.display = 'none';
                document.getElementById('scan-progress').style.display = 'block';
                document.getElementById('scan-results').style.display = 'none';
                document.getElementById('start-scan-btn').disabled = true;
                document.getElementById('progress-text').textContent = 'Scanning database... This may take a few minutes.';
                document.getElementById('progress-fill').style.width = '10%';

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/scanDatabaseIssues`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ indexName })
                    });

                    const result = await response.json();
                    console.log('Scan response:', {
                        success: result.success,
                        totalScanned: result.totalScanned,
                        issuesFound: result.issuesFound,
                        foodsLength: result.foods?.length,
                        error: result.error
                    });

                    if (result.success) {
                        state.scanResults = result.foods || [];
                        state.filteredScanResults = result.foods || [];
                        state.currentIssueFilter = 'all';
                        document.getElementById('progress-fill').style.width = '100%';
                        document.getElementById('progress-text').textContent = `Scan complete! Found ${result.foods?.length || 0} issues.`;

                        setTimeout(() => {
                            this.showScanResults(result);
                        }, 500);
                    } else {
                        this.showToast('Scan failed: ' + (result.error || 'Unknown error'), 'error');
                        document.getElementById('scan-progress').style.display = 'none';
                        document.getElementById('scan-empty').style.display = 'block';
                    }
                } catch (error) {
                    console.error('Scan error:', error);
                    this.showToast('Scan failed: ' + error.message, 'error');
                    document.getElementById('scan-progress').style.display = 'none';
                    document.getElementById('scan-empty').style.display = 'block';
                }

                state.scanInProgress = false;
                document.getElementById('start-scan-btn').disabled = false;
            },

            showScanResults(result) {
                document.getElementById('scan-progress').style.display = 'none';
                document.getElementById('scan-results').style.display = 'block';

                // Detect duplicates first (needed for ledger)
                this.detectDuplicates();

                // Reset filter buttons and tabs
                document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                const filterAllBtn = document.querySelector('[data-issue-filter="all"]');
                if (filterAllBtn) filterAllBtn.classList.add('active');

                // Reset ledger tabs to "All"
                state.currentLedgerFilter = 'all';
                document.querySelectorAll('.issue-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.status === 'all');
                });

                // Reset pagination and selection
                state.issuesCurrentPage = 0;
                state.selectedItems = new Set();
                this.updateSelectionUI();

                // Save session for persistence (this also creates the ledger and updates UI)
                this.saveCurrentSession(state.currentScanIndex, result.foods, result.totalScanned);

                this.renderIssuesList();
                this.updatePendingStatus();
            },

            // ============================================================
            // ADVANCED DUPLICATE DETECTION ENGINE
            // Multi-strategy approach: barcode, exact match, fuzzy, tokens
            // ============================================================

            // Levenshtein distance for fuzzy string matching
            levenshteinDistance(str1, str2) {
                const m = str1.length;
                const n = str2.length;

                // Quick checks
                if (m === 0) return n;
                if (n === 0) return m;
                if (str1 === str2) return 0;

                // Create distance matrix
                const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

                for (let i = 0; i <= m; i++) dp[i][0] = i;
                for (let j = 0; j <= n; j++) dp[0][j] = j;

                for (let i = 1; i <= m; i++) {
                    for (let j = 1; j <= n; j++) {
                        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                        dp[i][j] = Math.min(
                            dp[i - 1][j] + 1,      // deletion
                            dp[i][j - 1] + 1,      // insertion
                            dp[i - 1][j - 1] + cost // substitution
                        );
                    }
                }

                return dp[m][n];
            },

            // Similarity score (0-1, higher is more similar)
            stringSimilarity(str1, str2) {
                if (!str1 || !str2) return 0;
                const maxLen = Math.max(str1.length, str2.length);
                if (maxLen === 0) return 1;
                const distance = this.levenshteinDistance(str1, str2);
                return 1 - (distance / maxLen);
            },

            // Normalize a name for comparison
            normalizeName(name) {
                if (!name) return '';
                return name
                    .toLowerCase()
                    .trim()
                    .replace(/[''`]/g, "'")           // Normalize apostrophes
                    .replace(/[""]/g, '"')            // Normalize quotes
                    .replace(/&/g, 'and')             // & -> and
                    .replace(/\+/g, 'and')            // + -> and
                    .replace(/[^\w\s'-]/g, ' ')       // Remove special chars (keep apostrophe, hyphen)
                    .replace(/\s+/g, ' ')             // Collapse spaces
                    .trim();
            },

            // Extract tokens from a name (for token-based matching)
            extractTokens(name) {
                const normalized = this.normalizeName(name);
                // Split on spaces/hyphens, filter short words
                return normalized
                    .split(/[\s-]+/)
                    .filter(t => t.length >= 2)
                    .sort(); // Sort for consistent fingerprinting
            },

            // Create a fingerprint from tokens (order-independent)
            tokenFingerprint(name) {
                return this.extractTokens(name).join('|');
            },

            // Calculate Jaccard similarity between two token sets
            tokenSimilarity(tokens1, tokens2) {
                if (!tokens1.length || !tokens2.length) return 0;
                const set1 = new Set(tokens1);
                const set2 = new Set(tokens2);
                const intersection = [...set1].filter(t => set2.has(t)).length;
                const union = new Set([...set1, ...set2]).size;
                return intersection / union;
            },

            // Create brand+name fingerprint
            brandNameFingerprint(food) {
                const brand = this.normalizeName(food.brandName || food.brand || '');
                const name = this.normalizeName(food.foodName || food.name || '');
                // Remove brand from name if it's already there
                const nameWithoutBrand = name.replace(new RegExp(brand.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'), '').trim();
                return `${brand}::${nameWithoutBrand}`.toLowerCase();
            },

            // Remove size/weight info for comparison (500g, 1kg, 250ml, etc.)
            stripSizeInfo(name) {
                return name
                    .replace(/\d+\s*(g|kg|ml|l|oz|lb|lbs|gram|grams|litre|litres|liter|liters)\b/gi, '')
                    .replace(/\s+/g, ' ')
                    .trim();
            },

            // Advanced duplicate detection - finds all types of duplicates
            detectDuplicates() {
                state.duplicateGroups = [];
                state.duplicatesMap = new Map();

                const foods = state.scanResults;
                if (!foods || foods.length === 0) return;

                console.log(`üîç Starting advanced duplicate detection on ${foods.length} items...`);

                // Strategy 1: Exact barcode matches (highest confidence)
                const barcodeMap = new Map();
                for (const food of foods) {
                    if (food.barcode && food.barcode.length >= 8) {
                        const barcode = food.barcode.trim();
                        if (!barcodeMap.has(barcode)) {
                            barcodeMap.set(barcode, []);
                        }
                        barcodeMap.get(barcode).push(food.objectID);
                    }
                }

                for (const [barcode, ids] of barcodeMap) {
                    if (ids.length > 1) {
                        state.duplicateGroups.push({
                            type: 'barcode',
                            matchType: 'exact',
                            confidence: 100,
                            value: barcode,
                            objectIDs: ids
                        });
                        ids.forEach(id => state.duplicatesMap.set(id, {
                            type: 'barcode',
                            matchType: 'exact',
                            confidence: 100,
                            value: barcode
                        }));
                    }
                }

                console.log(`   üìä Found ${barcodeMap.size} unique barcodes, ${state.duplicateGroups.length} duplicate groups`);

                // Strategy 2: Exact normalized name matches
                const nameMap = new Map();
                for (const food of foods) {
                    const normalized = this.normalizeName(food.foodName || food.name || '');
                    if (normalized.length >= 4) {
                        if (!nameMap.has(normalized)) {
                            nameMap.set(normalized, []);
                        }
                        nameMap.get(normalized).push(food.objectID);
                    }
                }

                for (const [name, ids] of nameMap) {
                    if (ids.length > 1) {
                        const newIds = ids.filter(id => !state.duplicatesMap.has(id));
                        if (newIds.length >= 1 && ids.length > 1) {
                            state.duplicateGroups.push({
                                type: 'name',
                                matchType: 'exact',
                                confidence: 95,
                                value: name,
                                objectIDs: ids
                            });
                            ids.forEach(id => {
                                if (!state.duplicatesMap.has(id)) {
                                    state.duplicatesMap.set(id, {
                                        type: 'name',
                                        matchType: 'exact',
                                        confidence: 95,
                                        value: name
                                    });
                                }
                            });
                        }
                    }
                }

                // Strategy 3: Brand+Name fingerprint matches
                const brandNameMap = new Map();
                for (const food of foods) {
                    if (state.duplicatesMap.has(food.objectID)) continue; // Skip already found
                    const fingerprint = this.brandNameFingerprint(food);
                    if (fingerprint.length >= 6 && fingerprint !== '::') {
                        if (!brandNameMap.has(fingerprint)) {
                            brandNameMap.set(fingerprint, []);
                        }
                        brandNameMap.get(fingerprint).push(food.objectID);
                    }
                }

                for (const [fingerprint, ids] of brandNameMap) {
                    if (ids.length > 1) {
                        state.duplicateGroups.push({
                            type: 'brand_name',
                            matchType: 'exact',
                            confidence: 90,
                            value: fingerprint,
                            objectIDs: ids
                        });
                        ids.forEach(id => {
                            if (!state.duplicatesMap.has(id)) {
                                state.duplicatesMap.set(id, {
                                    type: 'brand_name',
                                    matchType: 'exact',
                                    confidence: 90,
                                    value: fingerprint
                                });
                            }
                        });
                    }
                }

                // Strategy 4: Token-based matching (same words, any order)
                const tokenMap = new Map();
                for (const food of foods) {
                    if (state.duplicatesMap.has(food.objectID)) continue;
                    const fingerprint = this.tokenFingerprint(food.foodName || food.name || '');
                    if (fingerprint.split('|').length >= 2) { // At least 2 tokens
                        if (!tokenMap.has(fingerprint)) {
                            tokenMap.set(fingerprint, []);
                        }
                        tokenMap.get(fingerprint).push(food.objectID);
                    }
                }

                for (const [fingerprint, ids] of tokenMap) {
                    if (ids.length > 1) {
                        state.duplicateGroups.push({
                            type: 'tokens',
                            matchType: 'reordered',
                            confidence: 85,
                            value: fingerprint,
                            objectIDs: ids
                        });
                        ids.forEach(id => {
                            if (!state.duplicatesMap.has(id)) {
                                state.duplicatesMap.set(id, {
                                    type: 'tokens',
                                    matchType: 'reordered',
                                    confidence: 85,
                                    value: fingerprint
                                });
                            }
                        });
                    }
                }

                // Strategy 5: Size-stripped matching (ignore weight/volume)
                const strippedMap = new Map();
                for (const food of foods) {
                    if (state.duplicatesMap.has(food.objectID)) continue;
                    const name = this.normalizeName(food.foodName || food.name || '');
                    const stripped = this.stripSizeInfo(name);
                    if (stripped.length >= 6 && stripped !== name) { // Only if size was actually stripped
                        if (!strippedMap.has(stripped)) {
                            strippedMap.set(stripped, []);
                        }
                        strippedMap.get(stripped).push(food.objectID);
                    }
                }

                for (const [stripped, ids] of strippedMap) {
                    if (ids.length > 1) {
                        state.duplicateGroups.push({
                            type: 'size_variant',
                            matchType: 'size_stripped',
                            confidence: 80,
                            value: stripped,
                            objectIDs: ids
                        });
                        ids.forEach(id => {
                            if (!state.duplicatesMap.has(id)) {
                                state.duplicatesMap.set(id, {
                                    type: 'size_variant',
                                    matchType: 'size_stripped',
                                    confidence: 80,
                                    value: stripped
                                });
                            }
                        });
                    }
                }

                // Strategy 6: Fuzzy matching (computationally expensive - limited scope)
                // Only compare items not yet matched and with similar lengths
                const unmatchedFoods = foods.filter(f => !state.duplicatesMap.has(f.objectID));
                const FUZZY_THRESHOLD = 0.85; // 85% similarity required
                const MAX_FUZZY_COMPARISONS = 50000; // Limit to prevent browser freeze
                let comparisons = 0;

                const fuzzyGroups = [];
                const fuzzyMatched = new Set();

                for (let i = 0; i < unmatchedFoods.length && comparisons < MAX_FUZZY_COMPARISONS; i++) {
                    if (fuzzyMatched.has(unmatchedFoods[i].objectID)) continue;

                    const food1 = unmatchedFoods[i];
                    const name1 = this.normalizeName(food1.foodName || food1.name || '');
                    if (name1.length < 6) continue;

                    const group = [food1.objectID];

                    for (let j = i + 1; j < unmatchedFoods.length && comparisons < MAX_FUZZY_COMPARISONS; j++) {
                        if (fuzzyMatched.has(unmatchedFoods[j].objectID)) continue;

                        const food2 = unmatchedFoods[j];
                        const name2 = this.normalizeName(food2.foodName || food2.name || '');

                        // Skip if lengths are too different (optimization)
                        if (Math.abs(name1.length - name2.length) > 5) continue;

                        comparisons++;
                        const similarity = this.stringSimilarity(name1, name2);

                        if (similarity >= FUZZY_THRESHOLD) {
                            group.push(food2.objectID);
                            fuzzyMatched.add(food2.objectID);
                        }
                    }

                    if (group.length > 1) {
                        fuzzyMatched.add(food1.objectID);
                        fuzzyGroups.push({
                            type: 'fuzzy',
                            matchType: 'similar',
                            confidence: 75,
                            value: name1,
                            objectIDs: group
                        });
                    }
                }

                // Add fuzzy groups to results
                for (const group of fuzzyGroups) {
                    state.duplicateGroups.push(group);
                    group.objectIDs.forEach(id => {
                        if (!state.duplicatesMap.has(id)) {
                            state.duplicatesMap.set(id, {
                                type: 'fuzzy',
                                matchType: 'similar',
                                confidence: 75,
                                value: group.value
                            });
                        }
                    });
                }

                // Sort groups by confidence (highest first), then by size (largest first)
                state.duplicateGroups.sort((a, b) => {
                    if (b.confidence !== a.confidence) return b.confidence - a.confidence;
                    return b.objectIDs.length - a.objectIDs.length;
                });

                // Summary
                const stats = {
                    barcode: state.duplicateGroups.filter(g => g.type === 'barcode').length,
                    exactName: state.duplicateGroups.filter(g => g.type === 'name').length,
                    brandName: state.duplicateGroups.filter(g => g.type === 'brand_name').length,
                    tokens: state.duplicateGroups.filter(g => g.type === 'tokens').length,
                    sizeVariant: state.duplicateGroups.filter(g => g.type === 'size_variant').length,
                    fuzzy: state.duplicateGroups.filter(g => g.type === 'fuzzy').length
                };

                console.log(`üéØ Advanced duplicate detection complete:`);
                console.log(`   üìä ${state.duplicateGroups.length} total duplicate groups found`);
                console.log(`   üìä ${state.duplicatesMap.size} total items are duplicates`);
                console.log(`   üè∑Ô∏è  Barcode matches: ${stats.barcode}`);
                console.log(`   üìù Exact name matches: ${stats.exactName}`);
                console.log(`   üè™ Brand+name matches: ${stats.brandName}`);
                console.log(`   üî§ Token matches: ${stats.tokens}`);
                console.log(`   üìè Size variant matches: ${stats.sizeVariant}`);
                console.log(`   üîç Fuzzy matches: ${stats.fuzzy}`);
                console.log(`   ‚ö° Fuzzy comparisons made: ${comparisons}`);

                // Update duplicates panel if visible
                this.updateDuplicatesPanel();
            },

            // =====================
            // Duplicate Groups Panel Management
            // =====================

            toggleDuplicateGroupsPanel() {
                const panel = document.getElementById('duplicate-groups-panel');
                if (panel.style.display === 'none') {
                    panel.style.display = 'block';
                    state.duplicateGroupFilter = 'all';
                    this.renderDuplicateGroups();
                } else {
                    panel.style.display = 'none';
                }
            },

            updateDuplicatesPanel() {
                const panel = document.getElementById('duplicate-groups-panel');
                if (panel && panel.style.display !== 'none') {
                    this.renderDuplicateGroups();
                }
                // Update count badge anywhere it appears
                const totalGroups = state.duplicateGroups?.length || 0;
                const totalItems = state.duplicatesMap?.size || 0;
                const countEl = document.getElementById('dup-groups-count');
                if (countEl) {
                    countEl.textContent = `(${totalGroups} groups, ${totalItems} items)`;
                }
                // Update button badge
                const btnCountEl = document.getElementById('dup-btn-count');
                if (btnCountEl) {
                    btnCountEl.textContent = totalGroups;
                    btnCountEl.style.display = totalGroups > 0 ? 'inline' : 'none';
                }
            },

            filterDuplicateGroups(type) {
                state.duplicateGroupFilter = type;
                this.renderDuplicateGroups();
            },

            renderDuplicateGroups() {
                const container = document.getElementById('dup-groups-list');
                if (!container) return;

                const filter = state.duplicateGroupFilter || 'all';
                let groups = state.duplicateGroups || [];

                // Filter by type
                if (filter !== 'all') {
                    groups = groups.filter(g => g.type === filter);
                }

                if (groups.length === 0) {
                    container.innerHTML = `
                        <div style="padding: 24px; text-align: center; color: var(--text-secondary);">
                            ${filter === 'all' ? 'No duplicates detected.' : `No ${filter} duplicates found.`}
                        </div>
                    `;
                    return;
                }

                // Build HTML for groups
                const html = groups.map((group, idx) => {
                    const typeLabels = {
                        'barcode': 'üè∑Ô∏è Barcode Match',
                        'name': 'üìù Exact Name',
                        'brand_name': 'üè™ Brand+Name',
                        'tokens': 'üî§ Same Words',
                        'size_variant': 'üìè Size Variant',
                        'fuzzy': 'üîç Fuzzy Match'
                    };
                    const typeLabel = typeLabels[group.type] || group.type;

                    // Get food items for this group
                    const items = group.objectIDs.map(id => {
                        const food = state.scanResults.find(f => f.objectID === id);
                        return food || { objectID: id, foodName: 'Unknown', brandName: '' };
                    });

                    // First item is canonical (to keep)
                    const itemsHtml = items.map((item, itemIdx) => {
                        const isCanonical = itemIdx === 0;
                        const name = item.foodName || item.name || 'Unknown';
                        const brand = item.brandName || item.brand || '';
                        const barcode = item.barcode || '';
                        const isMarkedDelete = state.pendingDeletes.has(item.objectID);

                        return `
                            <div class="dup-item ${isCanonical ? 'canonical' : ''} ${isMarkedDelete ? 'marked-delete' : ''}">
                                <span class="dup-item-name" title="${this.escapeHtml(name)}">
                                    ${isCanonical ? '‚úì ' : ''}${this.escapeHtml(name)}
                                </span>
                                <span class="dup-item-meta">${this.escapeHtml(brand)}${barcode ? ` | ${barcode}` : ''}</span>
                                <div class="dup-item-actions">
                                    ${!isCanonical ? `
                                        <button class="dup-item-btn keep" onclick="event.stopPropagation(); app.keepDuplicateItem(${idx}, '${item.objectID}')" title="Keep this, delete others">Keep</button>
                                    ` : ''}
                                    <button class="dup-item-btn delete" onclick="event.stopPropagation(); app.deleteDuplicateItem('${item.objectID}')" title="${isMarkedDelete ? 'Undo delete' : 'Delete this item'}">${isMarkedDelete ? 'Undo' : 'Delete'}</button>
                                </div>
                            </div>
                        `;
                    }).join('');

                    // Truncate value for display
                    const displayValue = group.value.length > 50 ? group.value.substring(0, 50) + '...' : group.value;

                    return `
                        <div class="dup-group" data-group-index="${idx}">
                            <div class="dup-group-header">
                                <div class="dup-group-title">
                                    <span class="dup-type-badge">${typeLabel} (${group.confidence}%)</span>
                                    <span title="${this.escapeHtml(group.value)}">${this.escapeHtml(displayValue)}</span>
                                </div>
                                <div class="dup-group-actions">
                                    <button class="dup-item-btn keep" onclick="app.keepFirstInGroup(${idx})" title="Keep first, delete rest">Keep First</button>
                                    <button class="dup-item-btn" onclick="app.skipDuplicateGroup(${idx})" title="Skip this group">Skip</button>
                                </div>
                            </div>
                            <div class="dup-group-items">
                                ${itemsHtml}
                            </div>
                        </div>
                    `;
                }).join('');

                container.innerHTML = html;

                // Update count
                const countEl = document.getElementById('dup-groups-count');
                if (countEl) {
                    const totalItems = groups.reduce((sum, g) => sum + g.objectIDs.length, 0);
                    countEl.textContent = `(${groups.length} groups, ${totalItems} items)`;
                }
            },

            keepDuplicateItem(groupIndex, keepObjectID) {
                const group = state.duplicateGroups[groupIndex];
                if (!group) return;

                // Delete all items in group except the one to keep
                group.objectIDs.forEach(id => {
                    if (id !== keepObjectID) {
                        state.pendingDeletes.add(id);
                    }
                });

                this.updatePendingStatus();
                this.renderDuplicateGroups();
                this.renderIssuesList();
                this.showToast(`Marked ${group.objectIDs.length - 1} duplicates for deletion`, 'success');
            },

            deleteDuplicateItem(objectID) {
                if (state.pendingDeletes.has(objectID)) {
                    state.pendingDeletes.delete(objectID);
                } else {
                    state.pendingDeletes.add(objectID);
                }
                this.updatePendingStatus();
                this.renderDuplicateGroups();
                this.renderIssuesList();
            },

            keepFirstInGroup(groupIndex) {
                const group = state.duplicateGroups[groupIndex];
                if (!group || group.objectIDs.length < 2) return;

                // Keep first (canonical), delete rest
                const toDelete = group.objectIDs.slice(1);
                toDelete.forEach(id => state.pendingDeletes.add(id));

                this.updatePendingStatus();
                this.renderDuplicateGroups();
                this.renderIssuesList();
                this.showToast(`Marked ${toDelete.length} duplicates for deletion`, 'success');
            },

            skipDuplicateGroup(groupIndex) {
                const group = state.duplicateGroups[groupIndex];
                if (!group) return;

                // Mark all items in group as skipped in ledger
                group.objectIDs.forEach(id => {
                    this.skipIssue(id, 'Skipped as part of duplicate group');
                });

                // Remove from duplicateGroups and duplicatesMap
                state.duplicateGroups.splice(groupIndex, 1);
                group.objectIDs.forEach(id => state.duplicatesMap.delete(id));

                this.updatePendingStatus();
                this.renderDuplicateGroups();
                this.renderIssuesList();
                this.showToast('Duplicate group skipped', 'info');
            },

            keepAllFirstDuplicates() {
                if (!confirm(`Keep the first item in each of ${state.duplicateGroups.length} duplicate groups and mark the rest for deletion?`)) return;

                let deleteCount = 0;
                state.duplicateGroups.forEach(group => {
                    if (group.objectIDs.length >= 2) {
                        const toDelete = group.objectIDs.slice(1);
                        toDelete.forEach(id => state.pendingDeletes.add(id));
                        deleteCount += toDelete.length;
                    }
                });

                this.updatePendingStatus();
                this.renderDuplicateGroups();
                this.renderIssuesList();
                this.showToast(`Marked ${deleteCount} duplicates for deletion`, 'success');
            },

            deleteAllDuplicates() {
                const totalItems = state.duplicatesMap.size;
                if (!confirm(`Mark ALL ${totalItems} duplicate items for deletion? This includes the canonical items.`)) return;

                state.duplicatesMap.forEach((_, id) => {
                    state.pendingDeletes.add(id);
                });

                this.updatePendingStatus();
                this.renderDuplicateGroups();
                this.renderIssuesList();
                this.showToast(`Marked ${totalItems} items for deletion`, 'warning');
            },

            skipAllDuplicateGroups() {
                if (!confirm(`Skip all ${state.duplicateGroups.length} duplicate groups?`)) return;

                state.duplicateGroups.forEach(group => {
                    group.objectIDs.forEach(id => {
                        this.skipIssue(id, 'Skipped as part of duplicate group');
                        state.duplicatesMap.delete(id);
                    });
                });

                state.duplicateGroups = [];

                this.updatePendingStatus();
                this.renderDuplicateGroups();
                this.renderIssuesList();
                this.showToast('All duplicate groups skipped', 'info');
            },

            filterByIssueType(type) {
                state.currentIssueFilter = type;
                state.issuesCurrentPage = 0; // Reset to first page on filter change

                // Update filter dropdown
                const filterSelect = document.getElementById('issue-filter-select');
                if (filterSelect) filterSelect.value = type;

                if (type === 'all') {
                    state.filteredScanResults = state.scanResults;
                } else if (type === 'multiple') {
                    state.filteredScanResults = state.scanResults.filter(f => f.issues.length > 1);
                } else if (type === 'duplicates') {
                    // Show ALL foods that are duplicates
                    state.filteredScanResults = state.scanResults.filter(f => state.duplicatesMap.has(f.objectID));
                } else if (type === 'dup-barcode') {
                    // Show only barcode duplicates
                    state.filteredScanResults = state.scanResults.filter(f => {
                        const dup = state.duplicatesMap.get(f.objectID);
                        return dup && dup.type === 'barcode';
                    });
                } else if (type === 'dup-name') {
                    // Show only exact name duplicates
                    state.filteredScanResults = state.scanResults.filter(f => {
                        const dup = state.duplicatesMap.get(f.objectID);
                        return dup && dup.type === 'name';
                    });
                } else if (type === 'dup-brand') {
                    // Show only brand+name duplicates
                    state.filteredScanResults = state.scanResults.filter(f => {
                        const dup = state.duplicatesMap.get(f.objectID);
                        return dup && dup.type === 'brand_name';
                    });
                } else if (type === 'dup-tokens') {
                    // Show only token/word duplicates
                    state.filteredScanResults = state.scanResults.filter(f => {
                        const dup = state.duplicatesMap.get(f.objectID);
                        return dup && dup.type === 'tokens';
                    });
                } else if (type === 'dup-size') {
                    // Show only size variant duplicates
                    state.filteredScanResults = state.scanResults.filter(f => {
                        const dup = state.duplicatesMap.get(f.objectID);
                        return dup && dup.type === 'size_variant';
                    });
                } else if (type === 'dup-fuzzy') {
                    // Show only fuzzy match duplicates
                    state.filteredScanResults = state.scanResults.filter(f => {
                        const dup = state.duplicatesMap.get(f.objectID);
                        return dup && dup.type === 'fuzzy';
                    });
                } else if (type === 'calories-mismatch') {
                    // Show foods where calculated calories don't match stated calories
                    state.filteredScanResults = state.scanResults.filter(f => {
                        const calories = f.calories || 0;
                        const protein = f.protein || 0;
                        const carbs = f.carbs || f.carbohydrates || 0;
                        const fat = f.fat || 0;
                        if (calories === 0 || (protein === 0 && carbs === 0 && fat === 0)) return false;
                        const calculated = (protein * 4) + (carbs * 4) + (fat * 9);
                        const diff = Math.abs(calories - calculated);
                        const percentDiff = (diff / calories) * 100;
                        return percentDiff > 15 && diff > 30; // More than 15% off and 30 cal difference
                    });
                } else {
                    state.filteredScanResults = state.scanResults.filter(f =>
                        f.issues.some(i => i.type === type)
                    );
                }

                // Update filtered total display
                document.getElementById('filtered-total').textContent = state.filteredScanResults.length;

                this.renderIssuesList();
            },

            renderIssuesList() {
                const list = document.getElementById('issues-list');
                const countEl = document.getElementById('filtered-count');

                if (state.filteredScanResults.length === 0) {
                    list.innerHTML = '<div class="empty-state"><p>No foods match this filter.</p></div>';
                    countEl.textContent = '';
                    this.updatePaginationUI(0, 0);
                    return;
                }

                // Calculate pagination
                const totalItems = state.filteredScanResults.length;
                const totalPages = Math.ceil(totalItems / state.issuesPerPage);
                const startIndex = state.issuesCurrentPage * state.issuesPerPage;
                const endIndex = Math.min(startIndex + state.issuesPerPage, totalItems);
                const pageItems = state.filteredScanResults.slice(startIndex, endIndex);

                countEl.textContent = `Showing ${startIndex + 1}-${endIndex} of ${totalItems} foods with issues`;

                const html = pageItems.map(food => this.renderIssueCard(food)).join('');
                list.innerHTML = html;

                // Update pagination UI
                this.updatePaginationUI(state.issuesCurrentPage, totalPages);

                // Update filtered total for select all
                document.getElementById('filtered-total').textContent = totalItems;

                // Scroll to top of list
                document.querySelector('.issues-list-container').scrollTop = 0;
            },

            // Pagination UI update
            updatePaginationUI(currentPage, totalPages) {
                const pageText = `Page ${currentPage + 1} of ${totalPages || 1}`;

                // Update top pagination
                const pageInfo = document.getElementById('issues-page-info');
                const prevBtn = document.getElementById('issues-prev-btn');
                const nextBtn = document.getElementById('issues-next-btn');
                const pageJump = document.getElementById('issues-page-jump');

                if (pageInfo) pageInfo.textContent = pageText;
                if (pageJump) {
                    pageJump.max = totalPages || 1;
                    pageJump.value = currentPage + 1;
                }
                if (prevBtn) prevBtn.disabled = currentPage === 0;
                if (nextBtn) nextBtn.disabled = currentPage >= totalPages - 1;

                // Update bottom pagination
                const pageInfoBottom = document.getElementById('issues-page-info-bottom');
                const firstBtn = document.getElementById('issues-first-btn');
                const prevBtnBottom = document.getElementById('issues-prev-btn-bottom');
                const nextBtnBottom = document.getElementById('issues-next-btn-bottom');
                const lastBtn = document.getElementById('issues-last-btn');

                if (pageInfoBottom) pageInfoBottom.textContent = pageText;
                if (firstBtn) firstBtn.disabled = currentPage === 0;
                if (prevBtnBottom) prevBtnBottom.disabled = currentPage === 0;
                if (nextBtnBottom) nextBtnBottom.disabled = currentPage >= totalPages - 1;
                if (lastBtn) lastBtn.disabled = currentPage >= totalPages - 1;
            },

            // Pagination navigation
            issuesFirstPage() {
                state.issuesCurrentPage = 0;
                this.renderIssuesList();
            },

            issuesPrevPage() {
                if (state.issuesCurrentPage > 0) {
                    state.issuesCurrentPage--;
                    this.renderIssuesList();
                }
            },

            issuesNextPage() {
                const totalPages = Math.ceil(state.filteredScanResults.length / state.issuesPerPage);
                if (state.issuesCurrentPage < totalPages - 1) {
                    state.issuesCurrentPage++;
                    this.renderIssuesList();
                }
            },

            issuesLastPage() {
                const totalPages = Math.ceil(state.filteredScanResults.length / state.issuesPerPage);
                state.issuesCurrentPage = totalPages - 1;
                this.renderIssuesList();
            },

            issuesJumpToPage(pageNum) {
                const totalPages = Math.ceil(state.filteredScanResults.length / state.issuesPerPage);
                const page = Math.max(0, Math.min(parseInt(pageNum) - 1, totalPages - 1));
                state.issuesCurrentPage = page;
                this.renderIssuesList();
            },

            renderIssueCard(food) {
                const isMarkedDelete = state.pendingDeletes.has(food.objectID);
                const isSelected = state.selectedItems.has(food.objectID);
                const isDuplicate = state.duplicatesMap.has(food.objectID);

                // Get ledger status for this item
                const ledgerStatus = this.getIssueStatusBadge(food.objectID);
                const ledgerIssue = state.issueLedger?.issues?.[food.objectID];
                const isResolved = ledgerIssue?.status === 'resolved';
                const isSkipped = ledgerIssue?.status === 'skipped';

                // Build issue badges
                let issuesBadges = food.issues.map(issue => {
                    let content = issue.type.replace('-', ' ');
                    if (issue.value) content += `: "${issue.value}"`;
                    if (issue.suggestion) content += ` ‚Üí "${issue.suggestion}"`;
                    return `<span class="issue-badge issue-${issue.type}">${content}</span>`;
                }).join('');

                // Add duplicate badge if applicable (with type-specific styling)
                if (isDuplicate) {
                    const dupInfo = state.duplicatesMap.get(food.objectID);
                    const dupTypeLabels = {
                        'barcode': 'üè∑Ô∏è Barcode',
                        'name': 'üìù Exact Name',
                        'brand_name': 'üè™ Brand+Name',
                        'tokens': 'üî§ Same Words',
                        'size_variant': 'üìè Size Variant',
                        'fuzzy': 'üîç Similar'
                    };
                    const dupLabel = dupTypeLabels[dupInfo.type] || dupInfo.type;
                    const confidence = dupInfo.confidence || 0;
                    const valuePreview = dupInfo.value.length > 25 ? dupInfo.value.substring(0, 25) + '...' : dupInfo.value;
                    issuesBadges += `<span class="issue-badge issue-duplicate" style="background: ${confidence >= 90 ? '#fef2f2' : confidence >= 80 ? '#fff7ed' : '#fefce8'}; color: ${confidence >= 90 ? '#dc2626' : confidence >= 80 ? '#ea580c' : '#ca8a04'}; border: 1px solid currentColor;">${dupLabel} (${confidence}%): ${valuePreview}</span>`;
                }

                // Add calories mismatch info
                const calories = food.calories || 0;
                const protein = food.protein || 0;
                const carbs = food.carbs || food.carbohydrates || 0;
                const fat = food.fat || 0;
                const calculatedCals = (protein * 4) + (carbs * 4) + (fat * 9);
                let caloriesInfo = '';
                if (calories > 0 && (protein > 0 || carbs > 0 || fat > 0)) {
                    const diff = Math.abs(calories - calculatedCals);
                    const percentDiff = (diff / calories) * 100;
                    if (percentDiff > 15 && diff > 30) {
                        caloriesInfo = `<span class="issue-badge issue-impossible-nutrition">Calories: ${calories} stated vs ${Math.round(calculatedCals)} calculated</span>`;
                    }
                }

                // Highlight misspellings in name and brand
                let displayName = this.escapeHtml(food.foodName || food.name || 'Unknown');
                let displayBrand = this.escapeHtml(food.brandName || food.brand || 'No brand');

                food.issues.filter(i => i.type === 'misspelling').forEach(issue => {
                    if (issue.value) {
                        const regex = new RegExp(`(${this.escapeRegex(issue.value)})`, 'gi');
                        if (issue.field === 'name') {
                            displayName = displayName.replace(regex, '<mark class="misspelling">$1</mark>');
                        } else if (issue.field === 'brand') {
                            displayBrand = displayBrand.replace(regex, '<mark class="misspelling">$1</mark>');
                        }
                    }
                });

                // Get before/after comparison if resolved
                const comparisonHtml = isResolved ? this.getComparisonHTML(food.objectID) : '';

                // Resolution info
                let resolutionInfo = '';
                if (ledgerIssue && (isResolved || isSkipped)) {
                    const resolvedDate = ledgerIssue.resolvedAt ? new Date(ledgerIssue.resolvedAt).toLocaleString('en-GB') : '';
                    const source = ledgerIssue.sourceUsed || ledgerIssue.resolvedBy || 'Unknown';
                    resolutionInfo = `
                        <div style="margin-top: 8px; padding: 8px 12px; background: ${isResolved ? '#f0fdf4' : '#f8fafc'}; border-radius: 6px; font-size: 12px; color: ${isResolved ? '#15803d' : '#64748b'};">
                            ${isResolved ? '‚úì Resolved' : '‚óã Skipped'} via ${this.escapeHtml(source)} ${resolvedDate ? `on ${resolvedDate}` : ''}
                            ${ledgerIssue.sourceUrl ? `<br><a href="${this.escapeHtml(ledgerIssue.sourceUrl)}" target="_blank" style="color: #2563eb;">View source</a>` : ''}
                        </div>
                    `;
                }

                return `
                <div class="food-item issue-card ${isMarkedDelete ? 'marked-delete' : ''} ${isSelected ? 'selected' : ''} ${isResolved ? 'resolved' : ''} ${isSkipped ? 'skipped' : ''}" data-id="${food.objectID}">
                    <div class="food-info">
                        <div style="display: flex; align-items: flex-start; gap: 12px;">
                            <input type="checkbox" class="item-select-checkbox" ${isSelected ? 'checked' : ''}
                                onchange="app.toggleItemSelection('${food.objectID}', this.checked)"
                                style="margin-top: 4px; width: 18px; height: 18px; cursor: pointer;">
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                    ${ledgerStatus}
                                    <h3 style="margin: 0;">${displayName}</h3>
                                </div>
                                <div class="meta">
                                    <span>${displayBrand}</span>
                                    <span>${food.barcode || 'No barcode'}</span>
                                    <span>Cal: ${calories} | P: ${protein}g | C: ${carbs}g | F: ${fat}g</span>
                                </div>
                                <div class="issues-row">${issuesBadges}${caloriesInfo}</div>
                                ${resolutionInfo}
                                ${comparisonHtml}
                            </div>
                        </div>
                    </div>
                    <div class="food-actions" style="flex-direction: column; gap: 4px;">
                        ${!isResolved && !isSkipped ? `
                            <button class="discovery-btn" onclick="app.openDiscoveryModal('${food.objectID}')" title="Find official UK sources">üîç UK Sources</button>
                            <button class="btn btn-primary" onclick="app.editIssueFood('${food.objectID}')">Edit</button>
                            <button class="btn btn-secondary" onclick="app.skipSingleIssue('${food.objectID}')" title="Skip this issue">Skip</button>
                            <button class="btn btn-danger" onclick="app.queueSingleDelete('${food.objectID}')">Delete</button>
                        ` : `
                            <button class="btn btn-secondary" onclick="app.reopenIssue('${food.objectID}')" title="Re-open this issue">Re-open</button>
                        `}
                        <label class="checkbox-label" style="font-size: 11px;">
                            <input type="checkbox" ${isMarkedDelete ? 'checked' : ''} onchange="app.toggleDelete('${food.objectID}', this.checked)">
                            Delete
                        </label>
                    </div>
                </div>
                `;
            },

            // Skip a single issue manually
            skipSingleIssue(objectID) {
                if (!confirm('Skip this issue? It will be marked as skipped in the ledger.')) return;
                this.skipIssue(objectID, 'Manually skipped by user');
                this.renderIssuesList();
                this.showToast('Issue skipped', 'info');
            },

            // Re-open a resolved or skipped issue
            reopenIssue(objectID) {
                if (!state.issueLedger || !state.issueLedger.issues[objectID]) return;

                const issue = state.issueLedger.issues[objectID];
                const previousStatus = issue.status;

                // Reset the issue status
                issue.status = 'pending';
                issue.resolvedAt = null;
                issue.resolvedBy = null;
                issue.afterState = null;
                issue.sourceUsed = null;
                issue.sourceUrl = null;
                issue.changes = [];

                // Update summary counts
                if (previousStatus === 'resolved') {
                    state.issueLedger.summary.resolved--;
                } else if (previousStatus === 'skipped') {
                    state.issueLedger.summary.skipped--;
                } else if (previousStatus === 'error') {
                    state.issueLedger.summary.errors--;
                }
                state.issueLedger.summary.pending++;

                // Update UI
                this.updateLedgerUI();
                this.updateActiveSession();
                this.renderIssuesList();
                this.showToast('Issue re-opened', 'info');
            },

            // ============================================================
            // UK SOURCE DISCOVERY FUNCTIONS
            // ============================================================

            // Open discovery modal for a food item
            openDiscoveryModal(objectID) {
                const food = state.scanResults.find(f => f.objectID === objectID);
                if (!food) return;

                state.discoveryFoodItem = food;
                state.discoveredSources = [];
                state.extractedData = null;
                state.extractionSourceUrl = null;

                // Update modal header
                document.getElementById('discovery-product-name').textContent = food.foodName || food.name || 'Unknown Product';
                document.getElementById('discovery-product-barcode').textContent = food.barcode || 'No barcode';

                // Generate manual search links
                this.generateManualSearchLinks(food);

                // Reset UI states
                document.getElementById('discovery-loading').style.display = 'none';
                document.getElementById('discovery-error').style.display = 'none';
                document.getElementById('discovered-sources-section').style.display = 'none';
                document.getElementById('extraction-preview').style.display = 'none';
                document.getElementById('manual-extract-url').value = '';
                document.getElementById('discovery-status').textContent = 'Enter a URL or use manual search links';

                // Show modal
                document.getElementById('discovery-modal').classList.add('active');

                // Try automatic discovery if API is configured
                this.tryAutomaticDiscovery(food);
            },

            closeDiscoveryModal() {
                document.getElementById('discovery-modal').classList.remove('active');
                state.discoveryFoodItem = null;
            },

            // Generate manual search links for UK supermarkets
            generateManualSearchLinks(food) {
                const searchTerm = food.barcode || `${food.brandName || ''} ${food.foodName || food.name || ''}`.trim();
                const encoded = encodeURIComponent(searchTerm);

                const supermarkets = [
                    { name: 'Tesco', url: `https://www.tesco.com/groceries/en-GB/search?query=${encoded}` },
                    { name: "Sainsbury's", url: `https://www.sainsburys.co.uk/gol-ui/SearchResults/${encoded}` },
                    { name: 'Asda', url: `https://groceries.asda.com/search/${encoded}` },
                    { name: 'Morrisons', url: `https://groceries.morrisons.com/search?entry=${encoded}` },
                    { name: 'Waitrose', url: `https://www.waitrose.com/ecom/shop/search?searchTerm=${encoded}` },
                    { name: 'Ocado', url: `https://www.ocado.com/search?entry=${encoded}` },
                    { name: 'Aldi', url: `https://www.aldi.co.uk/search?q=${encoded}` },
                    { name: 'Lidl', url: `https://www.lidl.co.uk/q/query/${encoded}` }
                ];

                const linksHtml = supermarkets.map(s => `
                    <a href="${s.url}" target="_blank" class="search-link">${s.name}</a>
                `).join('');

                document.getElementById('manual-search-links').innerHTML = linksHtml;

                // Build Google query
                const siteRestrictions = 'site:tesco.com OR site:sainsburys.co.uk OR site:asda.com OR site:morrisons.com OR site:waitrose.com OR site:ocado.com';
                const googleQuery = food.barcode
                    ? `${food.barcode} ${siteRestrictions}`
                    : `"${food.brandName || ''}" "${food.foodName || food.name || ''}" nutrition ${siteRestrictions}`;
                document.getElementById('google-search-query').value = googleQuery;
            },

            // Try automatic discovery using Google Custom Search API
            async tryAutomaticDiscovery(food) {
                document.getElementById('discovery-loading').style.display = 'flex';
                document.getElementById('discovery-status').textContent = 'Searching UK sources...';

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/discoverUKProductPage`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            data: {
                                foodName: food.foodName || food.name || '',
                                barcode: food.barcode || '',
                                brand: food.brandName || food.brand || ''
                            }
                        })
                    });

                    const result = await response.json();
                    document.getElementById('discovery-loading').style.display = 'none';

                    if (result.result && result.result.success && result.result.sources.length > 0) {
                        state.discoveredSources = result.result.sources;
                        this.renderDiscoveredSources(result.result.sources);
                        document.getElementById('discovered-sources-section').style.display = 'block';
                        document.getElementById('discovery-status').textContent = `Found ${result.result.sources.length} UK source(s)`;
                    } else if (result.result && result.result.error) {
                        // API not configured or error - show manual search only
                        document.getElementById('discovery-error').style.display = 'block';
                        document.getElementById('discovery-error').querySelector('p').textContent =
                            result.result.error.includes('not configured')
                                ? 'Google Search API not configured. Use manual search links below.'
                                : result.result.error;
                        document.getElementById('discovery-status').textContent = 'Use manual search';
                    } else {
                        document.getElementById('discovery-status').textContent = 'No UK sources found - use manual search';
                    }
                } catch (error) {
                    console.error('Discovery error:', error);
                    document.getElementById('discovery-loading').style.display = 'none';
                    document.getElementById('discovery-error').style.display = 'block';
                    document.getElementById('discovery-status').textContent = 'Discovery failed - use manual search';
                }
            },

            // Render discovered sources
            renderDiscoveredSources(sources) {
                const html = sources.map((source, index) => {
                    const confidenceClass = source.confidence >= 70 ? 'high' : source.confidence >= 40 ? 'medium' : 'low';
                    return `
                        <div class="source-card" data-index="${index}" onclick="app.selectSource(${index})">
                            <div class="source-card-header">
                                <span class="source-name">${this.escapeHtml(source.sourceName)}</span>
                                <span class="source-type-badge ${source.sourceType}">${source.sourceType}</span>
                            </div>
                            <div class="source-url">${this.escapeHtml(source.url)}</div>
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
                                ${this.escapeHtml(source.title || '')}
                            </div>
                            <div class="source-confidence">
                                <span>Confidence:</span>
                                <div class="confidence-bar-mini">
                                    <div class="fill ${confidenceClass}" style="width: ${source.confidence}%"></div>
                                </div>
                                <span>${source.confidence}%</span>
                                ${source.isProductPage ? '<span style="color: #16a34a; margin-left: 8px;">‚úì Product page</span>' : ''}
                            </div>
                            <div class="source-actions">
                                <button class="btn btn-primary" onclick="event.stopPropagation(); app.extractFromSource(${index})">Extract Data</button>
                                <a href="${this.escapeHtml(source.url)}" target="_blank" class="btn btn-secondary" onclick="event.stopPropagation()">View Page</a>
                            </div>
                        </div>
                    `;
                }).join('');

                document.getElementById('discovered-sources').innerHTML = html;
            },

            selectSource(index) {
                // Highlight selected source
                document.querySelectorAll('.source-card').forEach((card, i) => {
                    card.classList.toggle('selected', i === index);
                });
            },

            // Extract data from a discovered source
            async extractFromSource(index) {
                const source = state.discoveredSources[index];
                if (!source) return;

                await this.extractFromUrl(source.url);
            },

            // Extract data from manually entered URL
            async extractFromManualUrl() {
                const url = document.getElementById('manual-extract-url').value.trim();
                if (!url) {
                    this.showToast('Please enter a URL', 'error');
                    return;
                }

                // Basic URL validation
                try {
                    new URL(url);
                } catch {
                    this.showToast('Please enter a valid URL', 'error');
                    return;
                }

                await this.extractFromUrl(url);
            },

            // Extract nutrition data from a URL
            async extractFromUrl(url) {
                document.getElementById('extract-url-btn').disabled = true;
                document.getElementById('extract-url-btn').textContent = 'Extracting...';
                document.getElementById('discovery-status').textContent = 'Extracting nutrition data...';

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/extractUKProductData`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            data: { url }
                        })
                    });

                    const result = await response.json();

                    if (result.result && result.result.success && result.result.data) {
                        state.extractedData = result.result.data;
                        state.extractionSourceUrl = url;
                        this.renderExtractionPreview(result.result.data, result.result);
                        document.getElementById('extraction-preview').style.display = 'block';
                        document.getElementById('discovery-status').textContent =
                            `Extracted via ${result.result.extractionMethod} (${result.result.confidence}% confidence)`;
                        this.showToast('Nutrition data extracted successfully', 'success');
                    } else {
                        const errorMsg = result.result?.error || 'Failed to extract data';
                        this.showToast(errorMsg, 'error');
                        document.getElementById('discovery-status').textContent = 'Extraction failed';
                    }
                } catch (error) {
                    console.error('Extraction error:', error);
                    this.showToast('Error extracting data from URL', 'error');
                    document.getElementById('discovery-status').textContent = 'Extraction error';
                } finally {
                    document.getElementById('extract-url-btn').disabled = false;
                    document.getElementById('extract-url-btn').textContent = 'Extract';
                }
            },

            // Render extraction preview
            renderExtractionPreview(data, metadata) {
                const nutrition = data.nutrition || {};
                const food = state.discoveryFoodItem;

                // UK nutrition fields (per 100g)
                const fields = [
                    { key: 'energyKcal', label: 'Energy (kcal)', currentKey: 'calories' },
                    { key: 'energyKj', label: 'Energy (kJ)', currentKey: 'energyKj' },
                    { key: 'protein', label: 'Protein (g)', currentKey: 'protein' },
                    { key: 'carbohydrate', label: 'Carbs (g)', currentKey: 'carbs' },
                    { key: 'sugars', label: 'Sugars (g)', currentKey: 'sugars' },
                    { key: 'fat', label: 'Fat (g)', currentKey: 'fat' },
                    { key: 'saturates', label: 'Saturates (g)', currentKey: 'saturatedFat' },
                    { key: 'fibre', label: 'Fibre (g)', currentKey: 'fibre' },
                    { key: 'salt', label: 'Salt (g)', currentKey: 'salt' }
                ];

                const html = fields.map(field => {
                    const newValue = nutrition[field.key];
                    const currentValue = food?.[field.currentKey];
                    const isChanged = newValue !== undefined && newValue !== null && newValue !== currentValue;

                    return `
                        <div class="extraction-field">
                            <div class="label">${field.label}</div>
                            <div class="value ${isChanged ? 'changed' : ''}">
                                ${newValue !== undefined && newValue !== null ? newValue : '‚Äî'}
                                ${isChanged && currentValue !== undefined ? `<span style="font-size: 10px; color: #94a3b8;"> (was ${currentValue})</span>` : ''}
                            </div>
                        </div>
                    `;
                }).join('');

                // Add product info if available
                let extraInfo = '';
                if (data.name) {
                    extraInfo += `<div class="extraction-field"><div class="label">Product Name</div><div class="value">${this.escapeHtml(data.name)}</div></div>`;
                }
                if (data.brand) {
                    extraInfo += `<div class="extraction-field"><div class="label">Brand</div><div class="value">${this.escapeHtml(data.brand)}</div></div>`;
                }
                if (data.ingredients) {
                    extraInfo += `<div class="extraction-field" style="grid-column: 1 / -1;"><div class="label">Ingredients</div><div class="value" style="font-size: 11px;">${this.escapeHtml(data.ingredients.substring(0, 200))}${data.ingredients.length > 200 ? '...' : ''}</div></div>`;
                }

                document.getElementById('extraction-data').innerHTML = html + extraInfo;

                // Add source info
                if (metadata) {
                    const sourceInfo = document.createElement('div');
                    sourceInfo.style.cssText = 'margin-top: 12px; padding-top: 12px; border-top: 1px solid #bbf7d0; font-size: 11px; color: #15803d;';
                    sourceInfo.innerHTML = `
                        Source: <a href="${this.escapeHtml(state.extractionSourceUrl)}" target="_blank">${this.escapeHtml(state.extractionSourceUrl)}</a><br>
                        Method: ${this.escapeHtml(metadata.extractionMethod)} | Confidence: ${metadata.confidence}%
                        ${metadata.warnings && metadata.warnings.length > 0 ? `<br><span style="color: #b45309;">‚ö†Ô∏è ${metadata.warnings.join(', ')}</span>` : ''}
                    `;
                    document.getElementById('extraction-data').appendChild(sourceInfo);
                }
            },

            // Apply extracted data to the food item
            applyExtractedData() {
                if (!state.extractedData || !state.discoveryFoodItem) {
                    this.showToast('No data to apply', 'error');
                    return;
                }

                const food = state.discoveryFoodItem;
                const data = state.extractedData;
                const nutrition = data.nutrition || {};

                // Map extracted fields to food item fields
                const changes = {};

                if (nutrition.energyKcal !== undefined) changes.calories = nutrition.energyKcal;
                if (nutrition.energyKj !== undefined) changes.energyKj = nutrition.energyKj;
                if (nutrition.protein !== undefined) changes.protein = nutrition.protein;
                if (nutrition.carbohydrate !== undefined) changes.carbs = nutrition.carbohydrate;
                if (nutrition.sugars !== undefined) changes.sugars = nutrition.sugars;
                if (nutrition.fat !== undefined) changes.fat = nutrition.fat;
                if (nutrition.saturates !== undefined) changes.saturatedFat = nutrition.saturates;
                if (nutrition.fibre !== undefined) changes.fibre = nutrition.fibre;
                if (nutrition.salt !== undefined) changes.salt = nutrition.salt;
                if (data.ingredients) changes.ingredients = data.ingredients;
                if (data.allergens && Array.isArray(data.allergens)) changes.allergens = data.allergens;

                // Queue the changes
                this.queueEdit(food.objectID, changes);

                // Mark as resolved in ledger
                this.resolveIssue(
                    food.objectID,
                    Object.keys(changes).map(key => ({
                        field: key,
                        oldValue: food[key],
                        newValue: changes[key]
                    })),
                    'uk_source_extraction',
                    {
                        sourceUrl: state.extractionSourceUrl,
                        sourceType: this.detectSourceType(state.extractionSourceUrl),
                        confidence: 85
                    }
                );

                this.closeDiscoveryModal();
                this.renderIssuesList();
                this.showToast('Data extracted and queued for update', 'success');
            },

            detectSourceType(url) {
                if (!url) return 'unknown';
                const lowerUrl = url.toLowerCase();
                if (lowerUrl.includes('tesco.com')) return 'tesco';
                if (lowerUrl.includes('sainsburys.co.uk')) return 'sainsburys';
                if (lowerUrl.includes('asda.com')) return 'asda';
                if (lowerUrl.includes('morrisons.com')) return 'morrisons';
                if (lowerUrl.includes('waitrose.com')) return 'waitrose';
                if (lowerUrl.includes('ocado.com')) return 'ocado';
                if (lowerUrl.includes('aldi.co.uk')) return 'aldi';
                if (lowerUrl.includes('lidl.co.uk')) return 'lidl';
                return 'uk_supermarket';
            },

            clearExtraction() {
                state.extractedData = null;
                state.extractionSourceUrl = null;
                document.getElementById('extraction-preview').style.display = 'none';
                document.getElementById('discovery-status').textContent = 'Enter a URL or use manual search links';
            },

            copyGoogleQuery() {
                const query = document.getElementById('google-search-query').value;
                navigator.clipboard.writeText(query).then(() => {
                    this.showToast('Google query copied to clipboard', 'success');
                }).catch(() => {
                    this.showToast('Failed to copy', 'error');
                });
            },

            // ============================================================
            // BATCH DISCOVERY FUNCTIONS
            // ============================================================

            // Start batch discovery for pending items
            async startBatchDiscovery() {
                // Check if we have scan results
                if (!state.scanResults || state.scanResults.length === 0) {
                    this.showToast('No scan results. Please run a scan first.', 'error');
                    return;
                }

                // Ensure ledger exists - create one if missing
                if (!state.issueLedger) {
                    console.log('Creating issue ledger for batch discovery...');
                    state.issueLedger = this.createIssueLedger(
                        state.scanResults,
                        state.currentScanIndex || 'unknown',
                        state.scanResults.length
                    );
                    this.updateLedgerUI();
                }

                // Get pending items (not resolved, not skipped)
                const pendingItems = state.scanResults.filter(item => {
                    const issue = state.issueLedger.issues[item.objectID];
                    return !issue || issue.status === 'pending';
                });

                if (pendingItems.length === 0) {
                    this.showToast('No pending items to process', 'info');
                    return;
                }

                // Confirm with user
                const confirmMsg = `Start batch discovery for ${pendingItems.length} pending items?\n\nThis will search UK supermarket sites and extract nutrition data.`;
                if (!confirm(confirmMsg)) return;

                // Initialize batch state
                state.batchDiscoveryQueue = [...pendingItems];
                state.batchDiscoveryTotal = pendingItems.length;
                state.batchDiscoveryProcessed = 0;
                state.batchDiscoverySuccessful = 0;
                state.batchDiscoveryFailed = 0;
                state.batchDiscoveryInProgress = true;
                state.batchDiscoveryPaused = false;
                state.batchDiscoveryResults = []; // Clear previous results

                // Update UI
                document.getElementById('batch-discovery-btn').disabled = true;
                document.getElementById('batch-discovery-btn').textContent = 'Processing...';
                document.getElementById('pause-discovery-btn').style.display = 'inline-block';

                // Show results panel
                this.showBatchResultsPanel();

                // Process queue
                await this.processBatchDiscoveryQueue();
            },

            // Show the batch results panel
            showBatchResultsPanel() {
                document.getElementById('batch-results-panel').style.display = 'flex';
                document.getElementById('batch-results-list').innerHTML = '';
                this.updateBatchResultsPanel();
            },

            // Close the batch results panel
            closeBatchResultsPanel() {
                document.getElementById('batch-results-panel').style.display = 'none';
            },

            // Update batch results panel
            updateBatchResultsPanel() {
                // Count by status
                const successCount = state.batchDiscoveryResults.filter(r => r.status === 'success').length;
                const failedCount = state.batchDiscoveryResults.filter(r => r.status === 'failed').length;
                const skippedCount = state.batchDiscoveryResults.filter(r => r.status === 'skipped').length;

                // Update counts
                document.getElementById('batch-success-count').textContent = successCount;
                document.getElementById('batch-failed-count').textContent = failedCount;
                const skippedEl = document.getElementById('batch-skipped-count');
                if (skippedEl) skippedEl.textContent = skippedCount;

                // Update progress bar
                const progress = state.batchDiscoveryTotal > 0
                    ? (state.batchDiscoveryProcessed / state.batchDiscoveryTotal) * 100
                    : 0;
                document.getElementById('batch-progress-fill').style.width = `${progress}%`;
                document.getElementById('batch-progress-text').textContent =
                    `${state.batchDiscoveryProcessed}/${state.batchDiscoveryTotal}`;

                // Also update the status bar
                const statusEl = document.getElementById('batch-discovery-status');
                if (state.batchDiscoveryInProgress) {
                    statusEl.textContent = `${state.batchDiscoveryProcessed}/${state.batchDiscoveryTotal}`;
                    if (state.batchDiscoveryPaused) {
                        statusEl.textContent += ' [PAUSED]';
                    }
                } else {
                    statusEl.textContent = '';
                }
            },

            // Filter batch results display
            filterBatchResults(filter) {
                state.batchResultsFilter = filter;

                // Update active button
                document.querySelectorAll('.batch-filter-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.filter === filter);
                });

                // Re-render the list
                this.renderBatchResultsList();
            },

            // Render filtered batch results list
            renderBatchResultsList() {
                const listEl = document.getElementById('batch-results-list');
                const filter = state.batchResultsFilter || 'all';

                const filteredResults = filter === 'all'
                    ? state.batchDiscoveryResults
                    : state.batchDiscoveryResults.filter(r => r.status === filter);

                if (filteredResults.length === 0) {
                    listEl.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">No items match this filter</div>';
                    return;
                }

                listEl.innerHTML = filteredResults.map(r => this.renderBatchResultItem(r)).join('');
            },

            // Skip all failed items in batch
            skipAllBatchErrors() {
                const failedItems = state.batchDiscoveryResults.filter(r => r.status === 'failed');
                if (failedItems.length === 0) {
                    this.showToast('No failed items to skip', 'info');
                    return;
                }

                if (!confirm(`Skip all ${failedItems.length} failed items?`)) return;

                failedItems.forEach(item => {
                    this.skipIssue(item.objectID, 'Skipped via bulk action');
                    item.status = 'skipped';
                });

                this.renderBatchResultsList();
                this.updateBatchResultsPanel();
                this.renderIssuesList();
                this.showToast(`${failedItems.length} items marked as skipped`, 'success');
            },

            // Delete all failed items in batch
            deleteAllBatchErrors() {
                const failedItems = state.batchDiscoveryResults.filter(r => r.status === 'failed');
                if (failedItems.length === 0) {
                    this.showToast('No failed items to delete', 'info');
                    return;
                }

                if (!confirm(`Queue ${failedItems.length} failed items for deletion? You'll need to Apply Changes to confirm.`)) return;

                failedItems.forEach(item => {
                    state.pendingDeletes.add(item.objectID);
                });

                this.updatePendingStatus();
                this.renderIssuesList();
                this.showToast(`${failedItems.length} items queued for deletion`, 'info');
            },

            // Add a result to the live results list
            addBatchResult(result) {
                state.batchDiscoveryResults.unshift(result); // Add to beginning

                const listEl = document.getElementById('batch-results-list');
                const itemHtml = this.renderBatchResultItem(result);

                // Insert at top
                listEl.insertAdjacentHTML('afterbegin', itemHtml);

                // Scroll to show new item
                listEl.scrollTop = 0;
            },

            // Update an existing result in the list
            updateBatchResult(objectID, updates) {
                const result = state.batchDiscoveryResults.find(r => r.objectID === objectID);
                if (result) {
                    Object.assign(result, updates);
                    const itemEl = document.querySelector(`[data-batch-result="${objectID}"]`);
                    if (itemEl) {
                        itemEl.outerHTML = this.renderBatchResultItem(result);
                    }
                }
            },

            // Render a single batch result item
            renderBatchResultItem(result) {
                const statusClass = result.status === 'success' ? 'success' :
                    result.status === 'failed' ? 'failed' :
                    result.status === 'skipped' ? 'skipped' : 'processing';

                const statusIcon = result.status === 'success' ? '‚úì' :
                    result.status === 'failed' ? '‚úó' :
                    result.status === 'skipped' ? '‚óã' : '‚ãØ';

                const statusLabel = result.status === 'success' ? 'Data extracted' :
                    result.status === 'failed' ? 'Failed' :
                    result.status === 'skipped' ? 'Skipped' : 'Processing...';

                let changesHtml = '';
                if (result.changes && result.changes.length > 0) {
                    changesHtml = `<div class="batch-result-changes" style="margin-top: 4px;">
                        <span style="color: #16a34a; font-size: 11px;">Updated: </span>
                        ${result.changes.map(c => `<span class="change-badge" style="background: #dcfce7; color: #15803d; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 4px;">${c}</span>`).join('')}
                    </div>`;
                }

                let sourceHtml = '';
                if (result.source) {
                    const domain = this.extractDomain(result.source);
                    sourceHtml = `<div class="batch-result-source" style="margin-top: 2px; font-size: 11px;">
                        <span style="color: #64748b;">Source:</span> <a href="${this.escapeHtml(result.source)}" target="_blank" style="color: #2563eb;">${domain}</a>
                    </div>`;
                }

                let errorHtml = '';
                if (result.error) {
                    // Make error messages more readable
                    let errorMsg = result.error;
                    if (errorMsg.includes('No UK sources found')) {
                        errorMsg = 'üîç No matching product found on UK supermarket sites';
                    } else if (errorMsg.includes('not configured')) {
                        errorMsg = '‚öôÔ∏è Google Search API not configured';
                    } else if (errorMsg.includes('Extraction failed')) {
                        errorMsg = 'üìÑ Could not extract nutrition data from page';
                    } else if (errorMsg.includes('Low confidence')) {
                        errorMsg = '‚ùì Found page but low confidence it matches';
                    }
                    errorHtml = `<div class="batch-result-error" style="margin-top: 4px; padding: 6px 10px; background: #fef2f2; color: #dc2626; border-radius: 4px; font-size: 11px;">
                        ${this.escapeHtml(errorMsg)}
                        ${result.hint ? `<br><span style="color: #64748b; font-size: 10px;">üí° ${this.escapeHtml(result.hint)}</span>` : ''}
                    </div>`;
                }

                // Show what was searched for
                let searchInfoHtml = '';
                if (result.barcode || result.brand) {
                    const parts = [];
                    if (result.barcode) parts.push(`Barcode: ${result.barcode}`);
                    if (result.brand) parts.push(`Brand: ${result.brand}`);
                    searchInfoHtml = `<div style="font-size: 10px; color: #94a3b8; margin-top: 2px;">${parts.join(' | ')}</div>`;
                }

                return `
                    <div class="batch-result-item" data-batch-result="${result.objectID}" style="padding: 12px 16px; border-bottom: 1px solid var(--border); display: flex; gap: 12px; align-items: flex-start; ${result.status === 'failed' ? 'background: #fffbeb;' : ''}">
                        <div class="batch-result-status ${statusClass}" style="width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; flex-shrink: 0; ${statusClass === 'success' ? 'background: #dcfce7; color: #16a34a;' : statusClass === 'failed' ? 'background: #fef2f2; color: #dc2626;' : statusClass === 'skipped' ? 'background: #f1f5f9; color: #64748b;' : 'background: #e0f2fe; color: #0284c7;'}">${statusIcon}</div>
                        <div class="batch-result-content" style="flex: 1; min-width: 0;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <div class="batch-result-name" style="font-weight: 500; color: var(--text-primary); word-break: break-word;">${this.escapeHtml(result.name)}</div>
                                <span style="font-size: 10px; color: ${statusClass === 'success' ? '#16a34a' : statusClass === 'failed' ? '#dc2626' : '#64748b'}; white-space: nowrap; margin-left: 8px;">${statusLabel}</span>
                            </div>
                            ${searchInfoHtml}
                            ${sourceHtml}
                            ${changesHtml}
                            ${errorHtml}
                        </div>
                        ${result.status === 'failed' ? `
                            <div style="display: flex; gap: 4px; flex-shrink: 0;">
                                <button onclick="app.skipSingleIssue('${result.objectID}'); app.updateBatchResultStatus('${result.objectID}', 'skipped');" style="padding: 4px 8px; font-size: 10px; border: 1px solid #d1d5db; border-radius: 4px; background: white; cursor: pointer;" title="Skip this item">Skip</button>
                                <button onclick="app.queueSingleDelete('${result.objectID}')" style="padding: 4px 8px; font-size: 10px; border: 1px solid #fecaca; border-radius: 4px; background: #fef2f2; color: #dc2626; cursor: pointer;" title="Delete this item">Del</button>
                            </div>
                        ` : ''}
                    </div>
                `;
            },

            // Update batch result status
            updateBatchResultStatus(objectID, newStatus) {
                const result = state.batchDiscoveryResults.find(r => r.objectID === objectID);
                if (result) {
                    result.status = newStatus;
                    this.renderBatchResultsList();
                    this.updateBatchResultsPanel();
                }
            },

            extractDomain(url) {
                try {
                    return new URL(url).hostname.replace('www.', '');
                } catch {
                    return url;
                }
            },

            // Process the batch discovery queue
            async processBatchDiscoveryQueue() {
                while (state.batchDiscoveryQueue.length > 0 && state.batchDiscoveryInProgress) {
                    if (state.batchDiscoveryPaused) {
                        return;
                    }

                    const item = state.batchDiscoveryQueue.shift();
                    const itemName = item.foodName || item.name || 'Unknown';
                    const itemBarcode = item.barcode || '';
                    const itemBrand = item.brandName || item.brand || '';

                    // Add processing item to results (include barcode/brand for display)
                    this.addBatchResult({
                        objectID: item.objectID,
                        name: itemName,
                        barcode: itemBarcode,
                        brand: itemBrand,
                        status: 'processing',
                        source: null,
                        changes: [],
                        error: null,
                        hint: null
                    });

                    state.batchDiscoveryProcessed++;
                    this.updateBatchResultsPanel();

                    try {
                        const result = await this.batchProcessItem(item);

                        if (result.success) {
                            state.batchDiscoverySuccessful++;
                            this.updateBatchResult(item.objectID, {
                                status: result.skipped ? 'skipped' : 'success',
                                source: result.sourceUrl,
                                changes: result.changes || []
                            });
                        } else {
                            state.batchDiscoveryFailed++;
                            this.updateBatchResult(item.objectID, {
                                status: 'failed',
                                error: result.error,
                                hint: result.hint || null
                            });
                        }
                    } catch (error) {
                        console.error('Batch discovery error for item:', item.objectID, error);
                        state.batchDiscoveryFailed++;
                        this.updateBatchResult(item.objectID, {
                            status: 'failed',
                            error: error.message || 'Unknown error'
                        });
                    }

                    this.updateBatchResultsPanel();

                    // Small delay between requests (Google is the real bottleneck)
                    if (state.batchDiscoveryQueue.length > 0 && !state.batchDiscoveryPaused) {
                        await new Promise(resolve => setTimeout(resolve, state.batchDiscoveryRateLimit));
                    }
                }

                this.finishBatchDiscovery();
            },

            // Direct supermarket search fallback (no Google API required)
            // Tries to find products directly on supermarket websites
            async directSupermarketSearch(item) {
                const searchTerm = item.barcode || `${item.brandName || item.brand || ''} ${item.foodName || item.name || ''}`.trim();

                if (!searchTerm) {
                    this.markIssueError(item.objectID, 'No search term available');
                    return { success: false, error: 'No search term available' };
                }

                // UK supermarket search URLs - try each one
                const supermarkets = [
                    { name: 'Tesco', url: `https://www.tesco.com/groceries/en-GB/search?query=${encodeURIComponent(searchTerm)}` },
                    { name: 'Sainsburys', url: `https://www.sainsburys.co.uk/gol-ui/SearchResults/${encodeURIComponent(searchTerm)}` },
                    { name: 'Asda', url: `https://groceries.asda.com/search/${encodeURIComponent(searchTerm)}` },
                    { name: 'Morrisons', url: `https://groceries.morrisons.com/search?entry=${encodeURIComponent(searchTerm)}` },
                ];

                // Try extraction directly on first available
                for (const supermarket of supermarkets) {
                    try {
                        const extractResponse = await fetch(`${CONFIG.API_BASE}/extractUKProductData`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                data: { url: supermarket.url }
                            })
                        });

                        const extractResult = await extractResponse.json();

                        if (extractResult.result?.success && extractResult.result?.data) {
                            const data = extractResult.result.data;

                            // CRITICAL: Validate that extracted product matches original item
                            const validation = this.validateProductMatch(item, data);
                            if (!validation.isMatch) {
                                console.log(`${supermarket.name}: Product mismatch - "${validation.originalName}" vs "${validation.extractedName}" (${validation.confidence}%)`);
                                continue; // Try next supermarket
                            }

                            const nutrition = data.nutrition || {};
                            const changes = {};
                            const changeLabels = [];

                            if (nutrition.energyKcal !== undefined) { changes.calories = nutrition.energyKcal; changeLabels.push('kcal'); }
                            if (nutrition.energyKj !== undefined) { changes.energyKj = nutrition.energyKj; changeLabels.push('kJ'); }
                            if (nutrition.protein !== undefined) { changes.protein = nutrition.protein; changeLabels.push('protein'); }
                            if (nutrition.carbohydrate !== undefined) { changes.carbs = nutrition.carbohydrate; changeLabels.push('carbs'); }
                            if (nutrition.sugars !== undefined) { changes.sugars = nutrition.sugars; changeLabels.push('sugars'); }
                            if (nutrition.fat !== undefined) { changes.fat = nutrition.fat; changeLabels.push('fat'); }
                            if (nutrition.saturates !== undefined) { changes.saturatedFat = nutrition.saturates; changeLabels.push('sat fat'); }
                            if (nutrition.fibre !== undefined) { changes.fibre = nutrition.fibre; changeLabels.push('fibre'); }
                            if (nutrition.salt !== undefined) { changes.salt = nutrition.salt; changeLabels.push('salt'); }
                            if (data.ingredients) { changes.ingredients = data.ingredients; changeLabels.push('ingredients'); }

                            if (Object.keys(changes).length > 0) {
                                this.queueEdit(item.objectID, changes);
                                this.resolveIssue(
                                    item.objectID,
                                    Object.keys(changes).map(key => ({
                                        field: key,
                                        oldValue: item[key],
                                        newValue: changes[key]
                                    })),
                                    'direct_supermarket_search',
                                    {
                                        sourceUrl: supermarket.url,
                                        sourceType: supermarket.name.toLowerCase(),
                                        confidence: extractResult.result.confidence || 60
                                    }
                                );
                                return { success: true, sourceUrl: supermarket.url, changes: changeLabels };
                            }
                        }
                    } catch (e) {
                        console.log(`${supermarket.name} search failed:`, e.message);
                        // Continue to next supermarket
                    }
                }

                // All supermarkets failed - mark as needing manual verification
                this.markIssueError(item.objectID, 'No UK sources found - manual lookup needed');
                return {
                    success: false,
                    error: 'No UK sources found',
                    hint: `Try searching: ${supermarkets[0].url}`
                };
            },

            // Validate that extracted product matches the original item
            validateProductMatch(originalItem, extractedData) {
                const originalName = (originalItem.foodName || originalItem.name || '').toLowerCase().trim();
                const originalBrand = (originalItem.brandName || originalItem.brand || '').toLowerCase().trim();
                const extractedName = (extractedData.name || '').toLowerCase().trim();
                const extractedBrand = (extractedData.brand || '').toLowerCase().trim();

                // Normalize strings for comparison
                const normalize = (str) => str.replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, ' ').trim();
                const normOrigName = normalize(originalName);
                const normExtName = normalize(extractedName);
                const normOrigBrand = normalize(originalBrand);
                const normExtBrand = normalize(extractedBrand);

                let confidence = 0;
                const reasons = [];

                // 1. Check name match
                if (normOrigName && normExtName) {
                    // Check containment (one contains the other)
                    if (normExtName.includes(normOrigName) || normOrigName.includes(normExtName)) {
                        confidence += 40;
                        reasons.push('Name contains match');
                    } else {
                        // Check word overlap
                        const origWords = new Set(normOrigName.split(' ').filter(w => w.length > 2));
                        const extWords = new Set(normExtName.split(' ').filter(w => w.length > 2));
                        const overlap = [...origWords].filter(w => extWords.has(w)).length;
                        const total = Math.max(origWords.size, extWords.size);
                        if (total > 0) {
                            const wordOverlapPercent = (overlap / total) * 100;
                            if (wordOverlapPercent >= 60) {
                                confidence += 30;
                                reasons.push(`Word overlap ${Math.round(wordOverlapPercent)}%`);
                            } else if (wordOverlapPercent >= 40) {
                                confidence += 15;
                                reasons.push(`Partial word overlap ${Math.round(wordOverlapPercent)}%`);
                            } else {
                                reasons.push(`Low word overlap ${Math.round(wordOverlapPercent)}%`);
                            }
                        }
                    }
                }

                // 2. Check brand match
                if (normOrigBrand && normExtBrand) {
                    if (normExtBrand.includes(normOrigBrand) || normOrigBrand.includes(normExtBrand)) {
                        confidence += 30;
                        reasons.push('Brand matches');
                    } else {
                        // Different brand is a red flag!
                        confidence -= 20;
                        reasons.push(`Brand mismatch: "${originalBrand}" vs "${extractedBrand}"`);
                    }
                } else if (normOrigBrand && !normExtBrand) {
                    // Original has brand but extracted doesn't - check if brand is in name
                    if (normExtName.includes(normOrigBrand)) {
                        confidence += 20;
                        reasons.push('Brand found in extracted name');
                    }
                }

                // 3. Size/weight match (if present)
                const sizePatterns = [
                    /(\d+)\s*(g|kg|ml|l|oz|lb)/gi,
                    /(\d+)\s*x\s*(\d+)/gi
                ];
                for (const pattern of sizePatterns) {
                    const origSizes = originalName.match(pattern) || [];
                    const extSizes = extractedName.match(pattern) || [];
                    if (origSizes.length > 0 && extSizes.length > 0) {
                        if (origSizes[0]?.toLowerCase() === extSizes[0]?.toLowerCase()) {
                            confidence += 15;
                            reasons.push('Size matches');
                        } else {
                            confidence -= 10;
                            reasons.push(`Size mismatch: ${origSizes[0]} vs ${extSizes[0]}`);
                        }
                    }
                }

                // 4. Bonus for exact match
                if (normOrigName === normExtName) {
                    confidence += 20;
                    reasons.push('Exact name match');
                }

                const result = {
                    isMatch: confidence >= 50,
                    confidence: Math.min(100, Math.max(0, confidence)),
                    reasons,
                    originalName,
                    extractedName,
                    originalBrand,
                    extractedBrand
                };

                console.log('Product validation:', result);
                return result;
            },

            // Process a single item in batch mode - returns result object
            async batchProcessItem(item) {
                // First, try to discover UK sources
                const discoveryResponse = await fetch(`${CONFIG.API_BASE}/discoverUKProductPage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        data: {
                            foodName: item.foodName || item.name || '',
                            barcode: item.barcode || '',
                            brand: item.brandName || item.brand || ''
                        }
                    })
                });

                const discoveryResult = await discoveryResponse.json();

                // Check if we found any sources
                if (!discoveryResult.result?.success || !discoveryResult.result?.sources?.length) {
                    // Show actual error from discovery (e.g., "Google API not configured")
                    const actualError = discoveryResult.result?.error || 'No UK sources found';

                    // If Google API not configured, try direct supermarket search fallback
                    if (actualError.includes('not configured') || actualError.includes('API')) {
                        console.log('Google API not configured, trying direct supermarket search...');
                        return await this.directSupermarketSearch(item);
                    }

                    this.markIssueError(item.objectID, actualError);
                    return { success: false, error: actualError };
                }

                // Get the highest confidence source that is a product page
                const sources = discoveryResult.result.sources;
                const bestSource = sources.find(s => s.isProductPage) || sources[0];

                if (!bestSource || bestSource.confidence < 50) {
                    this.markIssueError(item.objectID, 'Low confidence source');
                    return { success: false, error: 'Low confidence source' };
                }

                // Try to extract data from the best source
                const extractResponse = await fetch(`${CONFIG.API_BASE}/extractUKProductData`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        data: { url: bestSource.url }
                    })
                });

                const extractResult = await extractResponse.json();

                if (!extractResult.result?.success || !extractResult.result?.data) {
                    this.markIssueError(item.objectID, 'Extraction failed');
                    return { success: false, error: 'Failed to extract nutrition', sourceUrl: bestSource.url };
                }

                // Map extracted data to changes
                const data = extractResult.result.data;

                // CRITICAL: Validate that extracted product matches original item
                const validation = this.validateProductMatch(item, data);
                if (!validation.isMatch) {
                    const mismatchMsg = `Product mismatch (${validation.confidence}%): "${validation.originalName}" vs "${validation.extractedName}"`;
                    console.warn('Product validation failed:', validation);
                    this.markIssueError(item.objectID, mismatchMsg);
                    return {
                        success: false,
                        error: 'Product mismatch - wrong product found',
                        sourceUrl: bestSource.url,
                        hint: `Found "${validation.extractedName}" but expected "${validation.originalName}". ${validation.reasons.join(', ')}`
                    };
                }
                const nutrition = data.nutrition || {};
                const changes = {};
                const changeLabels = [];

                if (nutrition.energyKcal !== undefined) { changes.calories = nutrition.energyKcal; changeLabels.push('kcal'); }
                if (nutrition.energyKj !== undefined) { changes.energyKj = nutrition.energyKj; changeLabels.push('kJ'); }
                if (nutrition.protein !== undefined) { changes.protein = nutrition.protein; changeLabels.push('protein'); }
                if (nutrition.carbohydrate !== undefined) { changes.carbs = nutrition.carbohydrate; changeLabels.push('carbs'); }
                if (nutrition.sugars !== undefined) { changes.sugars = nutrition.sugars; changeLabels.push('sugars'); }
                if (nutrition.fat !== undefined) { changes.fat = nutrition.fat; changeLabels.push('fat'); }
                if (nutrition.saturates !== undefined) { changes.saturatedFat = nutrition.saturates; changeLabels.push('sat fat'); }
                if (nutrition.fibre !== undefined) { changes.fibre = nutrition.fibre; changeLabels.push('fibre'); }
                if (nutrition.salt !== undefined) { changes.salt = nutrition.salt; changeLabels.push('salt'); }
                if (data.ingredients) { changes.ingredients = data.ingredients; changeLabels.push('ingredients'); }
                if (data.allergens && Array.isArray(data.allergens)) { changes.allergens = data.allergens; changeLabels.push('allergens'); }

                // Only queue if we have actual changes
                if (Object.keys(changes).length > 0) {
                    this.queueEdit(item.objectID, changes);

                    this.resolveIssue(
                        item.objectID,
                        Object.keys(changes).map(key => ({
                            field: key,
                            oldValue: item[key],
                            newValue: changes[key]
                        })),
                        'batch_uk_extraction',
                        {
                            sourceUrl: bestSource.url,
                            sourceType: this.detectSourceType(bestSource.url),
                            confidence: extractResult.result.confidence || 75
                        }
                    );

                    return { success: true, sourceUrl: bestSource.url, changes: changeLabels };
                } else {
                    this.skipIssue(item.objectID, 'No changes needed');
                    return { success: true, skipped: true, sourceUrl: bestSource.url, changes: [] };
                }
            },

            // Pause batch discovery
            pauseBatchDiscovery() {
                if (!state.batchDiscoveryInProgress) return;

                state.batchDiscoveryPaused = !state.batchDiscoveryPaused;

                if (state.batchDiscoveryPaused) {
                    document.getElementById('pause-discovery-btn').textContent = '‚ñ∂Ô∏è Resume';
                    this.showToast('Batch discovery paused', 'info');
                } else {
                    document.getElementById('pause-discovery-btn').textContent = '‚è∏Ô∏è Pause';
                    this.showToast('Batch discovery resumed', 'info');
                    this.processBatchDiscoveryQueue();
                }

                this.updateBatchResultsPanel();
            },

            // Finish batch discovery
            finishBatchDiscovery() {
                state.batchDiscoveryInProgress = false;
                state.batchDiscoveryPaused = false;

                // Reset UI
                document.getElementById('batch-discovery-btn').disabled = false;
                document.getElementById('batch-discovery-btn').textContent = 'üîç Batch Discovery';
                document.getElementById('pause-discovery-btn').style.display = 'none';
                document.getElementById('batch-discovery-status').textContent = '';

                // Update pending status and list
                this.updatePendingStatus();
                this.renderIssuesList();

                // Show completion message
                this.showToast(
                    `Complete: ${state.batchDiscoverySuccessful} verified, ${state.batchDiscoveryFailed} failed`,
                    state.batchDiscoverySuccessful > 0 ? 'success' : 'info'
                );
            },

            // ============================================================
            // END UK SOURCE DISCOVERY FUNCTIONS
            // ============================================================

            escapeRegex(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            },

            editIssueFood(objectID) {
                const food = state.scanResults.find(f => f.objectID === objectID);
                if (!food) return;

                // Reuse the existing edit modal
                state.editingFood = food;
                state.editingIndex = state.filteredScanResults.findIndex(f => f.objectID === objectID);

                this.populateEditForm(food);
                this.updateNavButtons();
                document.getElementById('edit-modal').classList.add('active');
            },

            toggleDelete(objectID, checked) {
                if (checked) {
                    state.pendingDeletes.add(objectID);
                } else {
                    state.pendingDeletes.delete(objectID);
                }
                this.updatePendingStatus();
                this.renderIssuesList();
            },

            queueSingleDelete(objectID) {
                if (confirm('Are you sure you want to delete this food?')) {
                    state.pendingDeletes.add(objectID);
                    this.updatePendingStatus();
                    this.renderIssuesList();
                    this.showToast('Food queued for deletion', 'info');
                }
            },

            queueEdit(objectID, changes) {
                state.pendingEdits[objectID] = { ...state.pendingEdits[objectID], ...changes };
                this.updatePendingStatus();
            },

            updatePendingStatus() {
                const editCount = Object.keys(state.pendingEdits).length;
                const deleteCount = state.pendingDeletes.size;

                // Count pending bulk fixes
                const htmlFixCount = (state.pendingFixes['html-code'] || []).length;
                const ingredientFixCount = (state.pendingFixes['simple-ingredients'] || []).length;
                const rescanCount = (state.pendingFixes['rescan'] || []).length;
                const totalFixCount = htmlFixCount + ingredientFixCount + rescanCount;

                // Build status text
                let statusParts = [];
                if (editCount > 0) statusParts.push(`${editCount} edit${editCount !== 1 ? 's' : ''}`);
                if (totalFixCount > 0) {
                    let fixParts = [];
                    if (htmlFixCount > 0) fixParts.push(`${htmlFixCount} HTML`);
                    if (ingredientFixCount > 0) fixParts.push(`${ingredientFixCount} ingredients`);
                    if (rescanCount > 0) fixParts.push(`${rescanCount} rescan`);
                    statusParts.push(`${totalFixCount} fix${totalFixCount !== 1 ? 'es' : ''} (${fixParts.join(', ')})`);
                }

                document.getElementById('pending-edits').textContent = statusParts.length > 0 ? statusParts.join(' | ') : '0 edits';
                document.getElementById('pending-deletes').textContent = `${deleteCount} deletion${deleteCount !== 1 ? 's' : ''}`;

                const hasChanges = editCount > 0 || deleteCount > 0 || totalFixCount > 0;
                document.getElementById('apply-changes-btn').disabled = !hasChanges;
                document.getElementById('clear-queue-btn').disabled = !hasChanges;
            },

            clearQueue() {
                state.pendingEdits = {};
                state.pendingDeletes = new Set();
                state.pendingFixes = {}; // Clear pending fixes too
                this.updatePendingStatus();
                this.renderIssuesList();
                this.showToast('Queue cleared', 'info');
            },

            async applyAllChanges() {
                const indexName = state.currentScanIndex || state.currentIndex || 'tesco_products';
                const updates = Object.entries(state.pendingEdits).map(([objectID, changes]) => ({
                    objectID,
                    changes
                }));
                const deletes = Array.from(state.pendingDeletes);

                // Get pending bulk fixes
                const htmlFixIds = state.pendingFixes['html-code'] || [];
                const ingredientFixIds = state.pendingFixes['simple-ingredients'] || [];
                const rescanIds = state.pendingFixes['rescan'] || [];
                const hasEdits = updates.length > 0 || deletes.length > 0;
                const hasFixes = htmlFixIds.length > 0 || ingredientFixIds.length > 0 || rescanIds.length > 0;

                if (!hasEdits && !hasFixes) {
                    this.showToast('No changes to apply', 'info');
                    return;
                }

                // Build confirmation message
                let confirmParts = [];
                if (updates.length > 0) confirmParts.push(`${updates.length} edit(s)`);
                if (deletes.length > 0) confirmParts.push(`${deletes.length} deletion(s)`);
                if (htmlFixIds.length > 0) confirmParts.push(`${htmlFixIds.length} HTML code fix(es)`);
                if (ingredientFixIds.length > 0) confirmParts.push(`${ingredientFixIds.length} ingredient fix(es)`);
                if (rescanIds.length > 0) confirmParts.push(`${rescanIds.length} rescan(s)`);
                const confirmMsg = `Apply ${confirmParts.join(', ')}?`;
                if (!confirm(confirmMsg)) {
                    return;
                }

                document.getElementById('apply-changes-btn').disabled = true;
                document.getElementById('apply-changes-btn').textContent = 'Applying...';

                let totalSuccess = 0;
                let totalErrors = 0;

                try {
                    // 1. Process regular edits and deletes
                    if (hasEdits) {
                        const requestBody = { indexName, updates, deletes };

                        const response = await fetch(`${CONFIG.API_BASE}/batchUpdateFoods`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(requestBody)
                        });

                        const result = await response.json();

                        if (result.success) {
                            totalSuccess += (result.updated || 0) + (result.deleted || 0);
                            this.showToast(`Applied ${result.updated} updates and ${result.deleted} deletions`, 'success');

                            // Mark issues as resolved in the ledger (keep them for before/after)
                            const processedIds = new Set([...deletes, ...updates.map(u => u.objectID)]);

                            // For each processed item, mark as resolved in ledger
                            for (const objectId of processedIds) {
                                const changes = state.pendingEdits[objectId];
                                if (changes) {
                                    // Capture the after state before marking resolved
                                    const item = state.scanResults.find(f => f.objectID === objectId);
                                    if (item) {
                                        // Apply the pending changes to the item so afterState is correct
                                        Object.assign(item, changes);
                                    }
                                    // Mark as resolved (skipSave=true for bulk operations)
                                    this.resolveIssue(objectId, Object.entries(changes).map(([field, value]) => ({
                                        field,
                                        oldValue: null, // Not tracked in simple mode
                                        newValue: value,
                                        reason: 'Applied from edit queue'
                                    })), 'manual_edit', {}, true);
                                } else if (deletes.includes(objectId)) {
                                    // For deletes, mark as resolved with deletion reason (skipSave=true for bulk operations)
                                    this.resolveIssue(objectId, [{
                                        field: 'deleted',
                                        oldValue: 'exists',
                                        newValue: 'deleted',
                                        reason: 'Item deleted from database'
                                    }], 'manual_delete', {}, true);
                                }
                            }

                            // Remove deleted items from scanResults (updates stay for before/after)
                            state.scanResults = state.scanResults.filter(f => !deletes.includes(f.objectID));
                        } else {
                            totalErrors++;
                            // Mark affected items as error
                            const processedIds = [...deletes, ...updates.map(u => u.objectID)];
                            processedIds.forEach(id => this.markIssueError(id, result.error || 'Batch update failed'));
                            this.showToast('Batch update failed: ' + (result.error || 'Unknown error'), 'error');
                        }
                    }

                    // 2. Process HTML code fixes
                    if (htmlFixIds.length > 0) {
                        document.getElementById('apply-changes-btn').textContent = `Fixing HTML (${htmlFixIds.length})...`;
                        this.showToast(`Processing ${htmlFixIds.length} HTML code fixes...`, 'info');

                        const MAX_BATCH = 500;
                        let htmlFixed = 0;

                        for (let i = 0; i < htmlFixIds.length; i += MAX_BATCH) {
                            const batch = htmlFixIds.slice(i, i + MAX_BATCH);
                            if (htmlFixIds.length > MAX_BATCH) {
                                document.getElementById('apply-changes-btn').textContent = `HTML batch ${Math.floor(i/MAX_BATCH) + 1}/${Math.ceil(htmlFixIds.length/MAX_BATCH)}...`;
                            }

                            try {
                                const fixFunc = firebase.functions().httpsCallable('fixHtmlCode', { timeout: 300000 });
                                const result = await fixFunc({ indexName, objectIDs: batch });
                                if (result.data?.success) {
                                    htmlFixed += result.data.itemsFixed || 0;

                                    // Mark fixed items as resolved (skipSave=true for bulk operations)
                                    if (result.data.items) {
                                        result.data.items.forEach(item => {
                                            this.resolveIssue(item.objectID, [{
                                                field: 'html-code',
                                                oldValue: 'had HTML',
                                                newValue: 'cleaned',
                                                reason: 'HTML code removed'
                                            }], 'bulk_fix', {}, true);
                                        });
                                    }
                                }
                            } catch (err) {
                                console.error('HTML fix batch error:', err);
                                totalErrors++;
                            }
                        }

                        totalSuccess += htmlFixed;
                        this.showToast(`Fixed ${htmlFixed} items with HTML code`, 'success');
                    }

                    // 3. Process simple ingredient fixes
                    if (ingredientFixIds.length > 0) {
                        document.getElementById('apply-changes-btn').textContent = `Fixing ingredients (${ingredientFixIds.length})...`;
                        this.showToast(`Processing ${ingredientFixIds.length} simple ingredient fixes...`, 'info');

                        const MAX_BATCH = 500;
                        let ingredientsFixed = 0;

                        for (let i = 0; i < ingredientFixIds.length; i += MAX_BATCH) {
                            const batch = ingredientFixIds.slice(i, i + MAX_BATCH);
                            if (ingredientFixIds.length > MAX_BATCH) {
                                document.getElementById('apply-changes-btn').textContent = `Ingredients batch ${Math.floor(i/MAX_BATCH) + 1}/${Math.ceil(ingredientFixIds.length/MAX_BATCH)}...`;
                            }

                            try {
                                const fixFunc = firebase.functions().httpsCallable('fixSimpleIngredients', { timeout: 300000 });
                                const result = await fixFunc({ indexName, objectIDs: batch });
                                if (result.data?.success) {
                                    ingredientsFixed += result.data.itemsFixed || 0;

                                    // Mark fixed items as resolved (skipSave=true for bulk operations)
                                    if (result.data.items) {
                                        result.data.items.forEach(item => {
                                            this.resolveIssue(item.objectID, [{
                                                field: 'ingredients',
                                                oldValue: 'missing',
                                                newValue: item.addedIngredients || 'added',
                                                reason: 'Simple ingredients auto-populated'
                                            }], 'bulk_fix', {}, true);
                                        });
                                    }
                                }
                            } catch (err) {
                                console.error('Ingredient fix batch error:', err);
                                totalErrors++;
                            }
                        }

                        totalSuccess += ingredientsFixed;
                        this.showToast(`Fixed ${ingredientsFixed} simple ingredient foods`, 'success');
                    }

                    // 4. Process Tesco rescans
                    if (rescanIds.length > 0) {
                        document.getElementById('apply-changes-btn').textContent = `Rescanning (${rescanIds.length})...`;
                        this.showToast(`Rescanning ${rescanIds.length} products via Tesco API...`, 'info');

                        const MAX_BATCH = 50; // Smaller batches due to API rate limits
                        let rescannedCount = 0;

                        for (let i = 0; i < rescanIds.length; i += MAX_BATCH) {
                            const batch = rescanIds.slice(i, i + MAX_BATCH);
                            if (rescanIds.length > MAX_BATCH) {
                                document.getElementById('apply-changes-btn').textContent = `Rescan batch ${Math.floor(i/MAX_BATCH) + 1}/${Math.ceil(rescanIds.length/MAX_BATCH)}...`;
                            }

                            try {
                                const rescanFunc = firebase.functions().httpsCallable('rescanProducts', { timeout: 540000 });
                                const result = await rescanFunc({ indexName, objectIDs: batch });
                                if (result.data?.success) {
                                    rescannedCount += result.data.itemsUpdated || 0;

                                    // Mark rescanned items as resolved (skipSave=true for bulk operations)
                                    if (result.data.items) {
                                        result.data.items.forEach(item => {
                                            if (item.status === 'found') {
                                                this.resolveIssue(item.objectID, [{
                                                    field: 'nutrition',
                                                    oldValue: 'missing/bad',
                                                    newValue: 'rescanned',
                                                    reason: 'Fresh data fetched from Tesco API'
                                                }], 'bulk_fix', {}, true);
                                            }
                                        });
                                    }
                                }
                            } catch (err) {
                                console.error('Rescan batch error:', err);
                                totalErrors++;
                            }
                        }

                        totalSuccess += rescannedCount;
                        this.showToast(`Rescanned ${rescannedCount} products with fresh Tesco data`, 'success');
                    }

                    // Clear all queues
                    state.pendingEdits = {};
                    state.pendingDeletes = new Set();
                    state.pendingFixes = {};

                    // Final success message
                    if (totalErrors === 0) {
                        this.showToast(`Successfully applied all changes (${totalSuccess} items processed)`, 'success');
                    } else {
                        this.showToast(`Applied changes with ${totalErrors} error(s). Check activity log.`, 'warning');
                    }

                    // Update UI
                    this.updateLedgerUI();
                    this.filterByIssueType(state.currentIssueFilter);
                    this.updatePendingStatus();

                    // Update the saved session
                    this.updateActiveSession();

                } catch (error) {
                    console.error('Apply changes error:', error);
                    this.showToast('Apply changes failed: ' + error.message, 'error');
                }

                document.getElementById('apply-changes-btn').disabled = false;
                document.getElementById('apply-changes-btn').textContent = 'Apply All Changes';
            },

            cancelScan() {
                // Note: Can't actually cancel the server-side scan, but we can hide the UI
                state.scanInProgress = false;
                document.getElementById('scan-progress').style.display = 'none';
                document.getElementById('scan-empty').style.display = 'block';
                document.getElementById('start-scan-btn').disabled = false;
            },

            // =====================
            // Selection Functions
            // =====================

            toggleItemSelection(objectID, checked) {
                if (checked) {
                    state.selectedItems.add(objectID);
                } else {
                    state.selectedItems.delete(objectID);
                }
                this.updateSelectionUI();
            },

            toggleSelectAll(checked) {
                // Select/deselect all items on current page
                const startIndex = state.issuesCurrentPage * state.issuesPerPage;
                const endIndex = Math.min(startIndex + state.issuesPerPage, state.filteredScanResults.length);
                const pageItems = state.filteredScanResults.slice(startIndex, endIndex);

                if (checked) {
                    pageItems.forEach(food => state.selectedItems.add(food.objectID));
                } else {
                    pageItems.forEach(food => state.selectedItems.delete(food.objectID));
                }

                this.updateSelectionUI();
                this.renderIssuesList();
            },

            toggleSelectAllFiltered(checked) {
                // Select/deselect ALL filtered items (not just current page)
                if (checked) {
                    state.filteredScanResults.forEach(food => state.selectedItems.add(food.objectID));
                } else {
                    state.filteredScanResults.forEach(food => state.selectedItems.delete(food.objectID));
                }

                this.updateSelectionUI();
                this.renderIssuesList();
            },

            clearSelection() {
                state.selectedItems = new Set();
                document.getElementById('select-all-checkbox').checked = false;
                document.getElementById('select-all-filtered-checkbox').checked = false;
                this.updateSelectionUI();
                this.renderIssuesList();
            },

            deleteSelected() {
                if (state.selectedItems.size === 0) {
                    this.showToast('No items selected', 'info');
                    return;
                }

                if (!confirm(`Delete ${state.selectedItems.size} selected items?`)) return;

                // Add all selected items to pending deletes
                state.selectedItems.forEach(id => state.pendingDeletes.add(id));
                this.updatePendingStatus();
                this.renderIssuesList();
                this.showToast(`${state.selectedItems.size} items queued for deletion`, 'info');
            },

            updateSelectionUI() {
                const count = state.selectedItems.size;

                // Safely update elements (some may not exist)
                const selectionInfo = document.getElementById('selection-info');
                if (selectionInfo) selectionInfo.textContent = `${count} selected`;

                const clearBtn = document.getElementById('clear-selection-btn');
                if (clearBtn) clearBtn.disabled = count === 0;

                const deleteBtn = document.getElementById('delete-selected-btn');
                if (deleteBtn) deleteBtn.disabled = count === 0;

                const aiLookupBtn = document.getElementById('ai-lookup-selected-btn');
                if (aiLookupBtn) aiLookupBtn.disabled = count === 0;

                const approveBtn = document.getElementById('approve-calculated-btn');
                if (approveBtn) approveBtn.disabled = count === 0;

                // Update select all checkboxes
                if (state.filteredScanResults && state.filteredScanResults.length > 0) {
                    const startIndex = state.issuesCurrentPage * state.issuesPerPage;
                    const endIndex = Math.min(startIndex + state.issuesPerPage, state.filteredScanResults.length);
                    const pageItems = state.filteredScanResults.slice(startIndex, endIndex);
                    const pageAllSelected = pageItems.every(f => state.selectedItems.has(f.objectID));

                    const selectAllCheckbox = document.getElementById('select-all-checkbox');
                    if (selectAllCheckbox) selectAllCheckbox.checked = pageAllSelected && pageItems.length > 0;

                    const allFilteredSelected = state.filteredScanResults.every(f => state.selectedItems.has(f.objectID));
                    const selectAllFilteredCheckbox = document.getElementById('select-all-filtered-checkbox');
                    if (selectAllFilteredCheckbox) selectAllFilteredCheckbox.checked = allFilteredSelected && state.filteredScanResults.length > 0;
                }
            },

            // =====================
            // Calories Approval
            // =====================

            approveCalculatedCalories() {
                if (state.selectedItems.size === 0) {
                    this.showToast('No items selected', 'info');
                    return;
                }

                // Find selected items with calories mismatch
                let updatedCount = 0;
                const updates = [];

                state.selectedItems.forEach(objectID => {
                    const food = state.scanResults.find(f => f.objectID === objectID);
                    if (!food) return;

                    const protein = food.protein || 0;
                    const carbs = food.carbs || food.carbohydrates || 0;
                    const fat = food.fat || 0;

                    if (protein > 0 || carbs > 0 || fat > 0) {
                        const calculatedCals = Math.round((protein * 4) + (carbs * 4) + (fat * 9));
                        updates.push({
                            objectID,
                            calculatedCals
                        });
                        // Queue the edit
                        state.pendingEdits[objectID] = {
                            ...(state.pendingEdits[objectID] || {}),
                            calories: calculatedCals
                        };
                        updatedCount++;
                    }
                });

                if (updatedCount > 0) {
                    this.updatePendingStatus();
                    this.showToast(`Queued ${updatedCount} calorie updates. Click "Apply All Changes" to save.`, 'success');
                    document.getElementById('calories-status').textContent = `${updatedCount} calories will be updated`;
                } else {
                    this.showToast('No items with valid macros to calculate calories from', 'info');
                }
            },

            // =====================================================
            // UK VERIFICATION SYSTEM - Transparent & Auditable
            // =====================================================

            /**
             * UK SOURCE TIER DEFINITIONS (MANDATORY ORDER):
             *
             * TIER 1 - PRIMARY (ALWAYS PREFERRED):
             * - Official manufacturer UK product pages
             * - Manufacturer nutrition PDFs (UK labelling)
             * - UK Supermarket listings:
             *   - Tesco (tesco.com)
             *   - Sainsbury's (sainsburys.co.uk)
             *   - Asda (asda.com)
             *   - Morrisons (morrisons.com)
             *   - Waitrose (waitrose.com)
             *   - Co-op (coop.co.uk)
             *   - Aldi UK (aldi.co.uk)
             *   - Lidl UK (lidl.co.uk)
             *
             * TIER 2 - SECONDARY (ONLY IF TIER 1 UNAVAILABLE):
             * - OpenFoodFacts entries that are:
             *   a) Marked as manufacturer-edited AND
             *   b) UK-specific (countries_tags includes 'en:united-kingdom')
             * - Brand-owned UK microsites
             *
             * TIER 3 - LAST RESORT (REQUIRES 2+ MATCHING SOURCES):
             * - Multiple independent UK listings that match exactly
             *
             * NEVER ACCEPTABLE:
             * - USDA or any US-based nutrition databases
             * - Non-UK product variants
             * - Community-contributed data without verification
             * - Estimated or guessed values
             */

            // UK Supermarket domains for source identification
            UK_SUPERMARKET_DOMAINS: [
                'tesco.com', 'sainsburys.co.uk', 'asda.com', 'groceries.asda.com',
                'morrisons.com', 'waitrose.com', 'coop.co.uk', 'aldi.co.uk', 'lidl.co.uk',
                'ocado.com', 'iceland.co.uk', 'marksandspencer.com'
            ],

            // UK 14 Allergens (mandatory under UK Food Law)
            UK_ALLERGENS: [
                'celery', 'cereals containing gluten', 'crustaceans', 'eggs', 'fish',
                'lupin', 'milk', 'molluscs', 'mustard', 'nuts', 'peanuts',
                'sesame', 'soybeans', 'sulphur dioxide'
            ],

            // ============================================================
            // ISSUE LEDGER SYSTEM
            // Proper before/after tracking with immutable total counts
            // ============================================================

            // Create a new Issue Ledger when scan completes
            createIssueLedger(scanResults, indexName, totalScanned) {
                const ledger = {
                    sessionId: Date.now().toString(),
                    createdAt: new Date().toISOString(),
                    indexName: indexName,
                    totalScanned: totalScanned,

                    // Summary counts (totalFound never changes)
                    summary: {
                        totalFound: scanResults.length,
                        pending: scanResults.length,
                        resolved: 0,
                        skipped: 0,
                        errors: 0
                    },

                    // Individual issue records indexed by objectID
                    issues: {}
                };

                // Populate issue records with frozen beforeState
                for (const item of scanResults) {
                    const beforeState = this.captureItemState(item);
                    ledger.issues[item.objectID] = {
                        id: item.objectID,
                        foodName: item.foodName || item.name || 'Unknown',
                        barcode: item.barcode || '',
                        brand: item.brandName || item.brand || '',
                        issueTypes: item.issues || [],
                        severity: this.calculateSeverity(item.issues || []),

                        // Frozen before state
                        beforeState: beforeState,

                        // After state (null until resolved)
                        afterState: null,

                        // Resolution tracking
                        status: 'pending', // pending | resolved | skipped | error
                        resolvedAt: null,
                        resolvedBy: null, // 'google_discovery' | 'manual' | 'ai_suggestion'

                        // Source audit trail
                        sourceUsed: null,
                        sourceUrl: null,
                        sourceType: null,
                        confidence: null,

                        // Change log
                        changes: []
                    };
                }

                return ledger;
            },

            // Capture the current state of an item (for before/after)
            captureItemState(item) {
                return {
                    foodName: item.foodName || item.name || null,
                    brandName: item.brandName || item.brand || null,
                    barcode: item.barcode || null,
                    calories: item.calories || null,
                    protein: item.protein || null,
                    carbs: item.carbs || item.carbohydrates || null,
                    fat: item.fat || null,
                    fibre: item.fibre || item.fiber || null,
                    sugars: item.sugars || item.sugar || null,
                    salt: item.salt || null,
                    saturatedFat: item.saturatedFat || null,
                    energyKj: item.energyKj || null,
                    ingredients: item.ingredients || item.extractedIngredients || null,
                    allergens: item.allergens || null
                };
            },

            // Calculate issue severity
            calculateSeverity(issues) {
                if (!issues || issues.length === 0) return 'low';
                // Issues can be strings or objects with .type property
                const getIssueType = (i) => typeof i === 'string' ? i : (i?.type || '');
                if (issues.some(i => {
                    const type = getIssueType(i);
                    return type.includes('missing-nutrition') || type.includes('impossible');
                })) return 'high';
                if (issues.some(i => {
                    const type = getIssueType(i);
                    return type.includes('duplicate') || type.includes('mismatch');
                })) return 'medium';
                return 'low';
            },

            // Resolve an issue with changes
            resolveIssue(objectId, changes, resolvedBy, sourceInfo = {}, skipSave = false) {
                if (!state.issueLedger) return;

                // Ensure issue exists in ledger
                if (!state.issueLedger.issues[objectId]) {
                    const item = state.scanResults.find(r => r.objectID === objectId);
                    if (item) {
                        state.issueLedger.issues[objectId] = {
                            id: objectId,
                            foodName: item.foodName || item.name || 'Unknown',
                            barcode: item.barcode || '',
                            brand: item.brandName || item.brand || '',
                            issueTypes: item.issues || [],
                            severity: 'medium',
                            beforeState: this.captureItemState(item),
                            afterState: null,
                            status: 'pending',
                            resolvedAt: null,
                            resolvedBy: null,
                            sourceUsed: null,
                            sourceUrl: null,
                            sourceType: null,
                            confidence: null,
                            changes: []
                        };
                        state.issueLedger.summary.totalFound++;
                        state.issueLedger.summary.pending++;
                    }
                }

                const issue = state.issueLedger.issues[objectId];
                if (!issue) return;

                // Capture the new state
                const item = state.scanResults.find(f => f.objectID === objectId);
                if (item) {
                    issue.afterState = this.captureItemState(item);
                }

                // Only decrement pending if it was previously pending
                const wasPending = issue.status === 'pending';

                // Update issue record
                issue.status = 'resolved';
                issue.resolvedAt = new Date().toISOString();
                issue.resolvedBy = resolvedBy;
                issue.changes = changes || [];
                issue.sourceUsed = sourceInfo.name || null;
                issue.sourceUrl = sourceInfo.url || sourceInfo.sourceUrl || null;
                issue.sourceType = sourceInfo.type || sourceInfo.sourceType || null;
                issue.confidence = sourceInfo.confidence || null;

                // Update summary counts
                if (wasPending) {
                    state.issueLedger.summary.pending--;
                }
                state.issueLedger.summary.resolved++;

                // Update UI
                this.updateLedgerUI();
                if (!skipSave) {
                    this.updateActiveSession();
                }
            },

            // Skip an issue
            skipIssue(objectId, reason = '') {
                if (!state.issueLedger) return;

                // Ensure issue exists in ledger
                if (!state.issueLedger.issues[objectId]) {
                    const item = state.scanResults.find(r => r.objectID === objectId);
                    if (item) {
                        state.issueLedger.issues[objectId] = {
                            id: objectId,
                            foodName: item.foodName || item.name || 'Unknown',
                            barcode: item.barcode || '',
                            brand: item.brandName || item.brand || '',
                            issueTypes: item.issues || [],
                            severity: 'medium',
                            beforeState: this.captureItemState(item),
                            afterState: null,
                            status: 'pending',
                            resolvedAt: null,
                            resolvedBy: null,
                            sourceUsed: null,
                            sourceUrl: null,
                            sourceType: null,
                            confidence: null,
                            changes: []
                        };
                        state.issueLedger.summary.totalFound++;
                        state.issueLedger.summary.pending++;
                    }
                }

                const issue = state.issueLedger.issues[objectId];
                if (!issue) return;

                // Only decrement pending if it was previously pending
                const wasPending = issue.status === 'pending';

                issue.status = 'skipped';
                issue.resolvedAt = new Date().toISOString();
                issue.resolvedBy = 'manual_skip';
                issue.changes = [{ field: 'status', reason: reason || 'Manually skipped' }];

                // Update summary counts
                if (wasPending) {
                    state.issueLedger.summary.pending--;
                }
                state.issueLedger.summary.skipped++;

                // Update UI
                this.updateLedgerUI();
                this.updateActiveSession();
            },

            // Mark issue as error
            markIssueError(objectId, errorMessage) {
                if (!state.issueLedger) return;

                // Ensure issue exists in ledger
                if (!state.issueLedger.issues[objectId]) {
                    const item = state.scanResults.find(r => r.objectID === objectId);
                    if (item) {
                        state.issueLedger.issues[objectId] = {
                            id: objectId,
                            foodName: item.foodName || item.name || 'Unknown',
                            barcode: item.barcode || '',
                            brand: item.brandName || item.brand || '',
                            issueTypes: item.issues || [],
                            severity: 'medium',
                            beforeState: this.captureItemState(item),
                            afterState: null,
                            status: 'pending',
                            resolvedAt: null,
                            resolvedBy: null,
                            sourceUsed: null,
                            sourceUrl: null,
                            sourceType: null,
                            confidence: null,
                            changes: []
                        };
                        state.issueLedger.summary.totalFound++;
                        state.issueLedger.summary.pending++;
                    }
                }

                const issue = state.issueLedger.issues[objectId];
                if (!issue) return;

                // Only decrement pending if it was previously pending
                if (issue.status === 'pending') {
                    state.issueLedger.summary.pending--;
                }

                issue.status = 'error';
                issue.resolvedAt = new Date().toISOString();
                issue.changes = [{ field: 'error', reason: errorMessage }];

                state.issueLedger.summary.errors++;

                // Update UI
                this.updateLedgerUI();
                this.updateActiveSession();
            },

            // Update ledger UI elements
            updateLedgerUI() {
                if (!state.issueLedger) return;

                const summary = state.issueLedger.summary;

                // Update summary stats
                document.getElementById('ledger-total').textContent = summary.totalFound.toLocaleString();
                document.getElementById('ledger-pending').textContent = summary.pending.toLocaleString();
                document.getElementById('ledger-resolved').textContent = summary.resolved.toLocaleString();
                document.getElementById('ledger-skipped').textContent = summary.skipped.toLocaleString();
                document.getElementById('ledger-errors').textContent = summary.errors.toLocaleString();

                // Update tab counts
                document.getElementById('tab-count-all').textContent = summary.totalFound.toLocaleString();
                document.getElementById('tab-count-pending').textContent = summary.pending.toLocaleString();
                document.getElementById('tab-count-resolved').textContent = summary.resolved.toLocaleString();
                document.getElementById('tab-count-skipped').textContent = summary.skipped.toLocaleString();

                // Update category counts
                this.updateCategoryCounts();
            },

            // Update category dashboard counts
            updateCategoryCounts() {
                const foods = state.scanResults || [];

                // Count by category
                const counts = {
                    duplicates: state.duplicatesMap?.size || 0,
                    missing: 0,
                    invalid: 0,
                    calories: 0,
                    text: 0,
                    multiple: 0
                };

                foods.forEach(food => {
                    if (!food.issues || !Array.isArray(food.issues)) return;

                    // Count items with multiple issues
                    if (food.issues.length > 1) counts.multiple++;

                    // Count by issue type (unique per item)
                    const types = new Set(food.issues.map(i => i.type));

                    if (types.has('missing-nutrition') || types.has('missing-barcode') || types.has('missing-ingredients')) {
                        counts.missing++;
                    }
                    if (types.has('impossible-nutrition') || types.has('suspect-value')) {
                        counts.invalid++;
                    }
                    if (types.has('calories-mismatch')) {
                        counts.calories++;
                    }
                    if (types.has('misspelling') || types.has('weird-spacing') || types.has('non-word')) {
                        counts.text++;
                    }
                });

                // Update UI
                const safeUpdate = (id, value) => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = value.toLocaleString();
                };

                safeUpdate('cat-duplicates', counts.duplicates);
                safeUpdate('cat-missing', counts.missing);
                safeUpdate('cat-invalid', counts.invalid);
                safeUpdate('cat-calories', counts.calories);
                safeUpdate('cat-text', counts.text);
                safeUpdate('cat-multiple', counts.multiple);

                // Update duplicates button badge
                this.updateDuplicatesPanel();
            },

            // Filter issues by ledger status
            filterByLedgerStatus(status) {
                state.currentLedgerFilter = status;

                // Update tab UI
                document.querySelectorAll('.issue-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.status === status);
                });

                // Filter the scan results based on ledger status
                if (status === 'all') {
                    state.filteredScanResults = [...state.scanResults];
                } else if (state.issueLedger) {
                    const matchingIds = Object.entries(state.issueLedger.issues)
                        .filter(([id, issue]) => issue.status === status)
                        .map(([id]) => id);
                    state.filteredScanResults = state.scanResults.filter(item =>
                        matchingIds.includes(item.objectID)
                    );
                }

                // Reset to first page and re-render
                state.issuesCurrentPage = 0;
                this.renderIssuesList();
            },

            // Get before/after comparison HTML for an issue
            getComparisonHTML(objectId) {
                if (!state.issueLedger || !state.issueLedger.issues[objectId]) return '';

                const issue = state.issueLedger.issues[objectId];
                if (!issue.afterState || issue.status !== 'resolved') return '';

                const before = issue.beforeState || {};
                const after = issue.afterState || {};

                const fields = [
                    { key: 'calories', label: 'Calories (kcal)' },
                    { key: 'protein', label: 'Protein (g)' },
                    { key: 'carbs', label: 'Carbs (g)' },
                    { key: 'fat', label: 'Fat (g)' },
                    { key: 'fibre', label: 'Fibre (g)' },
                    { key: 'sugars', label: 'Sugars (g)' },
                    { key: 'salt', label: 'Salt (g)' },
                    { key: 'saturatedFat', label: 'Saturates (g)' }
                ];

                let changedFields = [];
                for (const field of fields) {
                    if (before[field.key] !== after[field.key]) {
                        changedFields.push({
                            ...field,
                            oldVal: before[field.key],
                            newVal: after[field.key]
                        });
                    }
                }

                if (changedFields.length === 0) return '';

                return `
                    <div class="change-comparison">
                        <div class="comparison-side before">
                            <h4>Before</h4>
                            ${changedFields.map(f => `
                                <div class="comparison-field">
                                    <span class="field-name">${f.label}</span>
                                    <span class="field-value changed">${f.oldVal ?? '‚Äî'}</span>
                                </div>
                            `).join('')}
                        </div>
                        <div class="comparison-side after">
                            <h4>After</h4>
                            ${changedFields.map(f => `
                                <div class="comparison-field">
                                    <span class="field-name">${f.label}</span>
                                    <span class="field-value new">${f.newVal ?? '‚Äî'}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            },

            // Get status badge HTML for an issue
            getIssueStatusBadge(objectId) {
                if (!state.issueLedger || !state.issueLedger.issues[objectId]) {
                    return '<span class="issue-status-badge status-pending">PENDING</span>';
                }

                const issue = state.issueLedger.issues[objectId];
                const statusMap = {
                    'pending': { class: 'status-pending', label: 'PENDING' },
                    'resolved': { class: 'status-resolved', label: 'RESOLVED' },
                    'skipped': { class: 'status-skipped', label: 'SKIPPED' },
                    'error': { class: 'status-error', label: 'ERROR' }
                };

                const s = statusMap[issue.status] || statusMap.pending;
                return `<span class="issue-status-badge ${s.class}">${s.label}</span>`;
            },

            // Get items to verify based on current selection
            getItemsToVerify(forceIncludeVerified = false) {
                let items = [];

                // If items are selected, use those
                if (state.selectedItems.size > 0) {
                    items = Array.from(state.selectedItems).map(id =>
                        state.scanResults.find(f => f.objectID === id)
                    ).filter(Boolean);
                } else {
                    // Use all filtered items
                    items = [...state.filteredScanResults];
                }

                // Skip already verified items unless forced
                if (!forceIncludeVerified) {
                    items = items.filter(item => item.verificationStatus !== 'VERIFIED');
                }

                return items;
            },

            // Main verification action: Verify Against Online Sources
            async verifyAgainstSources() {
                const items = this.getItemsToVerify();

                if (items.length === 0) {
                    this.showToast('No unverified items to process. Use "Force Re-run" to re-check verified items.', 'info');
                    return;
                }

                const confirmMsg = `Verify ${items.length} items against UK sources?\n\nThis will:\n‚Ä¢ Search Open Food Facts (UK entries only)\n‚Ä¢ Look for UK supermarket listings (Tesco, Sainsbury's, etc.)\n‚Ä¢ Use only Tier 1/2 UK-compliant sources\n‚Ä¢ Show proposed changes in DRY RUN mode\n‚Ä¢ Require your approval before any changes are saved\n\n‚ö†Ô∏è US sources (USDA etc.) are NOT used - UK data only.`;

                if (!confirm(confirmMsg)) return;

                await this.runVerificationBatch(items, 'full');
            },

            // Fix Nutrition Only
            async fixNutritionOnly() {
                const items = this.getItemsToVerify();

                if (items.length === 0) {
                    this.showToast('No items selected or all items already verified.', 'info');
                    return;
                }

                const confirmMsg = `Fix nutrition data for ${items.length} items?\n\nThis will ONLY update (UK format per 100g):\n‚Ä¢ Energy (kcal and kJ)\n‚Ä¢ Protein, Carbohydrates, Fat\n‚Ä¢ Fibre, Sugars, Salt\n‚Ä¢ Saturated Fat\n‚Ä¢ Vitamins/minerals if available\n\n‚ö†Ô∏è UK labelling format only - salt not sodium.`;

                if (!confirm(confirmMsg)) return;

                await this.runVerificationBatch(items, 'nutrition');
            },

            // Fix Ingredients Only
            async fixIngredientsOnly() {
                const items = this.getItemsToVerify();

                if (items.length === 0) {
                    this.showToast('No items selected or all items already verified.', 'info');
                    return;
                }

                const confirmMsg = `Fix ingredient data for ${items.length} items?\n\nThis will ONLY update:\n‚Ä¢ Ingredient list (UK weight order)\n‚Ä¢ UK 14 Allergens (celery, gluten, crustaceans, eggs, fish, lupin, milk, molluscs, mustard, nuts, peanuts, sesame, soya, sulphites)\n‚Ä¢ E-numbers and additives`;

                if (!confirm(confirmMsg)) return;

                await this.runVerificationBatch(items, 'ingredients');
            },

            // Skip selected items in the ledger
            flagForHumanReview() {
                const items = this.getItemsToVerify(false); // Only get pending items

                if (items.length === 0) {
                    this.showToast('No pending items to skip. Select items first or use items that are not yet resolved.', 'info');
                    return;
                }

                const confirmMsg = `Skip ${items.length} items? They will be marked as skipped in the ledger.`;
                if (!confirm(confirmMsg)) return;

                // Mark items as skipped in the ledger
                items.forEach(item => {
                    this.skipIssue(item.objectID, 'Manually skipped via bulk action');
                });

                // Clear selection
                state.selectedItems.clear();

                this.updatePendingStatus();
                this.renderIssuesList();
                this.updateSelectionUI();
                this.showToast(`${items.length} items skipped.`, 'success');
            },

            // Force Re-run Verification
            async forceRerunVerification() {
                const items = this.getItemsToVerify(true); // Include verified items

                if (items.length === 0) {
                    this.showToast('No items selected.', 'info');
                    return;
                }

                const confirmMsg = `Force re-verify ${items.length} items?\n\nThis will re-check ALL selected items, including those already verified.`;
                if (!confirm(confirmMsg)) return;

                await this.runVerificationBatch(items, 'full');
            },

            // Fix kJ+kcal Combined Calories
            async fixKjKcalCalories() {
                const indexSelect = document.getElementById('scan-index');
                const indexName = indexSelect ? indexSelect.value : 'tesco_products';

                // First do a dry run to show what will be fixed
                this.showToast('Scanning for kJ+kcal combined calories...', 'info');

                try {
                    const dryRunResponse = await fetch(`${CONFIG.API_BASE}/fixKjKcalCombinedCalories`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ indexName, dryRun: true })
                    });

                    const dryRunResult = await dryRunResponse.json();

                    if (!dryRunResult.success) {
                        this.showToast(`Error: ${dryRunResult.error}`, 'error');
                        return;
                    }

                    if (dryRunResult.itemsFound === 0) {
                        this.showToast('No kJ+kcal combined calories found in this index.', 'success');
                        return;
                    }

                    // Show preview of items to fix
                    let previewMsg = `Found ${dryRunResult.itemsFound} items with kJ+kcal combined calories:\n\n`;
                    const preview = dryRunResult.items.slice(0, 10);
                    preview.forEach(item => {
                        previewMsg += `‚Ä¢ ${item.oldCalories} ‚Üí ${item.newCalories} kcal (${item.pattern})\n`;
                    });
                    if (dryRunResult.itemsFound > 10) {
                        previewMsg += `\n...and ${dryRunResult.itemsFound - 10} more.\n`;
                    }
                    previewMsg += `\nApply fixes to ${dryRunResult.itemsFound} items?`;

                    if (!confirm(previewMsg)) {
                        this.showToast('Fix cancelled.', 'info');
                        return;
                    }

                    // Apply the fixes
                    this.showToast('Applying fixes...', 'info');

                    const fixResponse = await fetch(`${CONFIG.API_BASE}/fixKjKcalCombinedCalories`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ indexName, dryRun: false })
                    });

                    const fixResult = await fixResponse.json();

                    if (fixResult.success) {
                        this.showToast(`‚úÖ Fixed ${fixResult.itemsFixed} items with kJ+kcal combined calories.`, 'success');
                    } else {
                        this.showToast(`Error: ${fixResult.error}`, 'error');
                    }

                } catch (error) {
                    console.error('Fix kJ+kcal error:', error);
                    this.showToast(`Error: ${error.message}`, 'error');
                }
            },

            // Fix simple ingredient foods (olive oil, honey, etc.) - EARMARK for Apply All Changes
            fixSimpleIngredients() {
                console.log('[fixSimpleIngredients] Called');
                console.log('[fixSimpleIngredients] state.scanResults length:', (state.scanResults || []).length);

                // Check if we have scan results with missing-ingredients issues
                const missingIngredientsItems = (state.scanResults || []).filter(item =>
                    item.issues && item.issues.some(issue => issue.type === 'missing-ingredients')
                );

                console.log('[fixSimpleIngredients] Found items with missing-ingredients:', missingIngredientsItems.length);
                if (missingIngredientsItems.length > 0) {
                    console.log('[fixSimpleIngredients] First item issues:', JSON.stringify(missingIngredientsItems[0].issues));
                }

                if (missingIngredientsItems.length === 0) {
                    // Debug: Show what issue types ARE in the scan results
                    const allIssueTypes = new Set();
                    (state.scanResults || []).forEach(item => {
                        (item.issues || []).forEach(issue => allIssueTypes.add(issue.type));
                    });
                    console.log('[fixSimpleIngredients] All issue types in scan results:', Array.from(allIssueTypes));
                    this.showToast('No items with missing ingredients found. Run a scan first.', 'info');
                    return;
                }

                const objectIDs = missingIngredientsItems.map(item => item.objectID);

                // Check if already earmarked
                const alreadyEarmarked = state.pendingFixes['simple-ingredients'] || [];
                const newCount = objectIDs.filter(id => !alreadyEarmarked.includes(id)).length;

                if (newCount === 0) {
                    this.showToast(`${objectIDs.length} items already earmarked for simple ingredients fix`, 'info');
                    return;
                }

                // Add to pending fixes (merge with existing)
                state.pendingFixes['simple-ingredients'] = [...new Set([...alreadyEarmarked, ...objectIDs])];

                this.showToast(`Earmarked ${newCount} item(s) for simple ingredients fix. Click "Apply All Changes" to execute.`, 'success');
                this.updatePendingStatus();
                this.renderIssuesList(); // Re-render to show earmarked state
            },

            // Fix HTML code in food records - EARMARK for Apply All Changes
            fixHtmlCode() {
                console.log('[fixHtmlCode] Called');
                console.log('[fixHtmlCode] state.scanResults length:', (state.scanResults || []).length);

                // Check if we have scan results with html-code issues
                const htmlCodeItems = (state.scanResults || []).filter(item =>
                    item.issues && item.issues.some(issue => issue.type === 'html-code')
                );

                console.log('[fixHtmlCode] Found items with html-code:', htmlCodeItems.length);
                if (htmlCodeItems.length > 0) {
                    console.log('[fixHtmlCode] First item issues:', JSON.stringify(htmlCodeItems[0].issues));
                }

                if (htmlCodeItems.length === 0) {
                    // Debug: Show what issue types ARE in the scan results
                    const allIssueTypes = new Set();
                    (state.scanResults || []).forEach(item => {
                        (item.issues || []).forEach(issue => allIssueTypes.add(issue.type));
                    });
                    console.log('[fixHtmlCode] All issue types in scan results:', Array.from(allIssueTypes));
                    this.showToast('No items with HTML code issues found. Run a scan first.', 'info');
                    return;
                }

                const objectIDs = htmlCodeItems.map(item => item.objectID);

                // Check if already earmarked
                const alreadyEarmarked = state.pendingFixes['html-code'] || [];
                const newCount = objectIDs.filter(id => !alreadyEarmarked.includes(id)).length;

                if (newCount === 0) {
                    this.showToast(`${objectIDs.length} items already earmarked for HTML code fix`, 'info');
                    return;
                }

                // Add to pending fixes (merge with existing)
                state.pendingFixes['html-code'] = [...new Set([...alreadyEarmarked, ...objectIDs])];

                this.showToast(`Earmarked ${newCount} item(s) for HTML code fix. Click "Apply All Changes" to execute.`, 'success');
                this.updatePendingStatus();
                this.renderIssuesList(); // Re-render to show earmarked state
            },

            // Rescan products with bad nutrition/details via Tesco API - EARMARK for Apply All Changes
            rescanProducts() {
                // Find items with nutrition or detail issues that could benefit from a rescan
                const rescanIssueTypes = ['missing-nutrition', 'impossible-nutrition', 'missing-ingredients'];
                const rescanItems = (state.scanResults || []).filter(item =>
                    item.issues && item.issues.some(issue => rescanIssueTypes.includes(issue.type))
                );

                if (rescanItems.length === 0) {
                    this.showToast('No items with nutrition/ingredient issues found. Run a scan first.', 'info');
                    return;
                }

                const objectIDs = rescanItems.map(item => item.objectID);

                // Check if already earmarked
                const alreadyEarmarked = state.pendingFixes['rescan'] || [];
                const newCount = objectIDs.filter(id => !alreadyEarmarked.includes(id)).length;

                if (newCount === 0) {
                    this.showToast(`${objectIDs.length} items already earmarked for rescan`, 'info');
                    return;
                }

                // Add to pending fixes (merge with existing)
                state.pendingFixes['rescan'] = [...new Set([...alreadyEarmarked, ...objectIDs])];

                this.showToast(`Earmarked ${newCount} item(s) for Tesco rescan. Click "Apply All Changes" to execute.`, 'success');
                this.updatePendingStatus();
                this.renderIssuesList(); // Re-render to show earmarked state
            },

            // Main batch verification runner
            async runVerificationBatch(items, mode = 'full') {
                if (state.verificationInProgress) {
                    this.showToast('Verification already in progress.', 'info');
                    return;
                }

                // Initialize state
                state.verificationInProgress = true;
                state.verificationCancelled = false;
                state.verificationResults = new Map();
                state.verificationLog = [];
                state.verificationStats = {
                    processed: 0,
                    verified: 0,
                    updated: 0,
                    flagged: 0,
                    skipped: 0,
                    errors: 0
                };

                // Show progress overlay
                this.showVerificationProgress(items.length, mode);

                // Disable action buttons
                this.setVerificationButtonsEnabled(false);

                // Sort items: those with barcodes first (more reliable)
                const sortedItems = [
                    ...items.filter(f => f.barcode && f.barcode.length >= 8),
                    ...items.filter(f => !f.barcode || f.barcode.length < 8)
                ];

                // Process items one by one for transparency
                for (let i = 0; i < sortedItems.length; i++) {
                    if (state.verificationCancelled) {
                        this.addVerificationLog('Verification cancelled by user.', 'warn');
                        break;
                    }

                    const item = sortedItems[i];
                    const name = item.foodName || item.name || 'Unknown';

                    this.addVerificationLog(`Processing: ${name.substring(0, 40)}...`, 'update');

                    try {
                        const result = await this.verifySingleItem(item, mode);
                        state.verificationResults.set(item.objectID, result);

                        // Update stats based on result
                        state.verificationStats.processed++;
                        if (result.status === 'VERIFIED') state.verificationStats.verified++;
                        else if (result.status === 'UPDATED') state.verificationStats.updated++;
                        else if (result.status === 'FLAGGED') state.verificationStats.flagged++;
                        else if (result.status === 'SKIPPED') state.verificationStats.skipped++;

                        // Log result
                        const statusEmoji = {
                            'VERIFIED': '‚úÖ',
                            'UPDATED': 'üîÑ',
                            'FLAGGED': '‚ö†Ô∏è',
                            'SKIPPED': '‚è≠Ô∏è',
                            'NO_ACTION': '‚ûñ'
                        };
                        this.addVerificationLog(
                            `${statusEmoji[result.status] || '‚ùì'} ${name.substring(0, 30)}: ${result.status}${result.sources.length > 0 ? ` (${result.sources[0].name})` : ''}`,
                            result.status === 'UPDATED' ? 'update' : result.status === 'VERIFIED' ? 'success' : 'skip'
                        );

                    } catch (error) {
                        console.error('Verification error:', error);
                        state.verificationStats.errors++;
                        this.addVerificationLog(`‚ùå Error processing ${name.substring(0, 30)}: ${error.message}`, 'error');
                    }

                    // Update progress UI
                    this.updateVerificationProgressUI();

                    // Small delay between items to avoid rate limiting
                    if (i < sortedItems.length - 1) {
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                }

                // Verification complete
                state.verificationInProgress = false;

                // Show summary
                this.addVerificationLog(`\n=== VERIFICATION COMPLETE ===`, 'success');
                this.addVerificationLog(`Processed: ${state.verificationStats.processed}`, 'skip');
                this.addVerificationLog(`Verified: ${state.verificationStats.verified}`, 'success');
                this.addVerificationLog(`Updated: ${state.verificationStats.updated}`, 'update');
                this.addVerificationLog(`Flagged: ${state.verificationStats.flagged}`, 'warn');
                this.addVerificationLog(`Skipped: ${state.verificationStats.skipped}`, 'skip');

                // Re-enable buttons
                this.setVerificationButtonsEnabled(true);

                // Update counts
                this.updateVerificationCounts();
                this.renderIssuesList();

                // Show completion message
                const hasChanges = state.verificationStats.updated > 0;
                if (hasChanges) {
                    this.showToast(`Verification complete. ${state.verificationStats.updated} items have proposed changes. Review and apply in the detail view.`, 'success');
                } else {
                    this.showToast(`Verification complete. ${state.verificationStats.verified} items verified, no changes needed.`, 'info');
                }
            },

            // Verify a single item against UK OFFICIAL SOURCES ONLY
            // NOTE: Open Food Facts removed - data already comes from there (circular validation)
            // This now provides search hints for manual verification
            // Phase 3 will add automatic Google discovery
            async verifySingleItem(item, mode = 'full') {
                const barcode = item.barcode || '';
                const name = item.foodName || item.name || '';
                const brand = item.brandName || item.brand || '';

                const result = {
                    status: 'NO_ACTION',
                    ukVerificationStatus: 'PENDING', // UK_VERIFIED, NON_UK_DATA, INSUFFICIENT_UK_DATA
                    sources: [],
                    rejectedSources: [],
                    fieldChanges: [],
                    confidence: 0,
                    reason: '',
                    timestamp: new Date().toISOString(),
                    isUKData: false
                };

                // Build search hints for UK supermarket product pages
                const searchName = name.replace(/['"]/g, '');
                const searchBrand = brand.replace(/['"]/g, '');

                result.searchHints = {
                    // Google query to find official UK product pages
                    googleQuery: barcode
                        ? `${barcode} site:tesco.com OR site:sainsburys.co.uk OR site:asda.com OR site:morrisons.com OR site:waitrose.com OR site:ocado.com`
                        : `"${searchBrand}" "${searchName}" nutrition site:tesco.com OR site:sainsburys.co.uk OR site:asda.com OR site:morrisons.com`,
                    // Direct links to search on each supermarket
                    suggestedSources: [
                        {
                            name: 'Tesco',
                            searchUrl: `https://www.tesco.com/groceries/en-GB/search?query=${encodeURIComponent(barcode || name)}`,
                            domain: 'tesco.com',
                            tier: 1
                        },
                        {
                            name: "Sainsbury's",
                            searchUrl: `https://www.sainsburys.co.uk/gol-ui/SearchResults/${encodeURIComponent(barcode || name)}`,
                            domain: 'sainsburys.co.uk',
                            tier: 1
                        },
                        {
                            name: 'Asda',
                            searchUrl: `https://groceries.asda.com/search/${encodeURIComponent(barcode || name)}`,
                            domain: 'asda.com',
                            tier: 1
                        },
                        {
                            name: 'Morrisons',
                            searchUrl: `https://groceries.morrisons.com/search?entry=${encodeURIComponent(barcode || name)}`,
                            domain: 'morrisons.com',
                            tier: 1
                        },
                        {
                            name: 'Waitrose',
                            searchUrl: `https://www.waitrose.com/ecom/shop/search?searchTerm=${encodeURIComponent(barcode || name)}`,
                            domain: 'waitrose.com',
                            tier: 1
                        },
                        {
                            name: 'Ocado',
                            searchUrl: `https://www.ocado.com/search?entry=${encodeURIComponent(barcode || name)}`,
                            domain: 'ocado.com',
                            tier: 1
                        }
                    ]
                };

                // Mark as requiring manual verification
                // Phase 3 will add automatic Google discovery and extraction
                result.status = 'FLAGGED';
                result.reason = 'Awaiting UK official source verification - use Google to find product on UK supermarket sites';
                result.confidence = 0;
                result.ukVerificationStatus = 'INSUFFICIENT_UK_DATA';

                // Store the result on the item for display
                item.verificationResult = result;
                item.ukVerificationStatus = result.ukVerificationStatus;

                return result;
            },

            // Check if a URL/domain is a UK source
            isUKSource(url) {
                if (!url) return false;
                const lowerUrl = url.toLowerCase();

                // UK TLD
                if (lowerUrl.includes('.co.uk') || lowerUrl.includes('.uk')) return true;

                // UK supermarket domains
                if (this.UK_SUPERMARKET_DOMAINS.some(domain => lowerUrl.includes(domain))) return true;

                return false;
            },

            // Compare nutrition data using UK-SPECIFIC format
            // UK uses: salt (not sodium), fibre (not fiber), kJ as well as kcal
            compareNutritionDataUK(original, verified, mode = 'full') {
                const changes = [];

                // UK NUTRITION FIELDS (per 100g/100ml - UK mandatory format)
                const nutritionFields = [
                    { key: 'calories', label: 'Energy (kcal)', unit: 'kcal', threshold: 5 },
                    { key: 'energyKj', label: 'Energy (kJ)', unit: 'kJ', threshold: 20 },
                    { key: 'protein', label: 'Protein', unit: 'g', threshold: 0.5 },
                    { key: 'carbs', label: 'Carbohydrate', unit: 'g', threshold: 1 },
                    { key: 'sugars', label: 'of which sugars', unit: 'g', threshold: 0.5 },
                    { key: 'fat', label: 'Fat', unit: 'g', threshold: 0.5 },
                    { key: 'saturatedFat', label: 'of which saturates', unit: 'g', threshold: 0.5 },
                    { key: 'fibre', label: 'Fibre', unit: 'g', threshold: 0.5 }, // UK spelling
                    // UK uses SALT not sodium (salt = sodium √ó 2.5)
                    { key: 'salt', label: 'Salt', unit: 'g', threshold: 0.05 }
                ];

                const ingredientFields = [
                    { key: 'ingredients', label: 'Ingredients', unit: '', threshold: 0 },
                    { key: 'allergens', label: 'UK 14 Allergens', unit: '', threshold: 0 }
                ];

                const identityFields = [
                    { key: 'foodName', label: 'Product Name', unit: '', threshold: 0 },
                    { key: 'brandName', label: 'Brand', unit: '', threshold: 0 }
                ];

                // Determine which fields to compare based on mode
                let fieldsToCompare = [];
                if (mode === 'full') fieldsToCompare = [...nutritionFields, ...ingredientFields, ...identityFields];
                else if (mode === 'nutrition') fieldsToCompare = nutritionFields;
                else if (mode === 'ingredients') fieldsToCompare = ingredientFields;

                for (const field of fieldsToCompare) {
                    // Handle field name mapping (e.g., fiber -> fibre)
                    let oldVal = original[field.key];
                    const newVal = verified[field.key];

                    // Map legacy US field names to UK equivalents
                    if (field.key === 'fibre' && oldVal === undefined) oldVal = original['fiber'];
                    if (field.key === 'sugars' && oldVal === undefined) oldVal = original['sugar'];
                    if (field.key === 'salt' && oldVal === undefined) {
                        // Convert sodium to salt if needed (salt = sodium √ó 2.5)
                        const sodiumMg = original['sodium'];
                        if (sodiumMg !== undefined) oldVal = Math.round((sodiumMg / 1000) * 2.5 * 100) / 100;
                    }

                    // Skip if no new value available
                    if (newVal === null || newVal === undefined) continue;

                    // Handle allergens array comparison
                    if (field.key === 'allergens' && Array.isArray(newVal)) {
                        const oldAllergens = Array.isArray(oldVal) ? oldVal : [];
                        const newAllergens = newVal;
                        if (JSON.stringify(oldAllergens.sort()) !== JSON.stringify(newAllergens.sort())) {
                            changes.push({
                                field: field.key,
                                label: field.label,
                                oldValue: oldAllergens.join(', ') || '(none)',
                                newValue: newAllergens.join(', '),
                                unit: field.unit,
                                confidence: 0.9,
                                reason: 'UK allergen information updated'
                            });
                        }
                        continue;
                    }

                    // Check if values differ significantly
                    const isDifferent = this.valuesDiffer(oldVal, newVal, field.threshold);

                    if (isDifferent) {
                        changes.push({
                            field: field.key,
                            label: field.label,
                            oldValue: oldVal,
                            newValue: newVal,
                            unit: field.unit,
                            confidence: 0.8,
                            reason: oldVal === undefined || oldVal === null
                                ? 'Missing UK data filled from source'
                                : 'Value differs from UK trusted source'
                        });
                    }
                }

                return changes;
            },

            // Legacy compare function (for backwards compatibility)
            compareNutritionData(original, verified, mode = 'full') {
                // Redirect to UK function
                return this.compareNutritionDataUK(original, verified, mode);
            },

            // Check if two values differ significantly
            valuesDiffer(oldVal, newVal, threshold) {
                // Handle null/undefined
                if (oldVal === null || oldVal === undefined) return newVal !== null && newVal !== undefined;
                if (newVal === null || newVal === undefined) return false;

                // Handle strings
                if (typeof oldVal === 'string' && typeof newVal === 'string') {
                    return oldVal.toLowerCase().trim() !== newVal.toLowerCase().trim();
                }

                // Handle numbers with threshold
                if (typeof oldVal === 'number' && typeof newVal === 'number') {
                    return Math.abs(oldVal - newVal) > threshold;
                }

                return oldVal !== newVal;
            },

            // Show verification progress overlay
            showVerificationProgress(total, mode) {
                const overlay = document.getElementById('verification-progress-overlay');
                const titleEl = document.getElementById('verify-progress-title');
                const subtitleEl = document.getElementById('verify-progress-subtitle');

                const modeLabels = {
                    'full': 'üá¨üáß Verifying against UK sources...',
                    'nutrition': 'üá¨üáß Verifying UK nutrition data...',
                    'ingredients': 'üá¨üáß Verifying UK ingredients...'
                };

                titleEl.textContent = modeLabels[mode] || 'üá¨üáß Verifying...';
                subtitleEl.textContent = `Searching UK-only sources for ${total} items (Tesco, Sainsbury's, Open Food Facts UK)`;

                document.getElementById('verify-progress-total').textContent = total;
                document.getElementById('verify-progress-current').textContent = '0';
                document.getElementById('verify-progress-fill').style.width = '0%';

                document.getElementById('verify-stat-verified').textContent = '0';
                document.getElementById('verify-stat-updated').textContent = '0';
                document.getElementById('verify-stat-flagged').textContent = '0';
                document.getElementById('verify-stat-skipped').textContent = '0';

                document.getElementById('verification-log-stream').innerHTML = '<div class="log-line log-skip">Starting verification...</div>';

                overlay.style.display = 'flex';
            },

            // Update verification progress UI
            updateVerificationProgressUI() {
                const stats = state.verificationStats;
                const total = state.verificationResults.size + stats.skipped + stats.errors;

                document.getElementById('verify-progress-current').textContent = stats.processed;
                const percent = Math.round((stats.processed / parseInt(document.getElementById('verify-progress-total').textContent)) * 100);
                document.getElementById('verify-progress-fill').style.width = `${percent}%`;

                document.getElementById('verify-stat-verified').textContent = stats.verified;
                document.getElementById('verify-stat-updated').textContent = stats.updated;
                document.getElementById('verify-stat-flagged').textContent = stats.flagged;
                document.getElementById('verify-stat-skipped').textContent = stats.skipped;
            },

            // Add log line to verification stream
            addVerificationLog(message, type = 'skip') {
                const logStream = document.getElementById('verification-log-stream');
                const logLine = document.createElement('div');
                logLine.className = `log-line log-${type}`;
                logLine.textContent = message;
                logStream.appendChild(logLine);
                logStream.scrollTop = logStream.scrollHeight;

                // Keep log in state
                state.verificationLog.push({ message, type, timestamp: new Date().toISOString() });
            },

            // Cancel verification
            cancelVerification() {
                if (state.verificationInProgress) {
                    state.verificationCancelled = true;
                    this.addVerificationLog('Cancelling...', 'warn');
                } else {
                    document.getElementById('verification-progress-overlay').style.display = 'none';
                }
            },

            // Set verification action buttons enabled/disabled
            setVerificationButtonsEnabled(enabled) {
                const buttons = [
                    'btn-verify-sources',
                    'btn-fix-nutrition',
                    'btn-fix-ingredients',
                    'btn-flag-review',
                    'btn-force-rerun'
                ];

                buttons.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.disabled = !enabled;
                });
            },

            // Update verification counts display
            updateVerificationCounts() {
                let verified = 0;
                let unverified = 0;

                state.scanResults.forEach(item => {
                    if (item.verificationStatus === 'VERIFIED') verified++;
                    else unverified++;
                });

                const verifiedEl = document.getElementById('verified-count');
                const unverifiedEl = document.getElementById('unverified-count');
                if (verifiedEl) verifiedEl.textContent = verified;
                if (unverifiedEl) unverifiedEl.textContent = unverified;
            },

            // Open verification detail modal for a specific item
            openVerificationModal(objectId) {
                const item = state.scanResults.find(f => f.objectID === objectId);
                if (!item) return;

                state.currentVerificationItem = item;

                // Populate modal header
                document.getElementById('verify-modal-title').textContent = item.foodName || item.name || 'Unknown Product';
                document.getElementById('verify-modal-brand').textContent = item.brandName || item.brand || 'Unknown Brand';
                document.getElementById('verify-modal-barcode').textContent = item.barcode || 'No Barcode';
                document.getElementById('verify-modal-country').textContent = item.country || 'UK';

                // Set verification status badge
                const statusBadge = document.getElementById('verify-modal-status');
                const status = item.verificationStatus || 'UNVERIFIED';
                statusBadge.textContent = status;
                statusBadge.className = `verification-badge status-${status.toLowerCase().replace('_', '-')}`;

                // Populate original data
                this.renderComparisonData(item);

                // Show/hide dry run banner based on pending changes
                const result = state.verificationResults.get(objectId);
                const hasPendingChanges = result && result.fieldChanges && result.fieldChanges.length > 0;
                document.getElementById('dry-run-banner').style.display = hasPendingChanges ? 'flex' : 'none';

                // Render sources if available
                this.renderSourcesList(result);

                // Render change log if available
                this.renderChangeLog(result);

                // Render audit log if item has verification history
                this.renderAuditLog(item);

                // Show modal
                document.getElementById('verification-modal').classList.add('active');
            },

            // Render side-by-side comparison
            renderComparisonData(item) {
                const result = state.verificationResults.get(item.objectID);

                const fields = [
                    { key: 'foodName', label: 'Product Name' },
                    { key: 'brandName', label: 'Brand' },
                    { key: 'calories', label: 'Calories', unit: 'kcal' },
                    { key: 'protein', label: 'Protein', unit: 'g' },
                    { key: 'carbs', label: 'Carbohydrates', unit: 'g' },
                    { key: 'fat', label: 'Fat', unit: 'g' },
                    { key: 'fiber', label: 'Fiber', unit: 'g' },
                    { key: 'sugar', label: 'Sugar', unit: 'g' },
                    { key: 'salt', label: 'Salt', unit: 'g' },
                    { key: 'saturatedFat', label: 'Saturated Fat', unit: 'g' }
                ];

                // Build original data column
                let originalHtml = '';
                let verifiedHtml = '';

                fields.forEach(field => {
                    const originalVal = item[field.key];
                    const unit = field.unit || '';

                    originalHtml += `
                        <div class="comparison-field">
                            <span class="field-name">${field.label}</span>
                            <span class="field-value">${originalVal !== undefined && originalVal !== null ? originalVal + (unit ? ' ' + unit : '') : '‚Äî'}</span>
                        </div>
                    `;

                    // Check if there's a proposed change for this field
                    let verifiedVal = originalVal;
                    let isChanged = false;
                    let fieldConfidence = null;

                    if (result && result.fieldChanges) {
                        const change = result.fieldChanges.find(c => c.field === field.key);
                        if (change) {
                            verifiedVal = change.newValue;
                            isChanged = true;
                            fieldConfidence = change.confidence;
                        }
                    }

                    verifiedHtml += `
                        <div class="comparison-field">
                            <span class="field-name">${field.label}</span>
                            <span class="field-value ${isChanged ? 'changed' : ''}">${verifiedVal !== undefined && verifiedVal !== null ? verifiedVal + (unit ? ' ' + unit : '') : '‚Äî'}${fieldConfidence ? `<span class="field-confidence">(${Math.round(fieldConfidence * 100)}%)</span>` : ''}</span>
                        </div>
                    `;
                });

                document.getElementById('original-data-fields').innerHTML = originalHtml;
                document.getElementById('verified-data-fields').innerHTML = verifiedHtml;

                // Update confidence display
                if (result && result.confidence) {
                    const confidenceFill = document.getElementById('verify-modal-confidence-fill');
                    const confidenceValue = document.getElementById('verify-modal-confidence-value');
                    const pct = Math.round(result.confidence * 100);
                    confidenceFill.style.width = `${pct}%`;
                    confidenceValue.textContent = `${pct}%`;
                    confidenceFill.className = `confidence-fill ${pct >= 70 ? 'high' : pct >= 40 ? 'medium' : 'low'}`;
                }
            },

            // Render sources list
            renderSourcesList(result) {
                const container = document.getElementById('sources-list');
                const itemsContainer = document.getElementById('sources-items');

                if (!result || !result.sources || result.sources.length === 0) {
                    container.style.display = 'none';
                    return;
                }

                let html = '';
                result.sources.forEach(source => {
                    html += `
                        <div class="source-item">
                            <span class="source-tier tier-${source.tier}">Tier ${source.tier}</span>
                            <span class="source-name">${source.name}</span>
                            <a href="${source.url}" target="_blank" class="source-url">${source.url}</a>
                        </div>
                    `;
                });

                itemsContainer.innerHTML = html;
                container.style.display = 'block';
            },

            // Render change log
            renderChangeLog(result) {
                const container = document.getElementById('change-log');
                const entriesContainer = document.getElementById('change-log-entries');

                if (!result || !result.fieldChanges || result.fieldChanges.length === 0) {
                    container.style.display = 'none';
                    return;
                }

                let html = '';
                result.fieldChanges.forEach(change => {
                    html += `
                        <div class="change-log-entry">
                            <span class="field-badge">${change.label}</span>
                            <div class="change-values">
                                <span class="old-value">${change.oldValue !== undefined && change.oldValue !== null ? change.oldValue + (change.unit ? ' ' + change.unit : '') : '(empty)'}</span>
                                <span class="arrow">‚Üí</span>
                                <span class="new-value">${change.newValue}${change.unit ? ' ' + change.unit : ''}</span>
                                <div class="change-reason">${change.reason}</div>
                            </div>
                        </div>
                    `;
                });

                entriesContainer.innerHTML = html;
                container.style.display = 'block';
            },

            // Render audit log
            renderAuditLog(item) {
                const container = document.getElementById('audit-log-section');
                const entriesContainer = document.getElementById('audit-log-entries');

                if (!item.verificationLog || item.verificationLog.length === 0) {
                    container.style.display = 'none';
                    return;
                }

                let html = '';
                item.verificationLog.slice(-10).reverse().forEach(entry => {
                    const date = new Date(entry.timestamp);
                    const dateStr = date.toLocaleString('en-GB', {
                        day: '2-digit', month: 'short', year: 'numeric',
                        hour: '2-digit', minute: '2-digit'
                    });

                    html += `
                        <div class="audit-entry entry-${entry.action.toLowerCase()}">
                            <span class="timestamp">${dateStr}</span>
                            <span class="action-type type-${entry.action.toLowerCase()}">${entry.action}</span>
                            <span class="details">${entry.reason || 'No details'}</span>
                        </div>
                    `;
                });

                entriesContainer.innerHTML = html;
                container.style.display = 'block';
            },

            // Close verification modal
            closeVerificationModal() {
                document.getElementById('verification-modal').classList.remove('active');
                state.currentVerificationItem = null;
            },

            // Apply proposed changes for current item
            applyProposedChanges() {
                if (!state.currentVerificationItem) return;

                const item = state.currentVerificationItem;
                const result = state.verificationResults.get(item.objectID);

                if (!result || !result.fieldChanges || result.fieldChanges.length === 0) {
                    this.showToast('No changes to apply.', 'info');
                    return;
                }

                // Build changes object
                const changes = {};
                result.fieldChanges.forEach(change => {
                    changes[change.field] = change.newValue;
                });

                // Add verification metadata
                changes.verificationStatus = 'UPDATED';
                changes.lastVerifiedDate = new Date().toISOString();
                changes.confidenceScore = result.confidence;

                // Queue the changes
                state.pendingEdits[item.objectID] = {
                    ...(state.pendingEdits[item.objectID] || {}),
                    ...changes
                };

                // Update item verification log
                item.verificationLog = item.verificationLog || [];
                item.verificationLog.push({
                    timestamp: new Date().toISOString(),
                    action: 'UPDATE',
                    sources: result.sources,
                    fieldChanges: result.fieldChanges,
                    status: 'APPLIED'
                });

                // Update item status
                item.verificationStatus = 'UPDATED';

                // Clear from pending verification results
                state.verificationResults.delete(item.objectID);

                // Update UI
                this.updatePendingStatus();
                this.renderIssuesList();
                this.updateVerificationCounts();
                this.closeVerificationModal();

                this.showToast(`Changes queued for "${item.foodName || item.name}". Click "Apply All Changes" to save to database.`, 'success');
            },

            // Reject proposed changes
            rejectProposedChanges() {
                if (!state.currentVerificationItem) return;

                const item = state.currentVerificationItem;

                // Clear pending verification result
                state.verificationResults.delete(item.objectID);

                // Mark as verified (no changes needed)
                item.verificationStatus = 'VERIFIED';
                item.verificationLog = item.verificationLog || [];
                item.verificationLog.push({
                    timestamp: new Date().toISOString(),
                    action: 'VERIFY',
                    sources: [],
                    fieldChanges: [],
                    reason: 'Changes rejected - original data accepted',
                    status: 'APPLIED'
                });

                // Queue status update
                state.pendingEdits[item.objectID] = {
                    ...(state.pendingEdits[item.objectID] || {}),
                    verificationStatus: 'VERIFIED',
                    lastVerifiedDate: new Date().toISOString()
                };

                this.updatePendingStatus();
                this.renderIssuesList();
                this.updateVerificationCounts();
                this.closeVerificationModal();

                this.showToast('Changes rejected. Original data marked as verified.', 'info');
            },

            // Flag item for manual review from modal
            flagForManualReview() {
                if (!state.currentVerificationItem) return;

                const item = state.currentVerificationItem;

                item.verificationStatus = 'FLAGGED';
                item.verificationLog = item.verificationLog || [];
                item.verificationLog.push({
                    timestamp: new Date().toISOString(),
                    action: 'FLAG',
                    sources: [],
                    fieldChanges: [],
                    reason: 'Flagged for human review from detail view',
                    status: 'APPLIED'
                });

                state.pendingEdits[item.objectID] = {
                    ...(state.pendingEdits[item.objectID] || {}),
                    verificationStatus: 'FLAGGED',
                    lastVerifiedDate: new Date().toISOString()
                };

                state.verificationResults.delete(item.objectID);

                this.updatePendingStatus();
                this.renderIssuesList();
                this.updateVerificationCounts();
                this.closeVerificationModal();

                this.showToast('Item flagged for human review.', 'success');
            },

            // Legacy compatibility - redirect old AI functions
            async aiLookupSelected() {
                this.showToast('AI Lookup has been replaced with the new Verification System. Use "Verify Against Online Sources" instead.', 'info');
            },

            async aiLookupAll() {
                this.showToast('AI Lookup has been replaced with the new Verification System. Use "Verify Against Online Sources" instead.', 'info');
            },

            // =====================
            // Session Persistence
            // =====================

            // ULTRA-MINIMAL COMPRESSION - Only store what's needed to reload from Algolia
            // Previous method stored ~200 bytes/item, this stores ~30 bytes/item
            compressFoodItem(food) {
                // For ultra-minimal storage, we only need objectID
                // Issue codes are stored separately in issueMap
                return food.objectID;
            },

            // Create issue code map for compact storage
            // Each issue type is abbreviated to 3 chars: mis=misspelling, dup=duplicate, cal=calories-mismatch, etc.
            createIssueCode(issues) {
                if (!issues || !Array.isArray(issues) || issues.length === 0) return '';
                const codeMap = {
                    'misspelling': 'mis',
                    'duplicate': 'dup',
                    'calories-mismatch': 'cal',
                    'missing-nutrition': 'mnu',
                    'impossible-nutrition': 'imp',
                    'missing-barcode': 'mbc',
                    'missing-ingredients': 'min',
                    'weird-spacing': 'wsp',
                    'non-word': 'nwd',
                    'suspect-value': 'sus',
                    'html-code': 'htm'
                };
                return issues.map(i => codeMap[i.type] || i.type.substring(0, 3)).join(',');
            },

            // Decode issue codes back to full types
            decodeIssueCodes(code) {
                if (!code) return [];
                const reverseMap = {
                    'mis': 'misspelling',
                    'dup': 'duplicate',
                    'cal': 'calories-mismatch',
                    'mnu': 'missing-nutrition',
                    'imp': 'impossible-nutrition',
                    'mbc': 'missing-barcode',
                    'min': 'missing-ingredients',
                    'wsp': 'weird-spacing',
                    'nwd': 'non-word',
                    'sus': 'suspect-value',
                    'htm': 'html-code'
                };
                return code.split(',').filter(c => c).map(c => ({
                    type: reverseMap[c] || c,
                    severity: 'medium'
                }));
            },

            // Decompress - this now needs to fetch from Algolia
            decompressFoodItem(compressed) {
                // If it's just an objectID string, return a placeholder
                // Full data will be fetched from Algolia when loading session
                if (typeof compressed === 'string') {
                    return { objectID: compressed, _needsReload: true };
                }
                // Legacy format compatibility
                return {
                    ...compressed,
                    name: compressed.foodName,
                    brand: compressed.brandName,
                    carbohydrates: compressed.carbs,
                    fibre: compressed.fiber,
                    sugars: compressed.sugar
                };
            },

            // Compress ledger - ultra minimal, only status info
            compressLedger(ledger) {
                if (!ledger) return null;
                const compressedIssues = {};
                for (const [id, issue] of Object.entries(ledger.issues)) {
                    // Only store if not pending (saves space for bulk of items)
                    if (issue.status !== 'pending') {
                        compressedIssues[id] = {
                            s: issue.status === 'resolved' ? 'r' : issue.status === 'skipped' ? 'k' : 'e', // 1 char status
                            t: issue.resolvedAt ? new Date(issue.resolvedAt).getTime() : null, // timestamp as number
                            b: issue.resolvedBy?.substring(0, 20) || null, // truncated resolvedBy
                            c: issue.confidence || null
                        };
                    }
                }
                return {
                    id: ledger.sessionId,
                    t: new Date(ledger.createdAt).getTime(),
                    i: ledger.indexName,
                    s: ledger.summary,
                    x: compressedIssues // compressed issues
                };
            },

            // Decompress ledger back to full format
            decompressLedger(compressed) {
                if (!compressed) return null;
                const statusMap = { 'r': 'resolved', 'k': 'skipped', 'e': 'error' };
                const issues = {};
                if (compressed.x) {
                    for (const [id, ci] of Object.entries(compressed.x)) {
                        issues[id] = {
                            id,
                            status: statusMap[ci.s] || 'pending',
                            resolvedAt: ci.t ? new Date(ci.t).toISOString() : null,
                            resolvedBy: ci.b,
                            confidence: ci.c,
                            changes: []
                        };
                    }
                }
                return {
                    sessionId: compressed.id,
                    createdAt: compressed.t ? new Date(compressed.t).toISOString() : null,
                    indexName: compressed.i,
                    summary: compressed.s,
                    issues
                };
            },

            // Estimate storage size of an object
            estimateSize(obj) {
                try {
                    return JSON.stringify(obj).length;
                } catch (e) {
                    return 0;
                }
            },

            // Get localStorage usage info
            getStorageInfo() {
                let used = 0;
                for (let key in localStorage) {
                    if (localStorage.hasOwnProperty(key)) {
                        used += localStorage.getItem(key).length;
                    }
                }
                // localStorage limit is typically 5MB
                const limit = 5 * 1024 * 1024;
                return { used, limit, percent: Math.round((used / limit) * 100) };
            },

            loadSavedSessions() {
                // Session history storage disabled to prevent localStorage quota errors
                state.savedSessions = [];
            },

            saveSessions(retryCount = 0) {
                // Session history storage disabled to prevent localStorage quota errors
                // Sessions are kept in memory only for the current browser session
            },

            saveCurrentSession(indexName, results, totalScanned) {
                // Create Issue Ledger for this session
                const ledger = this.createIssueLedger(results, indexName, totalScanned);
                state.issueLedger = ledger;

                // ULTRA-MINIMAL COMPRESSION
                // Only store objectIDs (strings) and a compact issue map
                const itemIds = results.map(r => r.objectID);
                const issueMap = {};
                results.forEach(r => {
                    const code = this.createIssueCode(r.issues);
                    if (code) issueMap[r.objectID] = code;
                });

                // Store duplicate info separately (needed for reload)
                const duplicateInfo = {};
                results.forEach(r => {
                    if (state.duplicatesMap.has(r.objectID)) {
                        const dup = state.duplicatesMap.get(r.objectID);
                        duplicateInfo[r.objectID] = `${dup.type}:${dup.confidence}:${(dup.value || '').substring(0, 30)}`;
                    }
                });

                const compressedLedger = this.compressLedger(ledger);

                const session = {
                    id: ledger.sessionId,
                    idx: indexName,
                    ts: Date.now(),
                    n: totalScanned,
                    // Store ledger summary for quick display
                    sum: ledger.summary,
                    cnt: results.length,
                    // ULTRA-MINIMAL: just objectIDs array
                    ids: itemIds,
                    // Compact issue codes map
                    iss: issueMap,
                    // Duplicate info
                    dup: Object.keys(duplicateInfo).length > 0 ? duplicateInfo : undefined,
                    // Compressed ledger
                    ldg: compressedLedger
                };

                // Log compression stats
                const originalSize = this.estimateSize({ results, ledger });
                const compressedSize = this.estimateSize(session);
                console.log(`üì¶ ULTRA-MINIMAL: ${(originalSize / 1024).toFixed(1)}KB ‚Üí ${(compressedSize / 1024).toFixed(1)}KB (${Math.round((1 - compressedSize / originalSize) * 100)}% reduction)`);

                // Add to beginning (most recent first)
                state.savedSessions.unshift(session);

                // Keep max 20 sessions (increased from 10 due to compression)
                if (state.savedSessions.length > 20) {
                    state.savedSessions = state.savedSessions.slice(0, 20);
                }

                state.activeSessionId = session.id;
                this.saveSessions();
                this.renderSessionList();
                this.updateLedgerUI();
            },

            renderSessionList() {
                const container = document.getElementById('session-list');
                if (!state.savedSessions.length) {
                    container.innerHTML = '<div class="no-sessions">No saved sessions yet. Run a scan to get started.</div>';
                    return;
                }

                container.innerHTML = state.savedSessions.map(session => {
                    // Handle both old and new format
                    const dateVal = session.ts || session.date;
                    const date = new Date(typeof dateVal === 'number' ? dateVal : dateVal);
                    const dateStr = date.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric' });
                    const timeStr = date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                    const isActive = session.id === state.activeSessionId;
                    const indexName = session.idx || session.indexName;
                    const totalScanned = session.n || session.totalScanned || 0;
                    const issuesFound = session.cnt || session.issuesFound || (session.ids?.length) || (session.results?.length) || 0;

                    // Use ledger summary if available (handle both formats)
                    const summary = session.sum || session.ledgerSummary || session.ldg?.s || session.ledger?.summary;
                    let statsHtml;
                    if (summary) {
                        statsHtml = `
                            <div class="session-stats">
                                <span>${totalScanned.toLocaleString()} scanned</span>
                            </div>
                            <div class="session-ledger-stats">
                                <span class="session-ledger-stat resolved">${summary.resolved} resolved</span>
                                <span class="session-ledger-stat pending">${summary.pending} pending</span>
                                ${summary.skipped > 0 ? `<span class="session-ledger-stat skipped">${summary.skipped} skipped</span>` : ''}
                            </div>
                        `;
                    } else {
                        statsHtml = `
                            <div class="session-stats">
                                <span>${totalScanned.toLocaleString()} scanned</span>
                                <span class="stat-issues">${issuesFound.toLocaleString()} issues</span>
                            </div>
                        `;
                    }

                    return `
                        <div class="session-item ${isActive ? 'active' : ''}" onclick="app.loadSession('${session.id}')">
                            <div class="session-index">${indexName}</div>
                            <div class="session-date">${dateStr} at ${timeStr}</div>
                            ${statsHtml}
                            <div class="session-actions">
                                <button class="btn-session delete" onclick="event.stopPropagation(); app.deleteSession('${session.id}')">Delete</button>
                            </div>
                        </div>
                    `;
                }).join('');
            },

            // Load session - handles both old format (full results) and new format (just IDs)
            async loadSession(sessionId) {
                const session = state.savedSessions.find(s => s.id === sessionId);
                if (!session) return;

                state.activeSessionId = sessionId;
                const indexName = session.idx || session.indexName;
                const totalScanned = session.n || session.totalScanned || 0;

                // Check if this is new ultra-minimal format (has 'ids' array)
                if (session.ids && Array.isArray(session.ids)) {
                    // NEW FORMAT - need to reload from Algolia
                    this.showToast('Loading session data from database...', 'info');

                    try {
                        const results = await this.reloadItemsFromAlgolia(
                            session.ids,
                            indexName,
                            session.iss || {},
                            session.dup || {}
                        );

                        state.scanResults = results;
                        state.currentScanIndex = indexName;
                        state.currentIssueFilter = 'all';
                        state.currentLedgerFilter = 'all';
                        state.filteredScanResults = [...results];
                        state.pendingEdits = {};
                        state.pendingDeletes = new Set();

                        // Decompress the ledger
                        if (session.ldg) {
                            state.issueLedger = this.decompressLedger(session.ldg);
                            // Ensure all items have ledger entries
                            results.forEach(r => {
                                if (!state.issueLedger.issues[r.objectID]) {
                                    state.issueLedger.issues[r.objectID] = {
                                        id: r.objectID,
                                        status: 'pending'
                                    };
                                }
                            });
                        } else {
                            state.issueLedger = this.createIssueLedger(results, indexName, totalScanned);
                        }

                        console.log(`üìÇ Loaded ${results.length} items from Algolia for session`);
                    } catch (error) {
                        console.error('Error loading session from Algolia:', error);
                        this.showToast('Error loading session data. Some items may be unavailable.', 'error');
                        state.scanResults = [];
                        state.filteredScanResults = [];
                    }
                } else {
                    // OLD FORMAT - results stored directly
                    const results = (session.results || []).map(r => {
                        if (r.name !== undefined) return r;
                        return this.decompressFoodItem(r);
                    });

                    state.scanResults = results;
                    state.currentScanIndex = indexName;
                    state.currentIssueFilter = 'all';
                    state.currentLedgerFilter = 'all';
                    state.filteredScanResults = [...results];
                    state.pendingEdits = {};
                    state.pendingDeletes = new Set();

                    // Load the Issue Ledger (or create one for legacy sessions)
                    if (session.ledger) {
                        state.issueLedger = session.ledger;
                    } else {
                        state.issueLedger = this.createIssueLedger(results, indexName, totalScanned);
                    }
                }

                // Reset pagination and selection
                state.issuesCurrentPage = 0;
                state.selectedItems = new Set();

                // Detect duplicates
                this.detectDuplicates();

                // Update UI
                document.getElementById('scan-index').value = indexName;
                document.getElementById('scan-progress').style.display = 'none';
                document.getElementById('scan-empty').style.display = 'none';
                document.getElementById('scan-results').style.display = 'block';

                // Update ledger UI
                this.updateLedgerUI();

                // Reset tab to "All"
                document.querySelectorAll('.issue-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.status === 'all');
                });

                this.renderIssuesList();
                this.updatePendingStatus();
                this.updateSelectionUI();
                this.renderSessionList();

                const dateVal = session.ts || session.date;
                this.showToast(`Loaded session from ${new Date(dateVal).toLocaleDateString()}`, 'success');
            },

            // Reload items from Algolia using objectIDs
            async reloadItemsFromAlgolia(objectIDs, indexName, issueMap, duplicateMap) {
                if (!objectIDs || objectIDs.length === 0) return [];

                const index = state.searchClient.initIndex(indexName);
                const results = [];

                // Algolia getObjects has a limit of 1000 per request
                const chunkSize = 1000;
                for (let i = 0; i < objectIDs.length; i += chunkSize) {
                    const chunk = objectIDs.slice(i, i + chunkSize);
                    try {
                        const response = await index.getObjects(chunk);
                        response.results.forEach((item, idx) => {
                            if (item) {
                                // Restore issues from issue map
                                const objectID = chunk[idx];
                                const issueCode = issueMap[objectID];
                                item.issues = issueCode ? this.decodeIssueCodes(issueCode) : [];

                                // Restore duplicate info
                                const dupInfo = duplicateMap[objectID];
                                if (dupInfo) {
                                    const [type, confidence, value] = dupInfo.split(':');
                                    state.duplicatesMap.set(objectID, {
                                        type,
                                        confidence: parseInt(confidence) || 0,
                                        value: value || ''
                                    });
                                }

                                results.push(item);
                            }
                        });
                    } catch (error) {
                        console.error(`Error fetching chunk ${i}-${i + chunkSize}:`, error);
                    }
                }

                return results;
            },

            deleteSession(sessionId) {
                if (!confirm('Delete this scan session?')) return;

                state.savedSessions = state.savedSessions.filter(s => s.id !== sessionId);

                // If we deleted the active session, clear the display
                if (state.activeSessionId === sessionId) {
                    state.activeSessionId = null;
                    state.scanResults = [];
                    state.filteredScanResults = [];
                    state.issueLedger = null;
                    document.getElementById('scan-results').style.display = 'none';
                    document.getElementById('scan-empty').style.display = 'block';
                }

                this.saveSessions();
                this.renderSessionList();
                this.showToast('Session deleted', 'info');
            },

            clearAllSessions() {
                if (!confirm('Delete all saved scan sessions?')) return;

                state.savedSessions = [];
                state.activeSessionId = null;
                state.scanResults = [];
                state.filteredScanResults = [];
                state.issueLedger = null;

                document.getElementById('scan-results').style.display = 'none';
                document.getElementById('scan-empty').style.display = 'block';

                this.saveSessions();
                this.renderSessionList();
                this.showToast('All sessions cleared', 'info');
            },

            updateActiveSession() {
                // Update the current session in storage after changes
                if (!state.activeSessionId) return;

                const session = state.savedSessions.find(s => s.id === state.activeSessionId);
                if (session) {
                    session.results = state.scanResults;
                    session.issuesFound = state.scanResults.length;

                    // Update the ledger if it exists
                    if (state.issueLedger) {
                        session.ledger = state.issueLedger;
                        session.ledgerSummary = state.issueLedger.summary;
                    }

                    this.saveSessions();
                    this.renderSessionList();
                }
            },

            // =====================
            // Email Marketing Functions
            // =====================

            async loadAuthEmails() {
                if (state.emailsLoading) return;

                // Verify authentication before calling
                if (!state.isAuthenticated || !state.currentUser) {
                    console.error('Not authenticated - cannot load emails');
                    this.showToast('Please sign in to access Email Marketing', 'error');
                    return;
                }

                console.log('Loading auth emails... User:', state.currentUser.email);
                state.emailsLoading = true;
                this.updateEmailLoadingState(true);

                try {
                    const getAuthenticatedEmails = firebase.functions().httpsCallable('getAuthenticatedEmails');
                    console.log('Calling getAuthenticatedEmails...');
                    const result = await getAuthenticatedEmails();
                    console.log('Result:', result.data);

                    if (result.data.success) {
                        state.authEmails = result.data.emails;
                        state.filteredAuthEmails = [...state.authEmails];
                        this.sortEmails();
                        this.updateEmailStats();
                        this.renderEmailTable();
                        this.showToast(`Loaded ${result.data.totalCount} authenticated users`, 'success');
                    } else {
                        throw new Error('Failed to load emails');
                    }
                } catch (error) {
                    console.error('Error loading authenticated emails:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));

                    // Better error messages
                    let errorMsg = error.message || 'Unknown error';
                    let errorTitle = 'Error Loading Emails';

                    if (error.code === 'permission-denied') {
                        const uid = state.currentUser?.uid || 'unknown';
                        errorMsg = `Admin access required. Add your UID (${uid}) to the /admins collection in Firestore.`;
                        errorTitle = 'Access Denied';
                        console.log('Your UID to add to /admins:', uid);
                    } else if (error.code === 'unauthenticated') {
                        errorMsg = 'Please sign in again.';
                        errorTitle = 'Not Authenticated';
                    } else if (error.code === 'failed-precondition') {
                        errorTitle = 'Configuration Required';
                        // Keep the error message from the server as it contains useful info
                    } else if (error.code === 'internal') {
                        // Show the server's actual error message for internal errors
                        errorTitle = 'Server Error';
                        console.error('Internal error - check Firebase Functions logs for details');
                    }

                    this.showToast('Failed to load emails: ' + errorMsg, 'error');

                    // Show error in the table container
                    const tableContainer = document.getElementById('email-table-container');
                    if (tableContainer) {
                        let helpText = '';
                        if (error.code === 'permission-denied') {
                            helpText = `<p style="margin-top: 16px; font-size: 13px; color: #6b7280;">
                                Go to Firebase Console ‚Üí Firestore ‚Üí Create document:<br>
                                <code style="background: #f3f4f6; padding: 4px 8px; border-radius: 4px;">/admins/${state.currentUser?.uid || 'YOUR_UID'}</code>
                            </p>`;
                        } else if (error.code === 'failed-precondition') {
                            helpText = `<p style="margin-top: 16px; font-size: 13px; color: #6b7280;">
                                Go to <a href="https://console.cloud.google.com/iam-admin/iam?project=nutrasafe-705c7" target="_blank" style="color: #2563eb;">GCP IAM Console</a> and add the "Firebase Authentication Admin" role to the Cloud Functions service account.
                            </p>`;
                        } else if (error.code === 'internal') {
                            helpText = `<p style="margin-top: 16px; font-size: 13px; color: #6b7280;">
                                Check <a href="https://console.firebase.google.com/project/nutrasafe-705c7/functions/logs" target="_blank" style="color: #2563eb;">Firebase Functions Logs</a> for details.
                            </p>`;
                        }

                        tableContainer.innerHTML = `<div class="error-message" style="padding: 40px; text-align: center; color: #991b1b;">
                            <h3>${errorTitle}</h3>
                            <p>${errorMsg}</p>
                            ${helpText}
                            <button onclick="app.loadAuthEmails()" class="btn btn-primary" style="margin-top: 20px;">üîÑ Retry</button>
                        </div>`;
                    }
                } finally {
                    state.emailsLoading = false;
                    this.updateEmailLoadingState(false);
                }
            },

            updateEmailLoadingState(loading) {
                const refreshBtn = document.getElementById('refresh-emails-btn');

                if (refreshBtn) {
                    refreshBtn.disabled = loading;
                    refreshBtn.innerHTML = loading ? '<span class="spinner-small"></span> Loading...' : 'üîÑ Refresh';
                }

                if (loading) {
                    const tableContainer = document.getElementById('email-table-container');
                    if (tableContainer) {
                        tableContainer.innerHTML = '<div class="loading"><div class="spinner"></div><span>Loading authenticated users...</span></div>';
                    }
                }
            },

            updateEmailStats() {
                const totalEl = document.getElementById('email-stat-total');
                const verifiedEl = document.getElementById('email-stat-verified');
                const recentEl = document.getElementById('email-stat-recent');
                const selectedEl = document.getElementById('email-stat-selected');

                if (totalEl) totalEl.textContent = state.authEmails.length;

                if (verifiedEl) {
                    const verified = state.authEmails.filter(e => e.emailVerified).length;
                    verifiedEl.textContent = verified;
                }

                if (recentEl) {
                    const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
                    const recent = state.authEmails.filter(e => {
                        if (!e.lastSignIn) return false;
                        return new Date(e.lastSignIn) > weekAgo;
                    }).length;
                    recentEl.textContent = recent;
                }

                if (selectedEl) {
                    selectedEl.textContent = state.selectedAuthEmails.size;
                }
            },

            filterEmails() {
                const query = (document.getElementById('email-search-input')?.value || '').toLowerCase().trim();
                state.emailSearchQuery = query;

                if (!query) {
                    state.filteredAuthEmails = [...state.authEmails];
                } else {
                    state.filteredAuthEmails = state.authEmails.filter(e => {
                        const email = (e.email || '').toLowerCase();
                        const name = (e.displayName || '').toLowerCase();
                        return email.includes(query) || name.includes(query);
                    });
                }

                this.sortEmails();
                this.renderEmailTable();
            },

            sortEmails() {
                const sortBy = state.emailsSortBy;
                const order = state.emailsSortOrder;

                state.filteredAuthEmails.sort((a, b) => {
                    let valA, valB;

                    if (sortBy === 'email') {
                        valA = (a.email || '').toLowerCase();
                        valB = (b.email || '').toLowerCase();
                    } else if (sortBy === 'createdAt') {
                        valA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
                        valB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
                    } else if (sortBy === 'lastSignIn') {
                        valA = a.lastSignIn ? new Date(a.lastSignIn).getTime() : 0;
                        valB = b.lastSignIn ? new Date(b.lastSignIn).getTime() : 0;
                    }

                    if (order === 'asc') {
                        return valA < valB ? -1 : valA > valB ? 1 : 0;
                    } else {
                        return valA > valB ? -1 : valA < valB ? 1 : 0;
                    }
                });
            },

            changeEmailSort(sortBy) {
                if (state.emailsSortBy === sortBy) {
                    // Toggle order
                    state.emailsSortOrder = state.emailsSortOrder === 'asc' ? 'desc' : 'asc';
                } else {
                    state.emailsSortBy = sortBy;
                    state.emailsSortOrder = 'desc';
                }
                this.sortEmails();
                this.renderEmailTable();
            },

            toggleSelectAllEmails(checked) {
                if (checked) {
                    state.filteredAuthEmails.forEach(e => state.selectedAuthEmails.add(e.uid));
                } else {
                    state.selectedAuthEmails.clear();
                }
                this.updateEmailStats();
                this.renderEmailTable();
            },

            toggleEmailSelection(uid, checked) {
                if (checked) {
                    state.selectedAuthEmails.add(uid);
                } else {
                    state.selectedAuthEmails.delete(uid);
                }
                this.updateEmailStats();

                // Update individual checkbox and select all state
                const allSelected = state.filteredAuthEmails.every(e => state.selectedAuthEmails.has(e.uid));
                const selectAllCheckbox = document.getElementById('email-select-all');
                if (selectAllCheckbox) selectAllCheckbox.checked = allSelected;
            },

            renderEmailTable() {
                const container = document.getElementById('email-table-container');
                if (!container) return;

                if (state.filteredAuthEmails.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <p>${state.authEmails.length === 0 ? 'No authenticated users found. Click Refresh to load.' : 'No emails match your search.'}</p>
                        </div>
                    `;
                    return;
                }

                const sortIcon = (col) => {
                    if (state.emailsSortBy !== col) return '';
                    return state.emailsSortOrder === 'asc' ? ' ‚Üë' : ' ‚Üì';
                };

                const allSelected = state.filteredAuthEmails.every(e => state.selectedAuthEmails.has(e.uid));

                let html = `
                    <table class="email-table">
                        <thead>
                            <tr>
                                <th style="width: 40px;">
                                    <input type="checkbox" id="email-select-all" ${allSelected ? 'checked' : ''} onchange="app.toggleSelectAllEmails(this.checked)">
                                </th>
                                <th class="sortable" onclick="app.changeEmailSort('email')">Email${sortIcon('email')}</th>
                                <th>Name</th>
                                <th class="sortable" onclick="app.changeEmailSort('createdAt')">Created${sortIcon('createdAt')}</th>
                                <th class="sortable" onclick="app.changeEmailSort('lastSignIn')">Last Sign In${sortIcon('lastSignIn')}</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                state.filteredAuthEmails.forEach(user => {
                    const isSelected = state.selectedAuthEmails.has(user.uid);
                    const createdDate = user.createdAt ? new Date(user.createdAt).toLocaleDateString() : '-';
                    const lastSignIn = user.lastSignIn ? new Date(user.lastSignIn).toLocaleDateString() : 'Never';

                    html += `
                        <tr class="${isSelected ? 'selected' : ''}">
                            <td>
                                <input type="checkbox" ${isSelected ? 'checked' : ''} onchange="app.toggleEmailSelection('${user.uid}', this.checked)">
                            </td>
                            <td class="email-cell">${this.escapeHtml(user.email)}</td>
                            <td>${this.escapeHtml(user.displayName || '-')}</td>
                            <td>${createdDate}</td>
                            <td>${lastSignIn}</td>
                            <td>
                                ${user.emailVerified ? '<span class="badge badge-success">Verified</span>' : '<span class="badge badge-warning">Unverified</span>'}
                                ${user.disabled ? '<span class="badge badge-danger">Disabled</span>' : ''}
                            </td>
                        </tr>
                    `;
                });

                html += '</tbody></table>';
                html += `<div class="email-table-footer">Showing ${state.filteredAuthEmails.length} of ${state.authEmails.length} users</div>`;
                container.innerHTML = html;
            },

            escapeHtml(text) {
                if (!text) return '';
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            exportEmailsCSV() {
                const emails = state.selectedAuthEmails.size > 0
                    ? state.authEmails.filter(e => state.selectedAuthEmails.has(e.uid))
                    : state.filteredAuthEmails;

                if (emails.length === 0) {
                    this.showToast('No emails to export', 'info');
                    return;
                }

                const headers = ['Email', 'Name', 'UID', 'Created At', 'Last Sign In', 'Email Verified', 'Disabled'];
                const rows = emails.map(e => [
                    e.email,
                    e.displayName || '',
                    e.uid,
                    e.createdAt || '',
                    e.lastSignIn || '',
                    e.emailVerified ? 'Yes' : 'No',
                    e.disabled ? 'Yes' : 'No'
                ]);

                const csvContent = [headers, ...rows]
                    .map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))
                    .join('\n');

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `nutrasafe_users_${new Date().toISOString().split('T')[0]}.csv`;
                link.click();

                this.showToast(`Exported ${emails.length} emails to CSV`, 'success');
            },

            copyEmailsToClipboard() {
                const emails = state.selectedAuthEmails.size > 0
                    ? state.authEmails.filter(e => state.selectedAuthEmails.has(e.uid))
                    : state.filteredAuthEmails;

                if (emails.length === 0) {
                    this.showToast('No emails to copy', 'info');
                    return;
                }

                const emailList = emails.map(e => e.email).join('\n');
                navigator.clipboard.writeText(emailList).then(() => {
                    this.showToast(`Copied ${emails.length} emails to clipboard`, 'success');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    this.showToast('Failed to copy to clipboard', 'error');
                });
            },

            async syncSelectedToMailchimp() {
                const emails = state.selectedAuthEmails.size > 0
                    ? state.authEmails.filter(e => state.selectedAuthEmails.has(e.uid))
                    : state.filteredAuthEmails;

                if (emails.length === 0) {
                    this.showToast('No emails to sync', 'info');
                    return;
                }

                if (!confirm(`Sync ${emails.length} emails to Mailchimp?\n\nThis will add new subscribers and update existing ones.`)) {
                    return;
                }

                const syncBtn = document.getElementById('sync-mailchimp-btn');
                if (syncBtn) {
                    syncBtn.disabled = true;
                    syncBtn.innerHTML = '<span class="spinner-small"></span> Syncing...';
                }

                try {
                    const bulkAddToMailchimp = firebase.functions().httpsCallable('bulkAddToMailchimp');
                    const result = await bulkAddToMailchimp({
                        emails: emails.map(e => ({
                            email: e.email,
                            displayName: e.displayName,
                            uid: e.uid
                        }))
                    });

                    if (result.data.success) {
                        let message = `Mailchimp sync complete!\n`;
                        message += `‚Ä¢ Added: ${result.data.addedCount}\n`;
                        message += `‚Ä¢ Updated: ${result.data.updatedCount}\n`;
                        if (result.data.errorCount > 0) {
                            message += `‚Ä¢ Errors: ${result.data.errorCount}`;
                        }
                        this.showToast(message, result.data.errorCount > 0 ? 'warning' : 'success');
                    } else {
                        throw new Error('Sync failed');
                    }
                } catch (error) {
                    console.error('Mailchimp sync error:', error);
                    this.showToast('Mailchimp sync failed: ' + error.message, 'error');
                } finally {
                    if (syncBtn) {
                        syncBtn.disabled = false;
                        syncBtn.innerHTML = 'üìß Sync to Mailchimp';
                    }
                }
            },

            // =========================================
            // TESCO DATABASE BUILDER FUNCTIONS
            // =========================================

            async refreshTescoProgress() {
                if (state.tescoBuildLoading) return;

                // Verify authentication before calling
                if (!state.isAuthenticated || !state.currentUser) {
                    console.error('Not authenticated - cannot load Tesco progress');
                    this.showToast('Please sign in to access Database Builder', 'error');
                    return;
                }

                console.log('Loading Tesco progress... User:', state.currentUser.email);
                state.tescoBuildLoading = true;
                this.updateTescoLoadingState(true);

                try {
                    const getTescoBuildProgress = firebase.functions().httpsCallable('getTescoBuildProgress');
                    const getTescoDatabaseStats = firebase.functions().httpsCallable('getTescoDatabaseStats');

                    console.log('Calling Tesco functions...');
                    // Load both progress and stats in parallel
                    const [progressResult, statsResult] = await Promise.all([
                        getTescoBuildProgress(),
                        getTescoDatabaseStats()
                    ]);
                    console.log('Tesco results:', progressResult.data, statsResult.data);

                    // getTescoBuildProgress returns the progress object directly
                    if (progressResult.data) {
                        state.tescoBuildProgress = progressResult.data;
                    }

                    // getTescoDatabaseStats returns { totalProducts, hasNutritionEstimate, recentProducts, collectionName, algoliaIndex }
                    if (statsResult.data) {
                        state.tescoStats = statsResult.data;
                    }

                    this.updateTescoUI();
                    this.updateTescoSyncStatus(); // Check Firestore vs Algolia sync status
                } catch (error) {
                    console.error('Error loading Tesco progress:', error);

                    // Better error messages
                    let errorMsg = error.message || 'Unknown error';
                    if (error.code === 'unauthenticated') {
                        errorMsg = 'Please sign in to access Database Builder.';
                    } else if (error.code === 'permission-denied') {
                        const uid = state.currentUser?.uid || 'unknown';
                        errorMsg = `Admin access required. Add UID (${uid}) to /admins collection.`;
                    }

                    this.showToast('Failed to load Tesco progress: ' + errorMsg, 'error');

                    // Show error in the UI
                    const statsEl = document.getElementById('tesco-database-stats');
                    if (statsEl) {
                        statsEl.innerHTML = `<div style="padding: 20px; text-align: center; color: #991b1b;">
                            <p><strong>Error:</strong> ${errorMsg}</p>
                            ${error.code === 'unauthenticated' ? '<p>Please sign in using the login form.</p>' : ''}
                        </div>`;
                    }
                } finally {
                    state.tescoBuildLoading = false;
                    this.updateTescoLoadingState(false);
                }
            },

            updateTescoLoadingState(loading) {
                const refreshBtn = document.getElementById('tesco-refresh-btn');
                if (refreshBtn) {
                    refreshBtn.disabled = loading;
                    refreshBtn.innerHTML = loading ? '<span class="spinner-small"></span> Loading...' : 'üîÑ Refresh';
                }
            },

            updateTescoUI() {
                const progress = state.tescoBuildProgress;
                const stats = state.tescoStats;

                // Update stats from getTescoDatabaseStats response
                const statTotal = document.getElementById('tesco-stat-total');
                const statNutrition = document.getElementById('tesco-stat-nutrition');
                const statFound = document.getElementById('tesco-stat-found');
                const statSkipped = document.getElementById('tesco-stat-skipped');
                const statErrors = document.getElementById('tesco-stat-errors');
                const lastUpdatedEl = document.getElementById('tesco-last-updated');
                const liveFeed = document.getElementById('tesco-live-feed');
                const currentActivityText = document.getElementById('current-activity-text');
                const currentActivityDetail = document.getElementById('current-activity-detail');

                // Show productsSaved from progress when available, otherwise use stats count
                if (statTotal) {
                    statTotal.textContent = progress?.productsSaved ?? stats?.totalProducts ?? 0;
                }

                // Update progress section
                const statusBadge = document.getElementById('tesco-status-badge');
                const progressBar = document.getElementById('tesco-progress-bar');
                const progressText = document.getElementById('tesco-progress-text');
                const currentTermEl = document.getElementById('tesco-current-term');

                if (progress) {
                    // Check for progress changes and log them
                    this.checkProgressChanges(progress);

                    // Update previous progress for next comparison
                    state.tescoPreviousProgress = { ...progress };

                    // Update last update time for stall detection
                    if (progress.lastUpdated) {
                        const newUpdateTime = new Date(progress.lastUpdated).getTime();
                        if (newUpdateTime !== state.tescoLastUpdateTime) {
                            state.tescoLastUpdateTime = newUpdateTime;
                        }
                    }

                    // Show status
                    const status = progress.status || 'idle';
                    if (statusBadge) {
                        statusBadge.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                        statusBadge.className = 'status-badge status-' + status;
                    }

                    // Update API source selector and status
                    const apiSourceSelect = document.getElementById('tesco-api-source');
                    const apiStatusEl = document.getElementById('tesco-api-status');
                    const currentApiSource = progress.apiSource || 'tesco8';
                    if (apiSourceSelect) {
                        apiSourceSelect.value = currentApiSource;
                        // Disable selector while build is running
                        apiSourceSelect.disabled = (status === 'running' || status === 'paused');
                    }
                    // API display name mapping
                    const apiDisplayNames = {
                        'tesco8': 'Tesco',
                        'uk_groceries': 'UK Groceries',
                        'spoonacular': 'Spoonacular'
                    };
                    const apiDisplayName = apiDisplayNames[currentApiSource] || 'Tesco';

                    if (apiStatusEl) {
                        if (status === 'running' || status === 'paused') {
                            apiStatusEl.textContent = `Currently using: ${apiDisplayName}`;
                        } else {
                            apiStatusEl.textContent = '';
                        }
                    }

                    // Show/hide live feed based on status
                    if (liveFeed) {
                        liveFeed.style.display = status === 'running' ? 'block' : 'none';
                    }

                    // Update live feed current activity
                    if (status === 'running' && currentActivityText) {
                        if (progress.currentTerm) {
                            currentActivityText.textContent = `Searching ${apiDisplayName} for "${progress.currentTerm}"`;
                            const termsRemaining = (progress.totalTerms || 0) - (progress.currentTermIndex || 0);
                            currentActivityDetail.textContent = `Term ${progress.currentTermIndex || 0} of ${progress.totalTerms || 0} ‚Ä¢ ${termsRemaining} remaining`;
                        } else {
                            currentActivityText.textContent = 'Processing...';
                            currentActivityDetail.textContent = '';
                        }
                    }

                    // Update progress bar
                    const totalTerms = progress.totalTerms || 1;
                    const currentTermIndex = progress.currentTermIndex || 0;
                    const percentage = Math.round((currentTermIndex / totalTerms) * 100);

                    if (progressBar) progressBar.style.width = percentage + '%';
                    if (progressText) progressText.textContent = `${currentTermIndex} / ${totalTerms} search terms processed`;

                    // Update details
                    if (currentTermEl) {
                        currentTermEl.textContent = progress.currentTerm ? `Searching: "${progress.currentTerm}"` : 'Not started';
                    }

                    // Update stat cards from progress
                    if (statNutrition) statNutrition.textContent = progress.productsWithNutrition || 0;
                    if (statFound) statFound.textContent = progress.productsFound || 0;
                    if (statSkipped) statSkipped.textContent = progress.duplicatesSkipped || 0;
                    if (statErrors) statErrors.textContent = progress.errors || 0;

                    // Update last updated
                    if (lastUpdatedEl && progress.lastUpdated) {
                        lastUpdatedEl.textContent = 'Updated: ' + new Date(progress.lastUpdated).toLocaleString();
                    }

                    // Show/hide buttons based on status
                    const startBtn = document.getElementById('tesco-start-btn');
                    const pauseBtn = document.getElementById('tesco-pause-btn');
                    const stopBtn = document.getElementById('tesco-stop-btn');
                    const resumeBtn = document.getElementById('tesco-resume-btn');

                    if (status === 'running') {
                        if (startBtn) startBtn.style.display = 'none';
                        if (pauseBtn) pauseBtn.style.display = 'inline-flex';
                        if (stopBtn) stopBtn.style.display = 'inline-flex';
                        if (resumeBtn) resumeBtn.style.display = 'none';
                    } else if (status === 'paused') {
                        if (startBtn) startBtn.style.display = 'none';
                        if (pauseBtn) pauseBtn.style.display = 'none';
                        if (stopBtn) stopBtn.style.display = 'inline-flex';
                        if (resumeBtn) resumeBtn.style.display = 'inline-flex';
                    } else if (status === 'completed') {
                        if (startBtn) {
                            startBtn.style.display = 'inline-flex';
                            startBtn.innerHTML = 'üîÑ Restart Build';
                        }
                        if (pauseBtn) pauseBtn.style.display = 'none';
                        if (stopBtn) stopBtn.style.display = 'none';
                        if (resumeBtn) resumeBtn.style.display = 'none';
                    } else {
                        if (startBtn) {
                            startBtn.style.display = 'inline-flex';
                            startBtn.innerHTML = '‚ñ∂Ô∏è Start Build';
                        }
                        if (pauseBtn) pauseBtn.style.display = 'none';
                        if (stopBtn) stopBtn.style.display = 'none';
                        if (resumeBtn) resumeBtn.style.display = 'none';
                    }

                    // Render recently found products from progress (during active build)
                    if (progress.recentlyFoundProducts && progress.recentlyFoundProducts.length > 0) {
                        this.renderTescoRecentProducts(progress.recentlyFoundProducts, true);
                    } else if (stats?.recentProducts) {
                        // Fall back to stats recent products if no active build products
                        this.renderTescoRecentProducts(stats.recentProducts, false);
                    }

                    // Show errors if any
                    if (progress.errors > 0 && progress.errorMessages?.length > 0) {
                        this.renderTescoErrors(progress.errorMessages);
                    }
                } else {
                    // Hide live feed when no progress
                    if (liveFeed) liveFeed.style.display = 'none';

                    if (statusBadge) {
                        statusBadge.textContent = 'Not Started';
                        statusBadge.className = 'status-badge status-idle';
                    }
                    if (progressBar) progressBar.style.width = '0%';
                    if (progressText) progressText.textContent = '0 / 0 search terms processed';
                    if (currentTermEl) currentTermEl.textContent = 'Not started';
                    if (statNutrition) statNutrition.textContent = '0';
                    if (statFound) statFound.textContent = '0';
                    if (statSkipped) statSkipped.textContent = '0';
                    if (statErrors) statErrors.textContent = '0';
                    if (lastUpdatedEl) lastUpdatedEl.textContent = '-';

                    // Show start button only
                    const startBtn = document.getElementById('tesco-start-btn');
                    const pauseBtn = document.getElementById('tesco-pause-btn');
                    const stopBtn = document.getElementById('tesco-stop-btn');
                    const resumeBtn = document.getElementById('tesco-resume-btn');
                    if (startBtn) startBtn.style.display = 'inline-flex';
                    if (pauseBtn) pauseBtn.style.display = 'none';
                    if (stopBtn) stopBtn.style.display = 'none';
                    if (resumeBtn) resumeBtn.style.display = 'none';
                }
            },

            renderTescoRecentProducts(recentProducts, isFromActiveBuild = false) {
                const container = document.getElementById('tesco-recent-products');
                if (!container) return;

                if (!recentProducts || recentProducts.length === 0) {
                    container.innerHTML = '<p class="empty-state">No products yet. Start the build to begin.</p>';
                    return;
                }

                const headerText = isFromActiveBuild
                    ? `üîÑ Products Found This Session (${recentProducts.length})`
                    : 'üì¶ Recently Saved Products';

                let html = `
                    <div class="recent-products-header" style="margin-bottom: 10px; font-size: 13px; color: ${isFromActiveBuild ? '#059669' : '#6b7280'};">
                        ${headerText}
                    </div>
                    <div class="recent-products-grid">
                `;
                recentProducts.forEach(product => {
                    const hasNutrition = product.hasNutrition ? '‚úÖ' : '‚ùå';
                    const timeAgo = product.savedAt ? this.formatTimeAgo(product.savedAt) : '';
                    html += `
                        <div class="recent-product-card" style="border-left: 3px solid ${product.hasNutrition ? '#059669' : '#f59e0b'};">
                            <div class="product-title">${this.escapeHtml(product.title)}</div>
                            <div class="product-meta">
                                <span class="product-brand">${this.escapeHtml(product.brand || 'Tesco')}</span>
                                <span class="product-nutrition">${hasNutrition} Nutrition</span>
                                ${timeAgo ? `<span class="product-time" style="color: #9ca3af; font-size: 11px;">${timeAgo}</span>` : ''}
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                container.innerHTML = html;
            },

            formatTimeAgo(dateString) {
                const now = new Date();
                const date = new Date(dateString);
                const seconds = Math.floor((now - date) / 1000);

                if (seconds < 60) return 'just now';
                if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
                if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
                return `${Math.floor(seconds / 86400)}d ago`;
            },

            renderTescoErrors(errorMessages) {
                const section = document.getElementById('tesco-errors-section');
                const log = document.getElementById('tesco-error-log');
                if (!section || !log) return;

                section.style.display = 'block';
                // Show more errors (last 25) with better formatting
                const errors = errorMessages.slice(-25);
                log.innerHTML = `
                    <p style="margin-bottom: 10px; color: #6b7280; font-size: 12px;">
                        Showing last ${errors.length} of ${errorMessages.length} errors
                    </p>
                    ${errors.map(msg =>
                        `<div class="error-entry" style="padding: 8px; margin-bottom: 4px; background: #fff; border-left: 3px solid #ef4444; font-size: 12px;">${this.escapeHtml(msg)}</div>`
                    ).join('')}
                `;
            },

            renderTescoCompletedTerms(completedTerms) {
                const container = document.getElementById('tesco-completed-terms');
                if (!container) return;

                if (completedTerms.length === 0) {
                    container.innerHTML = '<p class="text-muted">No terms completed yet</p>';
                    return;
                }

                // Show last 20 completed terms
                const recentTerms = completedTerms.slice(-20).reverse();

                let html = '<div class="completed-terms-list">';
                recentTerms.forEach(term => {
                    html += `<span class="term-badge">${this.escapeHtml(term)}</span>`;
                });
                html += '</div>';

                if (completedTerms.length > 20) {
                    html += `<p class="text-muted">... and ${completedTerms.length - 20} more</p>`;
                }

                container.innerHTML = html;
            },

            async startTescoBuild(forceReset = false) {
                // Get selected API source FIRST (before confirmation dialog)
                const apiSourceSelect = document.getElementById('tesco-api-source');
                const apiSource = apiSourceSelect ? apiSourceSelect.value : 'tesco8';

                // API-specific labels for confirmation dialog
                const apiLabels = {
                    'tesco8': { name: 'Tesco', desc: 'Tesco food categories' },
                    'uk_groceries': { name: 'UK Groceries', desc: 'UK grocery products' },
                    'spoonacular': { name: 'Spoonacular', desc: 'British recipes with nutrition' }
                };
                const apiLabel = apiLabels[apiSource] || apiLabels['tesco8'];

                // Check current build status
                const currentStatus = state.tescoBuildProgress?.status;

                // If build is completed, ask if they want to restart
                if (currentStatus === 'completed' && !forceReset) {
                    if (!confirm('The build has already completed.\n\nDo you want to restart the build from the beginning?\n\n(Products already in the database will be kept)')) {
                        return;
                    }
                    forceReset = true;
                } else if (!forceReset) {
                    if (!confirm(`Start building from ${apiLabel.name}?\n\nThis will scan ${apiLabel.desc} and save products to your database. You can pause at any time.`)) {
                        return;
                    }
                }

                const startBtn = document.getElementById('tesco-start-btn');
                if (startBtn) {
                    startBtn.disabled = true;
                    startBtn.innerHTML = '<span class="spinner-small"></span> Starting...';
                }

                try {
                    console.log('[START] Calling startTescoBuild function... reset:', forceReset, 'apiSource:', apiSource);
                    const startTescoBuild = firebase.functions().httpsCallable('startTescoBuild');
                    const result = await startTescoBuild({ reset: forceReset, apiSource: apiSource });
                    console.log('[START] Result:', result.data);

                    if (result.data.success) {
                        this.showToast('Database build started!', 'success');

                        // Initialize activity log and restart timers
                        state.tescoActivityLog = [];
                        state.tescoLastUpdateTime = Date.now();
                        state.tescoPreviousProgress = null;
                        state.tescoLastPeriodicRestart = Date.now(); // Reset periodic timer
                        state.tescoAutoRestartCount = 0; // Reset restart count for new build
                        state.tescoStopRequested = false; // Clear stop flag for new build
                        state.tescoAutoRestartEnabled = true; // Re-enable auto-restart
                        this.addActivityLogEntry('Build started', 'success');

                        // Update the toggle in the UI
                        const autoRestartToggle = document.getElementById('tesco-auto-restart-toggle');
                        if (autoRestartToggle) {
                            autoRestartToggle.checked = true;
                        }

                        // Start polling for progress
                        this.startTescoProgressPolling();
                    } else {
                        // Use message field (not error field) from function response
                        const errorMsg = result.data.message || result.data.error || 'Failed to start build';
                        console.warn('[START] Build not started:', errorMsg, result.data);

                        // If the build is completed and user hasn't tried reset yet, offer to restart
                        if (errorMsg.includes('completed') && !forceReset) {
                            if (confirm('Build is already completed. Would you like to restart from the beginning?')) {
                                return this.startTescoBuild(true);
                            }
                        }
                        throw new Error(errorMsg);
                    }
                } catch (error) {
                    console.error('Error starting Tesco build:', error);
                    this.showToast('Failed to start build: ' + error.message, 'error');
                } finally {
                    if (startBtn) {
                        startBtn.disabled = false;
                        startBtn.innerHTML = '‚ñ∂Ô∏è Start Build';
                    }
                    this.refreshTescoProgress();
                }
            },

            async pauseTescoBuild() {
                const pauseBtn = document.getElementById('tesco-pause-btn');
                if (pauseBtn) {
                    pauseBtn.disabled = true;
                    pauseBtn.innerHTML = '<span class="spinner-small"></span> Pausing...';
                }

                try {
                    const pauseTescoBuild = firebase.functions().httpsCallable('pauseTescoBuild');
                    const result = await pauseTescoBuild();

                    if (result.data.success) {
                        this.showToast('Database build paused. Progress saved.', 'success');
                        this.addActivityLogEntry('Build paused by user', 'info');
                        this.stopTescoProgressPolling();
                    } else {
                        throw new Error(result.data.error || 'Failed to pause build');
                    }
                } catch (error) {
                    console.error('Error pausing Tesco build:', error);
                    this.showToast('Failed to pause: ' + error.message, 'error');
                } finally {
                    if (pauseBtn) {
                        pauseBtn.disabled = false;
                        pauseBtn.innerHTML = '‚è∏Ô∏è Pause';
                    }
                    this.refreshTescoProgress();
                }
            },

            async stopTescoBuild() {
                const stopBtn = document.getElementById('tesco-stop-btn');
                if (stopBtn) {
                    stopBtn.disabled = true;
                    stopBtn.innerHTML = '<span class="spinner-small"></span> Stopping...';
                }

                // IMMEDIATELY disable auto-restart to prevent it from restarting
                state.tescoAutoRestartEnabled = false;
                state.tescoAutoRestarting = false;
                state.tescoStopRequested = true; // New flag to block any pending restart

                // Update the toggle in the UI
                const autoRestartToggle = document.getElementById('tesco-auto-restart-toggle');
                if (autoRestartToggle) {
                    autoRestartToggle.checked = false;
                }

                // Stop polling IMMEDIATELY
                this.stopTescoProgressPolling();

                try {
                    const stopTescoBuild = firebase.functions().httpsCallable('stopTescoBuild');
                    const result = await stopTescoBuild();

                    if (result.data.success) {
                        this.showToast('Database build STOPPED completely. Auto-restart disabled.', 'success');
                        this.addActivityLogEntry('Build STOPPED - auto-restart disabled', 'warning');
                    } else {
                        throw new Error(result.data.error || 'Failed to stop build');
                    }
                } catch (error) {
                    console.error('Error stopping Tesco build:', error);
                    this.showToast('Failed to stop: ' + error.message, 'error');
                } finally {
                    if (stopBtn) {
                        stopBtn.disabled = false;
                        stopBtn.innerHTML = '‚èπÔ∏è Stop';
                    }
                    this.refreshTescoProgress();
                }
            },

            async resumeTescoBuild() {
                const resumeBtn = document.getElementById('tesco-resume-btn');
                if (resumeBtn) {
                    resumeBtn.disabled = true;
                    resumeBtn.innerHTML = '<span class="spinner-small"></span> Resuming...';
                }

                try {
                    // Get selected API source for resume
                    const apiSourceSelect = document.getElementById('tesco-api-source');
                    const apiSource = apiSourceSelect ? apiSourceSelect.value : 'tesco8';

                    const startTescoBuild = firebase.functions().httpsCallable('startTescoBuild');
                    const result = await startTescoBuild({ apiSource: apiSource }); // Pass API source on resume

                    if (result.data.success) {
                        this.showToast('Database build resumed!', 'success');

                        // Initialize tracking if not already
                        if (!state.tescoLastUpdateTime) {
                            state.tescoLastUpdateTime = Date.now();
                        }
                        this.addActivityLogEntry('Build resumed', 'success');

                        this.startTescoProgressPolling();
                    } else {
                        throw new Error(result.data.error || 'Failed to resume build');
                    }
                } catch (error) {
                    console.error('Error resuming Tesco build:', error);
                    this.showToast('Failed to resume: ' + error.message, 'error');
                } finally {
                    if (resumeBtn) {
                        resumeBtn.disabled = false;
                        resumeBtn.innerHTML = '‚ñ∂Ô∏è Resume';
                    }
                    this.refreshTescoProgress();
                }
            },

            async resetTescoDatabase() {
                if (!confirm('‚ö†Ô∏è WARNING: This will delete ALL Tesco products and reset the build progress.\n\nAre you sure?')) {
                    return;
                }

                if (!confirm('This action cannot be undone. Type "RESET" mentally and click OK to confirm.')) {
                    return;
                }

                const resetBtn = document.getElementById('tesco-reset-btn');
                if (resetBtn) {
                    resetBtn.disabled = true;
                    resetBtn.innerHTML = '<span class="spinner-small"></span> Resetting...';
                }

                try {
                    const resetTescoDatabase = firebase.functions().httpsCallable('resetTescoDatabase');
                    const result = await resetTescoDatabase({ confirm: true });

                    if (result.data.success) {
                        this.showToast('Database reset complete', 'success');
                        this.stopTescoProgressPolling();
                    } else {
                        throw new Error(result.data.error || 'Failed to reset database');
                    }
                } catch (error) {
                    console.error('Error resetting Tesco database:', error);
                    this.showToast('Failed to reset: ' + error.message, 'error');
                } finally {
                    if (resetBtn) {
                        resetBtn.disabled = false;
                        resetBtn.innerHTML = 'üóëÔ∏è Reset Database';
                    }
                    this.refreshTescoProgress();
                }
            },

            async syncTescoToAlgolia() {
                const syncBtn = document.getElementById('tesco-sync-btn');
                if (syncBtn) {
                    syncBtn.disabled = true;
                    syncBtn.innerHTML = '<span class="spinner-small"></span> Syncing...';
                }

                try {
                    this.showToast('Syncing Tesco products to Algolia... This may take a while.', 'info');

                    const syncTescoToAlgolia = firebase.functions().httpsCallable('syncTescoToAlgolia', { timeout: 540000 });
                    const result = await syncTescoToAlgolia({});

                    if (result.data.success) {
                        this.showToast(`Synced ${result.data.synced} Tesco products to Algolia!`, 'success');
                        // Refresh index counts after sync
                        this.updateIndexCounts();
                        this.updateTescoSyncStatus();
                    } else {
                        throw new Error(result.data.error || 'Failed to sync');
                    }
                } catch (error) {
                    console.error('Error syncing Tesco to Algolia:', error);
                    this.showToast('Failed to sync: ' + error.message, 'error');
                } finally {
                    if (syncBtn) {
                        syncBtn.disabled = false;
                        syncBtn.innerHTML = 'üîÑ Sync to Algolia';
                    }
                }
            },

            // Update Tesco sync status (Firestore vs Algolia count)
            async updateTescoSyncStatus() {
                const statusEl = document.getElementById('tesco-sync-status');
                if (!statusEl) return;

                try {
                    // Get Firestore count from stats
                    const firestoreCount = state.tescoStats?.totalProducts || 0;

                    // Get Algolia count
                    const tescoIndex = algoliaClient.initIndex('tesco_products');
                    const algoliaResult = await tescoIndex.search('', { hitsPerPage: 0 });
                    const algoliaCount = algoliaResult.nbHits;

                    if (firestoreCount === algoliaCount) {
                        statusEl.innerHTML = `<span style="color: #16a34a;">‚úì Synced (${firestoreCount.toLocaleString()} products)</span>`;
                    } else {
                        const diff = firestoreCount - algoliaCount;
                        statusEl.innerHTML = `<span style="color: #dc2626;">‚ö† Out of sync: Firestore: ${firestoreCount.toLocaleString()}, Algolia: ${algoliaCount.toLocaleString()} (${diff > 0 ? '+' : ''}${diff.toLocaleString()} missing)</span>`;
                    }
                } catch (error) {
                    console.error('Error checking sync status:', error);
                    statusEl.innerHTML = '<span style="color: #6b7280;">Unable to check sync status</span>';
                }
            },

            // Real-time Firestore listener for live updates
            tescoProgressUnsubscribe: null,
            tescoTimeSinceUpdateInterval: null,
            tescoRealtimeConnected: false,
            tescoPollingInterval: null,
            tescoStaleCheckInterval: null,
            tescoLastDataTimestamp: null, // Track when we last got new data from Firebase

            startTescoRealtimeListener() {
                this.stopTescoRealtimeListener(); // Clear any existing

                // Subscribe to real-time updates from Firestore
                const db = firebase.firestore();
                const progressRef = db.collection('system').doc('tescoBuildProgress');

                console.log('[REALTIME] Starting Firestore listener for tescoBuildProgress...');

                this.tescoProgressUnsubscribe = progressRef.onSnapshot(
                    (doc) => {
                        if (doc.exists) {
                            const progress = doc.data();
                            console.log('[REALTIME] Progress update received:', progress.status, progress.productsSaved);

                            // Track when we received this update
                            this.tescoLastDataTimestamp = Date.now();

                            // Update state
                            state.tescoBuildProgress = progress;
                            this.tescoRealtimeConnected = true;

                            // Update last update time from the progress data
                            if (progress.lastUpdated) {
                                state.tescoLastUpdateTime = new Date(progress.lastUpdated).getTime();
                            }

                            // Update the UI immediately
                            this.updateTescoUI();

                            // Update connection indicator
                            this.updateRealtimeIndicator(true);
                        }
                    },
                    (error) => {
                        console.error('[REALTIME] Firestore listener error:', error);
                        this.tescoRealtimeConnected = false;
                        this.updateRealtimeIndicator(false);

                        // Fall back to polling on error
                        console.log('[REALTIME] Falling back to polling due to error');
                        this.startFallbackPolling();
                    }
                );

                // Update "time since" display every second + check for stale data
                this.tescoTimeSinceUpdateInterval = setInterval(() => {
                    this.updateTimeSinceDisplay();
                }, 1000);

                // Check for stale data every 10 seconds - if no updates for 60s, force refresh
                this.tescoStaleCheckInterval = setInterval(() => {
                    this.checkForStaleData();
                }, 10000);

                // Initial stats load (real-time listener doesn't cover stats)
                this.loadTescoStats();
            },

            // Check if data is stale (no updates for 60 seconds) and force refresh
            checkForStaleData() {
                const buildStatus = state.tescoBuildProgress?.status;
                if (buildStatus !== 'running') return; // Only check during active builds

                const now = Date.now();
                const lastUpdate = state.tescoLastUpdateTime || 0;
                const timeSinceUpdate = now - lastUpdate;

                // If no update for 60 seconds, force a refresh via Firebase Functions
                if (timeSinceUpdate > 60000) {
                    console.log(`[STALE] No updates for ${Math.round(timeSinceUpdate/1000)}s - forcing refresh...`);
                    this.addActivityLogEntry(`Stale data detected (${Math.round(timeSinceUpdate/1000)}s) - refreshing...`, 'warning');
                    this.refreshTescoProgress();
                }
            },

            stopTescoRealtimeListener() {
                if (this.tescoProgressUnsubscribe) {
                    this.tescoProgressUnsubscribe();
                    this.tescoProgressUnsubscribe = null;
                    console.log('[REALTIME] Firestore listener stopped');
                }
                if (this.tescoTimeSinceUpdateInterval) {
                    clearInterval(this.tescoTimeSinceUpdateInterval);
                    this.tescoTimeSinceUpdateInterval = null;
                }
                if (this.tescoStaleCheckInterval) {
                    clearInterval(this.tescoStaleCheckInterval);
                    this.tescoStaleCheckInterval = null;
                }
                if (this.tescoPollingInterval) {
                    clearInterval(this.tescoPollingInterval);
                    this.tescoPollingInterval = null;
                }
                this.tescoRealtimeConnected = false;
                this.updateRealtimeIndicator(false);
            },

            // Fallback polling if real-time fails
            startFallbackPolling() {
                if (this.tescoPollingInterval) return;
                console.log('[POLLING] Starting fallback polling every 3 seconds');
                this.tescoPollingInterval = setInterval(() => {
                    if (state.currentView === 'tesco-builder') {
                        this.refreshTescoProgress();
                    }
                }, 3000);
            },

            // Load stats separately (not covered by real-time listener)
            async loadTescoStats() {
                try {
                    const getTescoDatabaseStats = firebase.functions().httpsCallable('getTescoDatabaseStats');
                    const statsResult = await getTescoDatabaseStats();
                    if (statsResult.data) {
                        state.tescoStats = statsResult.data;
                        this.updateTescoUI();
                    }
                } catch (error) {
                    console.error('Error loading Tesco stats:', error);
                }
            },

            // Update the real-time connection indicator
            updateRealtimeIndicator(connected) {
                const indicator = document.getElementById('realtime-indicator');
                if (indicator) {
                    if (connected) {
                        indicator.innerHTML = '<span class="realtime-dot connected"></span> Live';
                        indicator.className = 'realtime-indicator connected';
                        indicator.title = 'Real-time updates active';
                    } else {
                        indicator.innerHTML = '<span class="realtime-dot disconnected"></span> Polling';
                        indicator.className = 'realtime-indicator disconnected';
                        indicator.title = 'Using polling for updates';
                    }
                }
            },

            // Legacy method for compatibility - now uses hybrid approach
            startTescoProgressPolling() {
                // Try real-time first, but also start polling as backup
                this.startTescoRealtimeListener();

                // Also start a slower polling interval as insurance
                if (!this.tescoPollingInterval) {
                    this.tescoPollingInterval = setInterval(() => {
                        if (state.currentView === 'tesco-builder') {
                            // Only poll if real-time isn't working or data seems stale
                            const timeSinceData = Date.now() - (this.tescoLastDataTimestamp || 0);
                            if (!this.tescoRealtimeConnected || timeSinceData > 30000) {
                                console.log('[POLLING] Backup poll triggered');
                                this.refreshTescoProgress();
                            }
                        }
                    }, 5000); // Poll every 5 seconds as backup
                }
            },

            stopTescoProgressPolling() {
                this.stopTescoRealtimeListener();
            },

            // Update the "time since last update" display
            updateTimeSinceDisplay() {
                if (!state.tescoLastUpdateTime) return;

                const now = Date.now();
                const elapsed = now - state.tescoLastUpdateTime;
                const seconds = Math.floor(elapsed / 1000);

                const timeEl = document.getElementById('time-since-update');
                const stallWarning = document.getElementById('stall-warning');
                const liveIndicator = document.getElementById('live-indicator');
                const liveFeed = document.getElementById('tesco-live-feed');

                if (timeEl) {
                    let timeText;
                    if (seconds < 5) {
                        timeText = 'Updated just now';
                        timeEl.className = 'time-since-update';
                    } else if (seconds < 60) {
                        timeText = `Updated ${seconds}s ago`;
                        timeEl.className = 'time-since-update';
                    } else {
                        const mins = Math.floor(seconds / 60);
                        timeText = `Updated ${mins}m ${seconds % 60}s ago`;
                        timeEl.className = seconds > 90 ? 'time-since-update danger' : 'time-since-update warning';
                    }
                    timeEl.textContent = timeText;
                }

                // Show stall warning after threshold
                const isStalled = elapsed > state.tescoStallThreshold;
                const shouldAutoRestart = elapsed > state.tescoAutoRestartThreshold;

                if (stallWarning) {
                    stallWarning.className = isStalled ? 'stall-warning visible' : 'stall-warning';
                    if (isStalled) {
                        const mins = Math.floor(elapsed / 60000);
                        const secs = Math.floor((elapsed % 60000) / 1000);
                        const stallText = document.getElementById('stall-warning-text');
                        if (stallText) {
                            if (state.tescoAutoRestartEnabled && !state.tescoAutoRestarting) {
                                const timeToRestart = Math.max(0, Math.ceil((state.tescoAutoRestartThreshold - elapsed) / 1000));
                                if (timeToRestart > 0) {
                                    stallText.textContent = `No updates for ${mins}m ${secs}s. Auto-restart in ${timeToRestart}s...`;
                                } else {
                                    stallText.textContent = `No updates for ${mins}m ${secs}s. Auto-restarting...`;
                                }
                            } else if (state.tescoAutoRestarting) {
                                stallText.textContent = `Restarting build... please wait`;
                            } else {
                                stallText.textContent = `No updates for ${mins}m ${secs}s. The build may be stalled. Click Pause then Resume to restart.`;
                            }
                        }
                    }
                }
                if (liveIndicator) {
                    liveIndicator.className = isStalled ? 'live-indicator stalled' : 'live-indicator';
                }
                if (liveFeed) {
                    liveFeed.className = isStalled ? 'tesco-live-feed stalled' : 'tesco-live-feed';
                }

                // Auto-restart logic
                const buildStatus = state.tescoBuildProgress?.status;
                const timeSinceLastRestart = state.tescoLastAutoRestart
                    ? (now - state.tescoLastAutoRestart)
                    : Infinity;
                const cooldownMet = timeSinceLastRestart > state.tescoAutoRestartCooldown;

                // Periodic restart check (every 5 minutes regardless of stall)
                const timeSincePeriodicRestart = state.tescoLastPeriodicRestart
                    ? (now - state.tescoLastPeriodicRestart)
                    : Infinity;
                const periodicRestartDue = timeSincePeriodicRestart > state.tescoPeriodicRestartInterval;

                // Debug logging for auto-restart
                if (elapsed > 30000 || periodicRestartDue) {
                    console.log(`[Auto-Restart Check] elapsed=${Math.round(elapsed/1000)}s, threshold=${state.tescoAutoRestartThreshold/1000}s, periodicDue=${periodicRestartDue}, enabled=${state.tescoAutoRestartEnabled}, restarting=${state.tescoAutoRestarting}, status=${buildStatus}`);
                }

                // Restart if stalled OR periodic restart is due
                const shouldRestart = (shouldAutoRestart || periodicRestartDue) &&
                    state.tescoAutoRestartEnabled &&
                    !state.tescoAutoRestarting &&
                    buildStatus === 'running' &&
                    cooldownMet;

                if (shouldRestart) {
                    const reason = periodicRestartDue ? 'periodic refresh' : 'stall detected';
                    console.log(`[Auto-Restart] Triggering auto-restart now! Reason: ${reason}`);
                    this.autoRestartTescoBuild(reason);
                }
            },

            // Add entry to activity log
            addActivityLogEntry(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString('en-GB');
                state.tescoActivityLog.unshift({ timestamp, message, type });

                // Keep only last 50 entries
                if (state.tescoActivityLog.length > 50) {
                    state.tescoActivityLog = state.tescoActivityLog.slice(0, 50);
                }

                this.renderActivityLog();
            },

            renderActivityLog() {
                const container = document.getElementById('activity-log');
                if (!container) return;

                if (state.tescoActivityLog.length === 0) {
                    container.innerHTML = `
                        <div class="activity-log-entry info">
                            <span class="timestamp">[--:--:--]</span>
                            Waiting for build to start...
                        </div>`;
                    return;
                }

                container.innerHTML = state.tescoActivityLog.map(entry => `
                    <div class="activity-log-entry ${entry.type}">
                        <span class="timestamp">[${entry.timestamp}]</span>
                        ${entry.message}
                    </div>
                `).join('');
            },

            // Check for progress changes and log them
            checkProgressChanges(newProgress) {
                const prev = state.tescoPreviousProgress;
                if (!prev || !newProgress) return;

                // Detect new products
                if (newProgress.productsSaved > prev.productsSaved) {
                    const diff = newProgress.productsSaved - prev.productsSaved;
                    this.addActivityLogEntry(`+${diff} product${diff > 1 ? 's' : ''} saved to database`, 'success');
                }

                // Detect search term change
                if (newProgress.currentTerm && newProgress.currentTerm !== prev.currentTerm) {
                    this.addActivityLogEntry(`Searching: "${newProgress.currentTerm}"`, 'info');
                }

                // Detect errors
                if (newProgress.errors > prev.errors) {
                    const diff = newProgress.errors - prev.errors;
                    this.addActivityLogEntry(`${diff} error${diff > 1 ? 's' : ''} occurred`, 'error');
                }

                // Detect duplicates skipped
                if (newProgress.duplicatesSkipped > prev.duplicatesSkipped) {
                    const diff = newProgress.duplicatesSkipped - prev.duplicatesSkipped;
                    this.addActivityLogEntry(`Skipped ${diff} duplicate${diff > 1 ? 's' : ''}`, 'info');
                }
            },

            // Toggle auto-restart feature
            toggleAutoRestart(enabled) {
                state.tescoAutoRestartEnabled = enabled;
                console.log('Auto-restart:', enabled ? 'enabled' : 'disabled');

                if (enabled) {
                    this.addActivityLogEntry('Auto-restart enabled (90s threshold)', 'info');
                } else {
                    this.addActivityLogEntry('Auto-restart disabled', 'info');
                }
            },

            // Auto-restart the build when stalled or periodically
            async autoRestartTescoBuild(reason = 'stall detected') {
                if (state.tescoAutoRestarting) {
                    console.log('[Auto-Restart] Already restarting, skipping');
                    return;
                }

                console.log(`[Auto-Restart] === Starting auto-restart process (${reason}) ===`);
                state.tescoAutoRestarting = true;
                state.tescoLastAutoRestart = Date.now();
                state.tescoLastPeriodicRestart = Date.now(); // Reset periodic timer too
                state.tescoAutoRestartCount++;

                // Stop polling during restart to prevent interference
                this.stopTescoProgressPolling();
                console.log('[Auto-Restart] Stopped polling');

                // Update UI
                const autoRestartContainer = document.querySelector('.tesco-auto-restart');
                if (autoRestartContainer) {
                    autoRestartContainer.classList.add('restarting');
                }

                // Update restart count display
                const countEl = document.getElementById('auto-restart-count');
                const countValue = document.getElementById('restart-count-value');
                if (countEl && countValue) {
                    countEl.style.display = 'inline';
                    countValue.textContent = state.tescoAutoRestartCount;
                }

                this.addActivityLogEntry(`üîÑ Auto-restart #${state.tescoAutoRestartCount} triggered (${reason})`, 'warning');

                try {
                    // Check if stop was requested before starting
                    if (state.tescoStopRequested) {
                        console.log('[Auto-Restart] ABORTED - Stop was requested');
                        this.addActivityLogEntry('Auto-restart cancelled - stop requested', 'info');
                        return;
                    }

                    // Step 1: Pause the build
                    console.log('[Auto-Restart] Step 1: Pausing build...');
                    const pauseTescoBuild = firebase.functions().httpsCallable('pauseTescoBuild');
                    const pauseResult = await pauseTescoBuild();
                    console.log('[Auto-Restart] Pause result:', pauseResult.data);
                    this.addActivityLogEntry('Build paused for restart', 'info');

                    // Check again if stop was requested during pause
                    if (state.tescoStopRequested) {
                        console.log('[Auto-Restart] ABORTED - Stop was requested during pause');
                        this.addActivityLogEntry('Auto-restart cancelled - stop requested', 'info');
                        return;
                    }

                    // Step 2: Wait for function to stop
                    // Simple fixed wait - the Cloud Function checks pause status between search terms
                    // Wait 15 seconds which should be enough for any term to complete
                    console.log('[Auto-Restart] Step 2: Waiting 15 seconds for function to stop...');
                    this.addActivityLogEntry('Waiting 15s for function to stop...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 15000));

                    // Check AGAIN if stop was requested during wait
                    if (state.tescoStopRequested) {
                        console.log('[Auto-Restart] ABORTED - Stop was requested during wait');
                        this.addActivityLogEntry('Auto-restart cancelled - stop requested', 'info');
                        return;
                    }

                    this.addActivityLogEntry('Wait complete, resuming...', 'success');

                    // Step 3: Resume the build
                    console.log('[Auto-Restart] Step 3: Resuming build...');
                    const startTescoBuild = firebase.functions().httpsCallable('startTescoBuild');
                    const result = await startTescoBuild();
                    console.log('[Auto-Restart] Resume result:', result.data);

                    if (result.data.success) {
                        state.tescoLastUpdateTime = Date.now();
                        this.addActivityLogEntry('‚úÖ Build resumed successfully', 'success');
                        console.log('[Auto-Restart] === Success! Build resumed ===');
                    } else {
                        throw new Error(result.data.message || result.data.error || 'Resume failed');
                    }
                } catch (error) {
                    console.error('[Auto-Restart] FAILED:', error);
                    this.addActivityLogEntry(`‚ùå Auto-restart failed: ${error.message}`, 'error');
                    this.showToast('Auto-restart failed: ' + error.message, 'error');
                } finally {
                    state.tescoAutoRestarting = false;
                    console.log('[Auto-Restart] Cleanup - restarting polling');

                    // Remove restarting class
                    const autoRestartContainer = document.querySelector('.tesco-auto-restart');
                    if (autoRestartContainer) {
                        autoRestartContainer.classList.remove('restarting');
                    }

                    // Always restart polling
                    this.startTescoProgressPolling();

                    // Refresh UI
                    this.refreshTescoProgress();
                }
            },

            // =============================================
            // AI FOOD CATEGORIZATION FUNCTIONS
            // =============================================

            // Available categories (loaded from API)
            availableCategories: [],

            // Load categories from API
            async loadCategories() {
                try {
                    const response = await fetch(`${CONFIG.API_BASE}/getCategories`);
                    const data = await response.json();
                    if (data.success) {
                        this.availableCategories = data.categories;
                        this.renderCategoryChips();
                    }
                } catch (error) {
                    console.error('Failed to load categories:', error);
                }
            },

            // Render category chips in the reference section
            renderCategoryChips() {
                const container = document.getElementById('category-chips-container');
                if (!container || !this.availableCategories.length) return;

                container.innerHTML = this.availableCategories.map(cat => `
                    <div class="category-chip" data-category="${cat.id}" title="${cat.description} - Default: ${cat.defaultServingSize}${cat.servingUnit}">
                        ${cat.name}
                    </div>
                `).join('');
            },

            // Store pulled foods for categorization
            pulledFoods: [],
            categorizationStopped: false,

            // Stop categorization
            stopCategorization() {
                this.categorizationStopped = true;
                document.getElementById('cat-stop-btn').textContent = '‚è≥ Stopping...';
                document.getElementById('cat-stop-btn').disabled = true;
            },

            // Reset categorization progress to start fresh
            async resetCategorization() {
                const collection = document.getElementById('cat-collection-select').value;
                if (!confirm(`Reset progress for ${collection}? This will start the categorization from the beginning.`)) {
                    return;
                }

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/resetCategorizationProgress`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ collection })
                    });

                    const data = await response.json();
                    if (data.success) {
                        this.showToast('Progress reset. Click Start to begin fresh.', 'success');
                        document.getElementById('cat-reset-btn').style.display = 'none';
                        document.getElementById('cat-start-btn').textContent = 'ü§ñ Start AI Categorization';
                        this.existingProgress = null;
                    } else {
                        throw new Error(data.error);
                    }
                } catch (error) {
                    this.showToast('Failed to reset progress: ' + error.message, 'error');
                }
            },

            // Check for existing progress on a collection
            async checkExistingProgress(collection) {
                try {
                    const response = await fetch(`${CONFIG.API_BASE}/getCategorizationProgress?collection=${collection}`);
                    const data = await response.json();

                    if (data.success && data.hasProgress && data.progress.status !== 'complete') {
                        this.existingProgress = data.progress;
                        return data.progress;
                    }
                    this.existingProgress = null;
                    return null;
                } catch (error) {
                    console.error('Failed to check progress:', error);
                    return null;
                }
            },

            // Pull foods from database for preview
            async pullUncategorizedFoods() {
                const collection = document.getElementById('cat-collection-select').value;
                const batchSizeValue = document.getElementById('cat-batch-size').value;
                const previewLimit = 50; // Show first 50 for preview

                const pullBtn = document.getElementById('cat-pull-btn');
                const startBtn = document.getElementById('cat-start-btn');
                const previewSection = document.getElementById('cat-preview-section');
                const previewList = document.getElementById('cat-preview-list');
                const previewCount = document.getElementById('cat-preview-count');

                pullBtn.disabled = true;
                pullBtn.textContent = '‚è≥ Loading...';

                try {
                    // Fetch actual foods for preview
                    const response = await fetch(`${CONFIG.API_BASE}/getFoodsForCategorization?collection=${collection}&limit=${previewLimit}`);
                    const data = await response.json();

                    if (!data.success) {
                        throw new Error(data.error || 'Failed to get foods');
                    }

                    const totalFoods = data.total;

                    if (totalFoods === 0) {
                        previewSection.style.display = 'block';
                        previewList.innerHTML = '<div class="preview-item"><span class="food-name">‚ö†Ô∏è No foods found in this collection</span></div>';
                        previewCount.textContent = '0 foods';
                        startBtn.disabled = true;
                        this.showToast('No foods in this collection', 'warning');
                        return;
                    }

                    // Store info for categorization
                    this.pulledFoods = {
                        collection: collection,
                        count: totalFoods,
                        batchSize: batchSizeValue
                    };

                    // Show preview section
                    previewSection.style.display = 'block';
                    previewCount.textContent = `${totalFoods.toLocaleString()} total foods`;

                    // Build preview list with actual food items
                    let html = `
                        <div class="preview-item" style="background: #dbeafe; padding: 12px 16px; border-left: 3px solid #3b82f6;">
                            <span style="font-size: 13px; color: #1e40af;">
                                üìä <strong>${totalFoods.toLocaleString()}</strong> foods in <strong>${collection}</strong> |
                                Mode: <strong>${batchSizeValue === 'all' ? 'Full Scan' : batchSizeValue + ' per batch'}</strong>
                            </span>
                        </div>
                    `;

                    // Show actual food items
                    data.foods.forEach((food, index) => {
                        const categoryBadge = food.currentCategory
                            ? `<span style="background: #e0e7ff; color: #3730a3; padding: 2px 8px; border-radius: 10px; font-size: 11px;">${food.currentCategoryName || food.currentCategory}</span>`
                            : `<span style="background: #fef3c7; color: #92400e; padding: 2px 8px; border-radius: 10px; font-size: 11px;">No category</span>`;

                        html += `
                            <div class="preview-item">
                                <span style="color: #9ca3af; font-size: 12px; min-width: 30px;">${index + 1}.</span>
                                <span class="food-name">${this.escapeHtml(food.foodName)}</span>
                                ${food.brandName ? `<span class="brand-name">${this.escapeHtml(food.brandName)}</span>` : ''}
                                ${categoryBadge}
                            </div>
                        `;
                    });

                    if (totalFoods > previewLimit) {
                        html += `
                            <div class="preview-item" style="background: #f3f4f6; justify-content: center;">
                                <span style="color: #6b7280; font-size: 13px;">... and ${(totalFoods - previewLimit).toLocaleString()} more foods</span>
                            </div>
                        `;
                    }

                    previewList.innerHTML = html;

                    // Check for existing progress
                    const progress = await this.checkExistingProgress(collection);
                    const resetBtn = document.getElementById('cat-reset-btn');

                    if (progress && progress.totalProcessed > 0) {
                        // Show resume option
                        const percent = Math.round((progress.totalProcessed / progress.totalFoods) * 100);
                        startBtn.textContent = `‚ñ∂Ô∏è Resume (${percent}% done)`;
                        resetBtn.style.display = 'inline-block';

                        // Add progress info to preview
                        const progressInfo = document.createElement('div');
                        progressInfo.className = 'preview-item';
                        progressInfo.style.cssText = 'background: #fef3c7; padding: 12px 16px; border-left: 3px solid #f59e0b;';
                        progressInfo.innerHTML = `
                            <span style="font-size: 13px; color: #92400e;">
                                ‚è∏Ô∏è <strong>Previous progress found:</strong> ${progress.totalProcessed.toLocaleString()} / ${progress.totalFoods.toLocaleString()} foods (${percent}%)
                                | Click Resume to continue or Start Fresh to restart
                            </span>
                        `;
                        previewList.insertBefore(progressInfo, previewList.firstChild);

                        this.showToast(`Found existing progress: ${percent}% complete. Click Resume to continue.`, 'info');
                    } else {
                        startBtn.textContent = 'ü§ñ Start AI Categorization';
                        resetBtn.style.display = 'none';
                    }

                    // Enable start button
                    startBtn.disabled = false;
                    this.showToast(`Loaded ${totalFoods.toLocaleString()} foods ready to categorize`, 'success');

                } catch (error) {
                    console.error('Failed to pull foods:', error);
                    this.showToast('Failed to pull data: ' + error.message, 'error');
                    previewSection.style.display = 'none';
                    startBtn.disabled = true;
                } finally {
                    pullBtn.disabled = false;
                    pullBtn.textContent = 'üì• Pull Data';
                }
            },

            // Refresh category statistics
            async refreshCategoryStats() {
                const collection = document.getElementById('cat-collection-select').value;

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/getCategorizeStats?collection=${collection}`);
                    const data = await response.json();

                    if (data.success) {
                        const stats = data.stats;
                        document.getElementById('cat-stat-total').textContent = stats.total.toLocaleString();
                        document.getElementById('cat-stat-categorized').textContent = stats.categorized.toLocaleString();
                        document.getElementById('cat-stat-uncategorized').textContent = stats.uncategorized.toLocaleString();
                        document.getElementById('cat-stat-percent').textContent = stats.percentCategorized + '%';

                        // Update distribution grid
                        this.renderDistribution(stats.categorySample);
                    }
                } catch (error) {
                    console.error('Failed to load stats:', error);
                    this.showToast('Failed to load statistics: ' + error.message, 'error');
                }
            },

            // Render category distribution
            renderDistribution(categorySample) {
                const container = document.getElementById('cat-distribution-grid');
                if (!container) return;

                if (!categorySample || Object.keys(categorySample).length === 0) {
                    container.innerHTML = '<p class="empty-state">No categorization data yet. Run a categorization batch to see distribution.</p>';
                    return;
                }

                // Sort by count descending
                const sorted = Object.entries(categorySample)
                    .sort((a, b) => b[1] - a[1]);

                container.innerHTML = sorted.map(([categoryId, count]) => {
                    const category = this.availableCategories.find(c => c.id === categoryId);
                    const name = category ? category.name : categoryId;
                    return `
                        <div class="distribution-item">
                            <span class="category-name">${name}</span>
                            <span class="category-count">${count}</span>
                        </div>
                    `;
                }).join('');
            },

            // Start AI categorization (save results)
            async startCategorization() {
                await this.runCategorization(true);
            },

            // Preview categorization (don't save)
            async previewCategorization() {
                await this.runCategorization(false);
            },

            // Run categorization (resume = true to continue from where we left off)
            async runCategorization(saveResults = true, resumeFromProgress = true) {
                const collection = document.getElementById('cat-collection-select').value;
                const batchSizeValue = document.getElementById('cat-batch-size').value;
                const isFullScan = batchSizeValue === 'all';
                const batchSize = isFullScan ? 500 : parseInt(batchSizeValue); // Process 500 at a time for full scan
                const totalFoods = this.pulledFoods?.count || 0;

                const progressSection = document.getElementById('cat-progress-section');
                const resultsSection = document.getElementById('cat-results-section');
                const startBtn = document.getElementById('cat-start-btn');
                const stopBtn = document.getElementById('cat-stop-btn');

                // Reset stop flag and show stop button
                this.categorizationStopped = false;
                stopBtn.style.display = 'inline-block';
                stopBtn.disabled = false;
                stopBtn.textContent = '‚èπÔ∏è Stop';

                // Show progress
                progressSection.style.display = 'block';
                resultsSection.style.display = 'none';
                startBtn.disabled = true;
                startBtn.textContent = isFullScan ? 'Full Scan Running...' : 'Processing...';

                const statusBadge = document.getElementById('cat-status-badge');
                const progressText = document.getElementById('cat-progress-text');
                const progressBar = document.getElementById('cat-progress-bar');

                statusBadge.textContent = 'Processing';
                statusBadge.className = 'status-badge status-running';
                progressBar.style.width = '0%';

                let allResults = [];
                let totalProcessed = 0;
                let hasMore = true;
                let isFirstBatch = true;

                try {
                    if (isFullScan) {
                        // Full database scan - process ALL foods with backend progress tracking
                        progressText.textContent = resumeFromProgress
                            ? `Checking for existing progress on ${collection}...`
                            : `Starting fresh scan of ${collection} (${totalFoods.toLocaleString()} foods)...`;

                        while (hasMore && !this.categorizationStopped) {
                            const response = await fetch(`${CONFIG.API_BASE}/categorizeFoodsFromDatabase`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    collection,
                                    limit: batchSize,
                                    saveResults,
                                    resume: isFirstBatch ? resumeFromProgress : true, // First batch: respect user choice, then always resume
                                    onlyUncategorized: false // Process ALL foods, overwrite existing
                                })
                            });

                            const data = await response.json();
                            isFirstBatch = false;

                            if (!data.success) {
                                throw new Error(data.error || 'Batch failed');
                            }

                            if (data.results && data.results.length > 0) {
                                allResults = allResults.concat(data.results);
                            }

                            // Use backend's progress tracking
                            totalProcessed = data.totalProcessed || totalProcessed + (data.processed || 0);
                            const serverTotalFoods = data.totalFoods || totalFoods;
                            hasMore = data.hasMore !== undefined ? data.hasMore : false;

                            // Update progress from server
                            const percent = data.percentComplete || (serverTotalFoods > 0 ? Math.round((totalProcessed / serverTotalFoods) * 100) : 100);
                            progressBar.style.width = Math.min(percent, 100) + '%';
                            progressText.textContent = `Processed ${totalProcessed.toLocaleString()} / ${serverTotalFoods.toLocaleString()} foods (${percent}%)`;

                            // Small delay to prevent rate limiting
                            if (hasMore && !this.categorizationStopped) {
                                await new Promise(r => setTimeout(r, 100)); // 100ms delay between batches
                            }
                        }

                        // Check if stopped by user
                        if (this.categorizationStopped) {
                            statusBadge.textContent = 'Paused';
                            statusBadge.className = 'status-badge status-warning';
                            progressText.textContent = `Paused at ${totalProcessed.toLocaleString()} foods. Progress saved - click Start to resume.`;
                            this.showToast(`Categorization paused. Progress saved. Click Start to resume.`, 'warning');
                        } else {
                            progressBar.style.width = '100%';
                            statusBadge.textContent = 'Complete';
                            statusBadge.className = 'status-badge status-idle';
                            progressText.textContent = `Full scan complete: ${totalProcessed.toLocaleString()} foods categorized`;
                        }

                        // Show results (limit display to last 100)
                        this.renderResults({
                            processed: totalProcessed,
                            results: allResults.slice(-100),
                            totalRemaining: 0,
                            newCategoriesCreated: allResults.filter(r => r.isNewCategory).length > 0
                                ? allResults.filter(r => r.isNewCategory).map(r => ({ name: r.categoryName }))
                                : []
                        }, saveResults, allResults.length > 100 ? `Showing last 100 of ${allResults.length} results` : null);
                        resultsSection.style.display = 'block';

                        await this.refreshCategoryStats();
                        if (!this.categorizationStopped) {
                            this.showToast(`Full scan complete: ${totalProcessed.toLocaleString()} foods categorized${saveResults ? ' and saved' : ''}`, 'success');
                        }

                    } else {
                        // Single batch processing
                        progressText.textContent = `Categorizing ${batchSize} foods from ${collection}...`;

                        let progress = 0;
                        const progressInterval = setInterval(() => {
                            if (progress < 90) {
                                progress += 5;
                                progressBar.style.width = progress + '%';
                            }
                        }, 500);

                        const response = await fetch(`${CONFIG.API_BASE}/categorizeFoodsFromDatabase`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                collection,
                                limit: batchSize,
                                offset: 0,
                                saveResults,
                                onlyUncategorized: false // Process all, overwrite existing
                            })
                        });

                        clearInterval(progressInterval);
                        progressBar.style.width = '100%';

                        const data = await response.json();

                        if (data.success) {
                            statusBadge.textContent = 'Complete';
                            statusBadge.className = 'status-badge status-idle';
                            progressText.textContent = `Processed ${data.processed} foods`;

                            this.renderResults(data, saveResults);
                            resultsSection.style.display = 'block';

                            await this.refreshCategoryStats();
                            this.showToast(`Successfully categorized ${data.processed} foods${saveResults ? ' and saved to database' : ' (preview only)'}`, 'success');
                        } else {
                            throw new Error(data.error || 'Categorization failed');
                        }
                    }
                } catch (error) {
                    console.error('Categorization error:', error);
                    statusBadge.textContent = 'Error';
                    statusBadge.className = 'status-badge status-error';
                    progressText.textContent = `Error after ${totalProcessed} foods: ${error.message}`;
                    this.showToast('Categorization failed: ' + error.message, 'error');

                    // Still show partial results if we have any
                    if (allResults.length > 0) {
                        this.renderResults({
                            processed: totalProcessed,
                            results: allResults.slice(-100),
                            totalRemaining: 'unknown'
                        }, saveResults, `Partial results (${totalProcessed} processed before error)`);
                        resultsSection.style.display = 'block';
                    }
                } finally {
                    startBtn.disabled = false;
                    startBtn.textContent = 'ü§ñ Start AI Categorization';
                    stopBtn.style.display = 'none';
                    stopBtn.disabled = false;
                    stopBtn.textContent = '‚èπÔ∏è Stop';
                }
            },

            // Render categorization results
            renderResults(data, saved) {
                const summaryEl = document.getElementById('cat-results-summary');
                const listEl = document.getElementById('cat-results-list');

                // Check for new categories created
                const newCats = data.newCategoriesCreated || [];
                const newCatHtml = newCats.length > 0
                    ? `<br><span style="color: #10b981;">‚ú® ${newCats.length} new categories created: ${newCats.map(c => c.name).join(', ')}</span>`
                    : '';

                summaryEl.innerHTML = `
                    <strong>${data.processed} foods categorized</strong>
                    ${saved ? ' and saved to database' : ' (preview only - not saved)'}
                    ${data.totalRemaining !== 'N/A' ? ` | ${data.totalRemaining} uncategorized remaining` : ''}
                    ${newCatHtml}
                `;

                if (!data.results || data.results.length === 0) {
                    listEl.innerHTML = '<p class="empty-state">No results to display</p>';
                    return;
                }

                listEl.innerHTML = data.results.map(result => `
                    <div class="result-item">
                        <span class="food-name">${this.escapeHtml(result.foodName)}</span>
                        <span class="category-badge ${result.isNewCategory ? 'new-category' : ''}">${result.categoryName}${result.isNewCategory ? ' ‚ú®' : ''}</span>
                        <span class="serving-info">${result.suggestedServingSize}${result.servingUnit}</span>
                        <span class="confidence-badge ${result.confidence}">${result.confidence}</span>
                    </div>
                `).join('');
            },

            // Initialize categories view
            // Handle collection dropdown change
            async onCollectionChange() {
                // Hide preview and disable start button when collection changes
                document.getElementById('cat-preview-section').style.display = 'none';
                document.getElementById('cat-start-btn').disabled = true;
                this.pulledFoods = [];

                // Refresh stats for new collection
                await this.refreshCategoryStats();
            },

            async initCategoriesView() {
                if (!this.availableCategories.length) {
                    await this.loadCategories();
                }
                await this.refreshCategoryStats();
            },

            // =============================================
            // AI DATA VALIDATION FUNCTIONS
            // =============================================

            validationStopped: false,
            validationProgress: null,
            pulledValidationFoods: [],

            // Stop validation
            stopValidation() {
                this.validationStopped = true;
                document.getElementById('val-stop-btn').textContent = '‚è≥ Stopping...';
                document.getElementById('val-stop-btn').disabled = true;
            },

            // Reset validation progress
            async resetValidation() {
                const collection = document.getElementById('val-collection-select').value;
                if (!confirm(`Reset validation progress for ${collection}? This will start from the beginning.`)) {
                    return;
                }

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/resetValidationProgress`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ collection })
                    });

                    const data = await response.json();
                    if (data.success) {
                        this.showToast('Progress reset. Click Start to begin fresh.', 'success');
                        document.getElementById('val-reset-btn').style.display = 'none';
                        document.getElementById('val-start-btn').textContent = 'üîç Start AI Validation';
                        this.validationProgress = null;
                    } else {
                        throw new Error(data.error);
                    }
                } catch (error) {
                    this.showToast('Failed to reset progress: ' + error.message, 'error');
                }
            },

            // Check for existing validation progress
            async checkValidationProgress(collection) {
                try {
                    const response = await fetch(`${CONFIG.API_BASE}/getValidationProgress?collection=${collection}`);
                    const data = await response.json();

                    if (data.success && data.hasProgress && data.progress.status !== 'complete') {
                        this.validationProgress = data.progress;
                        return data.progress;
                    }
                    this.validationProgress = null;
                    return null;
                } catch (error) {
                    console.error('Failed to check progress:', error);
                    return null;
                }
            },

            // Pull foods for validation preview
            async pullFoodsForValidation() {
                const collection = document.getElementById('val-collection-select').value;
                const batchSizeValue = document.getElementById('val-batch-size').value;
                const previewLimit = 50;

                const pullBtn = document.getElementById('val-pull-btn');
                const startBtn = document.getElementById('val-start-btn');
                const previewSection = document.getElementById('val-preview-section');
                const previewList = document.getElementById('val-preview-list');
                const previewCount = document.getElementById('val-preview-count');

                pullBtn.disabled = true;
                pullBtn.textContent = '‚è≥ Loading...';

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/getFoodsForValidation?collection=${collection}&limit=${previewLimit}`);
                    const data = await response.json();

                    if (!data.success) {
                        throw new Error(data.error || 'Failed to get foods');
                    }

                    const totalFoods = data.total;

                    if (totalFoods === 0) {
                        previewSection.style.display = 'block';
                        previewList.innerHTML = '<div class="preview-item"><span class="food-name">‚ö†Ô∏è No foods found in this collection</span></div>';
                        previewCount.textContent = '0 foods';
                        startBtn.disabled = true;
                        this.showToast('No foods in this collection', 'warning');
                        return;
                    }

                    this.pulledValidationFoods = {
                        collection: collection,
                        count: totalFoods,
                        batchSize: batchSizeValue
                    };

                    previewSection.style.display = 'block';
                    previewCount.textContent = `${totalFoods.toLocaleString()} total foods`;

                    let html = `
                        <div class="preview-item" style="background: #dbeafe; padding: 12px 16px; border-left: 3px solid #3b82f6;">
                            <span style="font-size: 13px; color: #1e40af;">
                                üìä <strong>${totalFoods.toLocaleString()}</strong> foods in <strong>${collection}</strong> |
                                Mode: <strong>${batchSizeValue === 'all' ? 'Full Scan' : batchSizeValue + ' per batch'}</strong>
                            </span>
                        </div>
                    `;

                    data.foods.forEach((food, index) => {
                        const statusBadge = food.lastValidated === 'Validated'
                            ? `<span style="background: #dcfce7; color: #15803d; padding: 2px 8px; border-radius: 10px; font-size: 11px;">‚úÖ Validated</span>`
                            : `<span style="background: #fef3c7; color: #92400e; padding: 2px 8px; border-radius: 10px; font-size: 11px;">Not validated</span>`;

                        const caloriesBadge = food.calories
                            ? `<span style="color: #6b7280; font-size: 11px;">${food.calories} kcal</span>`
                            : '';

                        html += `
                            <div class="preview-item">
                                <span style="color: #9ca3af; font-size: 12px; min-width: 30px;">${index + 1}.</span>
                                <span class="food-name">${this.escapeHtml(food.foodName)}</span>
                                ${food.brandName ? `<span class="brand-name">${this.escapeHtml(food.brandName)}</span>` : ''}
                                ${caloriesBadge}
                                ${statusBadge}
                            </div>
                        `;
                    });

                    if (totalFoods > previewLimit) {
                        html += `
                            <div class="preview-item" style="background: #f3f4f6; justify-content: center;">
                                <span style="color: #6b7280; font-size: 13px;">... and ${(totalFoods - previewLimit).toLocaleString()} more foods</span>
                            </div>
                        `;
                    }

                    previewList.innerHTML = html;

                    // Check for existing progress
                    const progress = await this.checkValidationProgress(collection);
                    const resetBtn = document.getElementById('val-reset-btn');

                    if (progress && progress.totalProcessed > 0) {
                        const percent = Math.round((progress.totalProcessed / progress.totalFoods) * 100);
                        startBtn.textContent = `‚ñ∂Ô∏è Resume (${percent}% done)`;
                        resetBtn.style.display = 'inline-block';

                        const progressInfo = document.createElement('div');
                        progressInfo.className = 'preview-item';
                        progressInfo.style.cssText = 'background: #fef3c7; padding: 12px 16px; border-left: 3px solid #f59e0b;';
                        progressInfo.innerHTML = `
                            <span style="font-size: 13px; color: #92400e;">
                                ‚è∏Ô∏è <strong>Previous progress found:</strong> ${progress.totalProcessed.toLocaleString()} / ${progress.totalFoods.toLocaleString()} foods (${percent}%)
                                | ${progress.updatedCount || 0} updated, ${progress.markedForDeletionCount || 0} marked for deletion
                            </span>
                        `;
                        previewList.insertBefore(progressInfo, previewList.firstChild);

                        this.showToast(`Found existing progress: ${percent}% complete. Click Resume to continue.`, 'info');
                    } else {
                        startBtn.textContent = 'üîç Start AI Validation';
                        resetBtn.style.display = 'none';
                    }

                    startBtn.disabled = false;
                    this.showToast(`Loaded ${totalFoods.toLocaleString()} foods ready to validate`, 'success');

                } catch (error) {
                    console.error('Failed to pull foods:', error);
                    this.showToast('Failed to pull data: ' + error.message, 'error');
                    previewSection.style.display = 'none';
                    startBtn.disabled = true;
                } finally {
                    pullBtn.disabled = false;
                    pullBtn.textContent = 'üì• Pull Data';
                }
            },

            // Refresh validation statistics
            async refreshValidationStats() {
                const collection = document.getElementById('val-collection-select').value;

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/getValidationStats?collection=${collection}`);
                    const data = await response.json();

                    if (data.success) {
                        const stats = data.stats;
                        document.getElementById('val-stat-total').textContent = stats.total.toLocaleString();
                        document.getElementById('val-stat-validated').textContent = stats.validated.toLocaleString();
                        document.getElementById('val-stat-unvalidated').textContent = stats.unvalidated.toLocaleString();
                        document.getElementById('val-stat-deletion').textContent = stats.markedForDeletion.toLocaleString();
                    }
                } catch (error) {
                    console.error('Failed to load stats:', error);
                    this.showToast('Failed to load statistics: ' + error.message, 'error');
                }

                // Also refresh marked for deletion list
                await this.refreshMarkedForDeletion();
            },

            // Start AI validation
            async startValidation() {
                await this.runValidation(true);
            },

            // Run validation
            async runValidation(saveResults = true) {
                const collection = document.getElementById('val-collection-select').value;
                const batchSizeValue = document.getElementById('val-batch-size').value;
                const isFullScan = batchSizeValue === 'all';
                const batchSize = isFullScan ? 500 : parseInt(batchSizeValue);
                const totalFoods = this.pulledValidationFoods?.count || 0;

                const progressSection = document.getElementById('val-progress-section');
                const resultsSection = document.getElementById('val-results-section');
                const startBtn = document.getElementById('val-start-btn');
                const stopBtn = document.getElementById('val-stop-btn');

                this.validationStopped = false;
                stopBtn.style.display = 'inline-block';
                stopBtn.disabled = false;
                stopBtn.textContent = '‚èπÔ∏è Stop';

                startBtn.disabled = true;
                startBtn.textContent = '‚è≥ Processing...';

                progressSection.style.display = 'block';
                resultsSection.style.display = 'none';

                let totalProcessed = 0;
                let totalUpdated = 0;
                let totalMarkedForDeletion = 0;
                let allResults = [];
                let hasMore = true;
                let batchCount = 0;

                try {
                    while (hasMore && !this.validationStopped) {
                        batchCount++;
                        const currentBatch = isFullScan ? 500 : batchSize;

                        const response = await fetch(`${CONFIG.API_BASE}/validateFoodsFromDatabase`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                collection,
                                limit: currentBatch,
                                saveResults,
                                resume: true
                            })
                        });

                        const data = await response.json();

                        if (!data.success) {
                            throw new Error(data.error || 'Validation failed');
                        }

                        totalProcessed = data.totalProcessed;
                        totalUpdated = data.updatedCount || 0;
                        totalMarkedForDeletion = data.markedForDeletionCount || 0;
                        hasMore = data.hasMore && isFullScan;

                        if (data.results) {
                            allResults = [...allResults, ...data.results].slice(-100);
                        }

                        // Update progress UI
                        const percent = data.percentComplete || Math.round((totalProcessed / totalFoods) * 100);
                        document.getElementById('val-progress-bar').style.width = `${percent}%`;
                        document.getElementById('val-progress-text').textContent =
                            `Processing ${totalProcessed.toLocaleString()} / ${totalFoods.toLocaleString()} foods... (${percent}%)`;
                        document.getElementById('val-status-badge').textContent = `Batch ${batchCount}`;
                        document.getElementById('val-updates-count').textContent = `${totalUpdated.toLocaleString()} updated`;
                        document.getElementById('val-deletions-count').textContent = `${totalMarkedForDeletion.toLocaleString()} marked for deletion`;

                        // Delay between batches
                        if (hasMore && !this.validationStopped) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }

                        // Break for single batch mode
                        if (!isFullScan) break;
                    }

                    // Show completion status
                    if (this.validationStopped) {
                        document.getElementById('val-status-badge').textContent = 'Paused';
                        document.getElementById('val-status-badge').classList.add('status-warning');
                        this.showToast(`Validation paused at ${totalProcessed.toLocaleString()} foods. Progress saved.`, 'info');
                    } else if (!hasMore) {
                        document.getElementById('val-status-badge').textContent = 'Complete';
                        document.getElementById('val-status-badge').classList.add('status-success');
                        this.showToast(`Validation complete! ${totalUpdated} updated, ${totalMarkedForDeletion} marked for deletion.`, 'success');
                    }

                    // Show results
                    this.renderValidationResults({
                        processed: totalProcessed,
                        updatedCount: totalUpdated,
                        markedForDeletionCount: totalMarkedForDeletion,
                        results: allResults
                    }, saveResults);
                    resultsSection.style.display = 'block';

                    // Refresh stats and deletion list
                    await this.refreshValidationStats();

                } catch (error) {
                    console.error('Validation error:', error);
                    this.showToast('Validation error: ' + error.message, 'error');
                    document.getElementById('val-status-badge').textContent = 'Error';
                    document.getElementById('val-status-badge').classList.add('status-error');
                } finally {
                    startBtn.disabled = false;
                    startBtn.textContent = 'üîç Start AI Validation';
                    stopBtn.style.display = 'none';
                    stopBtn.disabled = false;
                    stopBtn.textContent = '‚èπÔ∏è Stop';
                }
            },

            // Render validation results
            renderValidationResults(data, saved) {
                const summaryEl = document.getElementById('val-results-summary');
                const listEl = document.getElementById('val-results-list');

                summaryEl.innerHTML = `
                    <strong>${data.processed.toLocaleString()} foods validated</strong>
                    ${saved ? ' and changes saved to database' : ' (preview only)'}
                    <br>
                    <span style="color: #22c55e;">‚úèÔ∏è ${data.updatedCount || 0} updated</span> |
                    <span style="color: #ef4444;">üóëÔ∏è ${data.markedForDeletionCount || 0} marked for deletion</span>
                `;

                if (!data.results || data.results.length === 0) {
                    listEl.innerHTML = '<p class="empty-state">No detailed results to display</p>';
                    return;
                }

                listEl.innerHTML = data.results.map(result => {
                    const actionBadge = {
                        'update': '<span class="category-badge" style="background: #dcfce7; color: #15803d;">Updated</span>',
                        'delete': '<span class="category-badge" style="background: #fee2e2; color: #b91c1c;">Delete</span>',
                        'review': '<span class="category-badge" style="background: #fef3c7; color: #92400e;">Review</span>',
                        'none': '<span class="category-badge" style="background: #f3f4f6; color: #6b7280;">No Change</span>'
                    }[result.action] || '';

                    const changes = result.changes && result.changes.length > 0
                        ? `<div style="font-size: 12px; color: #6b7280; margin-top: 4px;">${result.changes.join(', ')}</div>`
                        : '';

                    const deleteReason = result.deleteReason
                        ? `<div style="font-size: 12px; color: #b91c1c; margin-top: 4px;">Reason: ${result.deleteReason}</div>`
                        : '';

                    return `
                        <div class="result-item" style="flex-direction: column; align-items: flex-start;">
                            <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                                <span class="food-name">${this.escapeHtml(result.originalFood?.foodName || 'Unknown')}</span>
                                ${result.originalFood?.brandName ? `<span class="brand-name">${this.escapeHtml(result.originalFood.brandName)}</span>` : ''}
                                ${actionBadge}
                                <span class="confidence-badge ${result.confidence}">${result.confidence}</span>
                            </div>
                            ${changes}
                            ${deleteReason}
                        </div>
                    `;
                }).join('');
            },

            // Handle validation collection change
            async onValidationCollectionChange() {
                document.getElementById('val-preview-section').style.display = 'none';
                document.getElementById('val-start-btn').disabled = true;
                this.pulledValidationFoods = [];

                await this.refreshValidationStats();
            },

            // Initialize validation view
            async initValidationView() {
                await this.refreshValidationStats();
            },

            // Refresh marked for deletion list
            async refreshMarkedForDeletion() {
                const collection = document.getElementById('val-collection-select').value;
                const listEl = document.getElementById('val-deletion-list');
                const deleteAllBtn = document.getElementById('val-delete-all-btn');
                const clearListBtn = document.getElementById('val-clear-list-btn');

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/getMarkedForDeletion?collection=${collection}`);
                    const data = await response.json();

                    if (!data.success) {
                        throw new Error(data.error);
                    }

                    if (!data.items || data.items.length === 0) {
                        listEl.innerHTML = '<p class="empty-state">No items marked for deletion yet. Run validation to identify problematic products.</p>';
                        deleteAllBtn.style.display = 'none';
                        clearListBtn.style.display = 'none';
                        return;
                    }

                    deleteAllBtn.style.display = 'inline-block';
                    clearListBtn.style.display = 'inline-block';

                    listEl.innerHTML = data.items.map(item => `
                        <div class="preview-item" style="flex-direction: column; align-items: flex-start; padding: 12px;" data-item-id="${item.id}">
                            <div style="display: flex; align-items: center; gap: 8px; width: 100%;">
                                <input type="checkbox" class="deletion-checkbox" data-id="${item.id}" checked>
                                <span class="food-name" style="flex: 1;">${this.escapeHtml(item.foodName)}</span>
                                ${item.brandName ? `<span class="brand-name">${this.escapeHtml(item.brandName)}</span>` : ''}
                                <span class="confidence-badge ${item.confidence}">${item.confidence}</span>
                            </div>
                            <div style="font-size: 12px; color: #b91c1c; margin-top: 4px; padding-left: 24px;">
                                ${this.escapeHtml(item.reason)}
                            </div>
                            <div style="margin-top: 8px; padding-left: 24px;">
                                <button class="btn btn-danger btn-sm" onclick="app.deleteSingleItem('${item.id}')">üóëÔ∏è Delete</button>
                                <button class="btn btn-secondary btn-sm" onclick="app.unmarkSingleItem('${item.id}')">‚úì Keep</button>
                            </div>
                        </div>
                    `).join('');

                } catch (error) {
                    console.error('Failed to load marked items:', error);
                    listEl.innerHTML = '<p class="empty-state">Error loading marked items.</p>';
                }
            },

            // Delete all marked items
            async deleteAllMarked() {
                const collection = document.getElementById('val-collection-select').value;
                const checkboxes = document.querySelectorAll('.deletion-checkbox:checked');
                const itemIds = Array.from(checkboxes).map(cb => cb.dataset.id);

                if (itemIds.length === 0) {
                    this.showToast('No items selected for deletion', 'warning');
                    return;
                }

                if (!confirm(`Are you sure you want to permanently delete ${itemIds.length} items from ${collection}? This cannot be undone.`)) {
                    return;
                }

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/deleteMarkedItems`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ collection, itemIds })
                    });

                    const data = await response.json();

                    if (data.success) {
                        this.showToast(`Deleted ${data.deleted} items from ${collection}`, 'success');
                        await this.refreshValidationStats();
                    } else {
                        throw new Error(data.error);
                    }
                } catch (error) {
                    this.showToast('Failed to delete items: ' + error.message, 'error');
                }
            },

            // Delete single item
            async deleteSingleItem(itemId) {
                const collection = document.getElementById('val-collection-select').value;

                if (!confirm('Are you sure you want to permanently delete this item?')) {
                    return;
                }

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/deleteMarkedItems`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ collection, itemIds: [itemId] })
                    });

                    const data = await response.json();

                    if (data.success) {
                        this.showToast('Item deleted', 'success');
                        await this.refreshValidationStats();
                    } else {
                        throw new Error(data.error);
                    }
                } catch (error) {
                    this.showToast('Failed to delete item: ' + error.message, 'error');
                }
            },

            // Unmark single item (keep in database)
            async unmarkSingleItem(itemId) {
                const collection = document.getElementById('val-collection-select').value;

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/unmarkForDeletion`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ collection, itemIds: [itemId] })
                    });

                    const data = await response.json();

                    if (data.success) {
                        this.showToast('Item removed from deletion list', 'success');
                        await this.refreshMarkedForDeletion();
                        await this.refreshValidationStats();
                    } else {
                        throw new Error(data.error);
                    }
                } catch (error) {
                    this.showToast('Failed to unmark item: ' + error.message, 'error');
                }
            },

            // Clear entire deletion list
            async clearDeletionList() {
                const collection = document.getElementById('val-collection-select').value;

                if (!confirm('Are you sure you want to clear the entire deletion list? Items will remain in the database.')) {
                    return;
                }

                try {
                    const response = await fetch(`${CONFIG.API_BASE}/clearMarkedForDeletion`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ collection })
                    });

                    const data = await response.json();

                    if (data.success) {
                        this.showToast('Deletion list cleared', 'success');
                        await this.refreshValidationStats();
                    } else {
                        throw new Error(data.error);
                    }
                } catch (error) {
                    this.showToast('Failed to clear list: ' + error.message, 'error');
                }
            }
        };

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
</body>
</html>
